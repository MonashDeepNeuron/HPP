<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Classes - High Performance Programming</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Monash DeepNeuron&#x27;s High Performance Programming Curriculum">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../home.html">Home</a></li><li class="chapter-item expanded affix "><div>Foreword</div></li><li class="chapter-item expanded "><a href="../chapter1/chapter1.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter1/wsl.html"><strong aria-hidden="true">1.1.</strong> WSL</a></li><li class="chapter-item expanded "><a href="../chapter1/software.html"><strong aria-hidden="true">1.2.</strong> Installing Software</a></li><li class="chapter-item expanded "><a href="../chapter1/helloworld.html"><strong aria-hidden="true">1.3.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="../chapter1/godbolt.html"><strong aria-hidden="true">1.4.</strong> Compiler Explorer</a></li><li class="chapter-item expanded "><a href="../chapter1/slides1.html"><strong aria-hidden="true">1.5.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter2/chapter2.html"><strong aria-hidden="true">2.</strong> Basics of C++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter2/typesystem.html"><strong aria-hidden="true">2.1.</strong> The C++ Type System</a></li><li class="chapter-item expanded "><a href="../chapter2/types.html"><strong aria-hidden="true">2.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../chapter2/variables.html"><strong aria-hidden="true">2.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../chapter2/operators.html"><strong aria-hidden="true">2.4.</strong> Operators</a></li><li class="chapter-item expanded "><a href="../chapter2/io.html"><strong aria-hidden="true">2.5.</strong> IO</a></li><li class="chapter-item expanded "><a href="../chapter2/eqordlogic.html"><strong aria-hidden="true">2.6.</strong> Equality, Ordering &amp; Logical Operators</a></li><li class="chapter-item expanded "><a href="../chapter2/condexpr.html"><strong aria-hidden="true">2.7.</strong> Conditional Expressions</a></li><li class="chapter-item expanded "><a href="../chapter2/loops.html"><strong aria-hidden="true">2.8.</strong> Loops</a></li><li class="chapter-item expanded "><a href="../chapter2/functions.html"><strong aria-hidden="true">2.9.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../chapter2/slides2.html"><strong aria-hidden="true">2.10.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter3/chapter3.html"><strong aria-hidden="true">3.</strong> Memory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter3/pointers.html"><strong aria-hidden="true">3.1.</strong> Pointers</a></li><li class="chapter-item expanded "><a href="../chapter3/slices.html"><strong aria-hidden="true">3.2.</strong> Slices</a></li><li class="chapter-item expanded "><a href="../chapter3/references.html"><strong aria-hidden="true">3.3.</strong> References</a></li><li class="chapter-item expanded "><a href="../chapter3/memory.html"><strong aria-hidden="true">3.4.</strong> Dynamic Memory</a></li><li class="chapter-item expanded "><a href="../chapter3/stdlib.html"><strong aria-hidden="true">3.5.</strong> The Standard Library</a></li><li class="chapter-item expanded "><a href="../chapter3/slides3.html"><strong aria-hidden="true">3.6.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter4/chapter4.html"><strong aria-hidden="true">4.</strong> Intermediate C++ Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter4/advfunc.html"><strong aria-hidden="true">4.1.</strong> Advanced Function Concepts</a></li><li class="chapter-item expanded "><a href="../chapter4/namespaces.html"><strong aria-hidden="true">4.2.</strong> Namespaces</a></li><li class="chapter-item expanded "><a href="../chapter4/enums.html"><strong aria-hidden="true">4.3.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="../chapter4/unions.html"><strong aria-hidden="true">4.4.</strong> Unions</a></li><li class="chapter-item expanded "><a href="../chapter4/structs.html"><strong aria-hidden="true">4.5.</strong> Structures</a></li><li class="chapter-item expanded "><a href="../chapter4/task1.html"><strong aria-hidden="true">4.6.</strong> Task 1</a></li><li class="chapter-item expanded "><a href="../chapter4/slides4.html"><strong aria-hidden="true">4.7.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter5/chapter5.html"><strong aria-hidden="true">5.</strong> Generic Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter5/classes.html" class="active"><strong aria-hidden="true">5.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="../chapter5/templates.html"><strong aria-hidden="true">5.2.</strong> Templates</a></li><li class="chapter-item expanded "><a href="../chapter5/generics.html"><strong aria-hidden="true">5.3.</strong> Generics</a></li><li class="chapter-item expanded "><a href="../chapter5/concepts.html"><strong aria-hidden="true">5.4.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="../chapter5/task2.html"><strong aria-hidden="true">5.5.</strong> Task 2</a></li><li class="chapter-item expanded "><a href="../chapter5/slides5.html"><strong aria-hidden="true">5.6.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter6/chapter6.html"><strong aria-hidden="true">6.</strong> Algorithms &amp; Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter6/iterators.html"><strong aria-hidden="true">6.1.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="../chapter6/data-structures.html"><strong aria-hidden="true">6.2.</strong> Data Structures</a></li><li class="chapter-item expanded "><a href="../chapter6/algorithms.html"><strong aria-hidden="true">6.3.</strong> Algorithms</a></li><li class="chapter-item expanded "><a href="../chapter6/ranges.html"><strong aria-hidden="true">6.4.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="../chapter6/views.html"><strong aria-hidden="true">6.5.</strong> Views</a></li><li class="chapter-item expanded "><a href="../chapter6/task3.html"><strong aria-hidden="true">6.6.</strong> Task 3</a></li><li class="chapter-item expanded "><a href="../chapter6/slides6.html"><strong aria-hidden="true">6.7.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter7/chapter7.html"><strong aria-hidden="true">7.</strong> Concurrent Computing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter7/parallel-alg.html"><strong aria-hidden="true">7.1.</strong> Parallel Algorithms</a></li><li class="chapter-item expanded "><a href="../chapter7/atomics.html"><strong aria-hidden="true">7.2.</strong> Atomics</a></li><li class="chapter-item expanded "><a href="../chapter7/threads.html"><strong aria-hidden="true">7.3.</strong> Threads</a></li><li class="chapter-item expanded "><a href="../chapter7/mutexes.html"><strong aria-hidden="true">7.4.</strong> Mutexes</a></li><li class="chapter-item expanded "><a href="../chapter7/async.html"><strong aria-hidden="true">7.5.</strong> Asynchronous Programming</a></li><li class="chapter-item expanded "><a href="../chapter7/slides7.html"><strong aria-hidden="true">7.6.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../GODBOLT.html">Godbolt Examples</a></li><li class="chapter-item expanded affix "><a href="../planned.html">Planned Additions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">High Performance Programming</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/MonashDeepNeuron/HPP" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="classes"><a class="header" href="#classes">Classes</a></h1>
<h2 id="what-is-a-class"><a class="header" href="#what-is-a-class">What Is a Class?</a></h2>
<p>What is a class? Classes are the same as types. They allow for defining a set of valid operations on a particular configuration or amalgamation of data. In C++ there are two category of types, primitives and classes. Primitives are the basic types your were first introduced to in Chapter 2. Many other programming languages do not primitives because the language undergoes many more transformations before becoming machine code. As an example, <code>int</code> in Python is an object. It meets all the basic requirements of an object same as any other object in Python. This is not the case in C++. <code>int</code> in C++ is directly lowered (translated) into a assembly or machine type. You can a can access the bits that represent the <code>int</code>, even mutate them. They have a fixed width in memory (although varying from platform-to-platform) and cannot have their interfaces changes or adapted. Classes are different, they are much like object from Python (although, due to C++'s zero overhead principle, you only pay for what you ask for). Class are custom types that anyone can define and even modify through hierarchy structures and inheritance.</p>
<h2 id="defining-a-class"><a class="header" href="#defining-a-class">Defining a Class</a></h2>
<p>A class is defined identically to a structure. In fact, to C++ they are identical. You can use either keyword to create a class type. Typically however, <code>struct</code> is reserved for simple structures while <code>class</code> are use for more complex types by convention. There is one distinction between the two declarations, <code>class</code> will make all class members (methods and variables) private by default while <code>struct</code> will make them public by default.</p>
<blockquote>
<p>Note: From now on I'll refer to structures and classes as classes or types.</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;iostream&gt;

class Point
{
    int x;
    int y;
};

auto main() -&gt; int
{
    auto p = Point{ 2, 5 };

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;  ///&lt; Fails as `x` and `y` are private

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/MrorPKKxW">Example</a></p>
<h3 id="member-access"><a class="header" href="#member-access">Member Access</a></h3>
<p>Classes allow for you to specify the access rights of its members. There are three member access categories. Each allows for a different level of access permissions from both direct users of the class and the children (derived) of the class.</p>
<blockquote>
<p>Note: The term 'Member' means any method (function) or variable owned by a class, structure or type.</p>
</blockquote>
<h4 id="general-access"><a class="header" href="#general-access">General Access</a></h4>
<p>When defining a class, you can specify chapters of its definition to be either <code>private</code>, <code>protected</code> or <code>public</code>. This is done by putting an accessor label (with the keyword being one of the previously mentioned accessor categories with a <code>:</code> suffix) in a region of the classes body. All declared members following the label will adopt the accessor policy. You can reuse access specifiers as much as you want.</p>
<p>Here are the rules for the different accessor policies.</p>
<table><thead><tr><th align="center">Accessor Category</th><th align="center">Meaning</th></tr></thead><tbody>
<tr><td align="center"><code>private</code></td><td align="center">Member can only be used by member functions of the same class or friends (functions or classes).</td></tr>
<tr><td align="center"><code>protected</code></td><td align="center">Member can only be used by member functions of the same class, friends (functions or classes) or derived classes.</td></tr>
<tr><td align="center"><code>public</code></td><td align="center">Can be accessed by anyone.</td></tr>
</tbody></table>
<pre><code class="language-cxx">#include &lt;iostream&gt;

class Point
{
public:             ///&lt; Declare members `x` and `y` as public
    int x;
    int y;
};

auto main() -&gt; int
{
    Point p{ 2, 5 };  ///&lt; Now succeeds

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;  ///&lt; Now succeeds

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/1hWjrhee7">Example</a></p>
<h4 id="access-in-derived-classes"><a class="header" href="#access-in-derived-classes">Access in Derived Classes</a></h4>
<p>When deriving from another classes (more on inheritance <a href="#task-16--dynamic-inheritance">here</a>), you can specify the access rights of the parent classes members through the base class.</p>
<table><thead><tr><th align="center">Base Classes Access Policy</th><th align="center"><code>private</code></th><th align="center"><code>protected</code></th><th><code>public</code></th></tr></thead><tbody>
<tr><td align="center"></td><td align="center">Always inaccessible with any derivation access</td><td align="center"><code>private</code> in derived class if you use <code>private</code> derivation</td><td><code>private</code> in derived class if you use <code>private</code> derivation</td></tr>
<tr><td align="center"></td><td align="center"></td><td align="center"><code>protected</code> in derived class if you use <code>protected</code> derivation</td><td><code>protected</code> in derived class if you use <code>protected</code> derivation</td></tr>
<tr><td align="center"></td><td align="center"></td><td align="center"><code>protected</code> in derived class if you use <code>public</code> derivation</td><td><code>public</code> in derived class if you use <code>public</code> derivation</td></tr>
</tbody></table>
<pre><code class="language-cxx">#include &lt;iostream&gt;

class Point
{
public:
    int x;
    int y;
};

class Point3D
    : protected Point       ///&lt; Points members are `protected`
{
public:
    int z;
};

auto main() -&gt; int
{
    Point p{ 2, 5 };
    Point3D p3d{};

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;p3d.z = &quot; &lt;&lt; p3d.z &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p3d.x &lt;&lt; &quot;, &quot; &lt;&lt; p3d.y &lt;&lt; &quot;, &quot; &lt;&lt; p3d.z &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;  ///&lt; Fails, `x` and `y` are inaccessible

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/Wr8av57cz">Example</a></p>
<blockquote>
<p>Note: Classes can access their own members regardless of the access policy even if it is a different instance.</p>
</blockquote>
<h2 id="constructors-and-destructors"><a class="header" href="#constructors-and-destructors">Constructors and Destructors</a></h2>
<p>So far we haven't seen much difference from classes than just using them as aggregate structures. One of the unique benefits of classes in C++ is the ability to explicitly define and control how structures are created and destroyed. This gives you powerful control over the lifetime of a type and how its resources are managed at the definition stage removing the need for manual management at runtime. This is done through constructors and destructors. These are special members (functions) with the same name as the class. A class can have any number of constructors (following the normal function overloading rules) but can only have one destructor.</p>
<blockquote>
<p>Note: Creation or construction of a type refers to the explicit instantiation of an object with a particular class type.</p>
</blockquote>
<h3 id="explicit-constructors"><a class="header" href="#explicit-constructors">Explicit Constructors</a></h3>
<p>The most useful kind of constructors for defining custom creation of a class are explicit constructors. These constructors take explicitly specified arguments, usually used to initialise member variables with a particular value. Explicit constructors are often marked with the <code>explicit</code> keyword in their function signature. Means the constructor must be explicitly called, ie. passed the correct types.</p>
<p>Throughout this chapter we are going to build up the <code>Point</code> class. Lets start by making it possible to define the point from two <code>int</code>. I've defined the explicit constructor for initialising the members <code>Point::x</code> and <code>Point::y</code> as well as temporary getters/setters.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

class Point
{
public:

    /// Explicit Constructor for initialising `x` and `y`
    explicit constexpr
    Point(int x, int y) noexcept
    : x{ x }, y{ y }
    { }

    constexpr auto
    X() noexcept -&gt; int&amp;
    { return x; }

    constexpr auto
    Y() noexcept -&gt; int&amp;
    { return y; }

private:
    int x;
    int y;

};  /// class Point

auto main() -&gt; int
{
    Point p{ 2, 5 };

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p.X() &lt;&lt; &quot;, &quot; &lt;&lt; p.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;


    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/748dx3vG1">Example</a></p>
<blockquote>
<p>Note: Even though it is taught often in; OOP centric or even OOP enabled languages, to define 'getters' and 'setters' for member variables. This is bad practice as it often leads to users of types and classes manually mutating the data themselves instead of defining access patterns and stateful transitions through methods or algorithms. If you must use 'getter' or 'setter' access patterns then you member variables should be publicly accessible.</p>
</blockquote>
<h4 id="member-initialisers-lists"><a class="header" href="#member-initialisers-lists">Member Initialisers Lists</a></h4>
<p>You may notice the comma separated 'list' under the constructors declaration. This is called an member initialiser list. It is used to initialise the members of a class from the arguments of the called constructor or from other members of the class. Member initialiser lists are specified between a constructors declaration and its body. Members are initialised in the following order regardless of the order specified by the member initialiser list.</p>
<ol>
<li>If the constructor is for the most-derived class, virtual bases are initialized in the order in which they appear in depth-first left-to-right traversal of the base class declarations (left-to-right refers to the appearance in base-specifier lists)</li>
<li>Then, direct bases are initialized in left-to-right order as they appear in this class's base-specifier list</li>
<li>Then, non-static data member are initialized in order of declaration in the class definition.</li>
<li>Finally, the body of the constructor is executed</li>
</ol>
<p><a href="https://en.cppreference.com/w/cpp/language/constructor">Constructors and member initializer lists</a></p>
<h3 id="default-constructor"><a class="header" href="#default-constructor">Default Constructor</a></h3>
<p>Sometimes, you don't know the state a type should by in when it is being initialised. In these cases it is useful to have a fallback state. To achieve this we use a default constructor. This will usually take no parameters.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

class Point
{
public:

    /// Default Constructor
    constexpr
    Point() noexcept
        : x{ 0 }, y{ 0 }
    { }

    /// Explicit Constructor for initialising `x` and `y`
    explicit constexpr
    Point(int x, int y) noexcept
        : x{ x }, y{ y }
    { }

    constexpr auto
    X() noexcept -&gt; int&amp;
    { return x; }

    constexpr auto
    Y() noexcept -&gt; int&amp;
    { return y; }

private:
    int x;
    int y;

};  /// class Point

auto main() -&gt; int
{
    Point p1{ 2, 5 };
    Point p2{};

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p1.X() &lt;&lt; &quot;, &quot; &lt;&lt; p1.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p2.X() &lt;&lt; &quot;, &quot; &lt;&lt; p2.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;


    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/Wrne3b1nd">Example</a></p>
<h3 id="copy-constructors"><a class="header" href="#copy-constructors">Copy Constructors</a></h3>
<p>Constructors allow for defining custom semantics for common meta-like operations. For example, if you define a constructor that takes a constant reference to another <code>Point</code>, the only thing to can do is copy the data from the other class. This constructor pattern is called Copy Semantics. We can also overload the <code>=</code> operator so we can perform copy assignments.
Let's define a copy constructor for <code>Point</code>.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

class Point
{
public:

    /// Default Constructor
    constexpr
    Point() noexcept
        : x{ 0 }, y{ 0 }
    { }

    /// Explicit Constructor for initialising `x` and `y`
    explicit constexpr
    Point(int x, int y) noexcept
        : x{ x }, y{ y }
    { }

    /// Copy Constructor
    constexpr Point(const Point&amp; p) noexcept
        : x{ p.x }, y{ p.y }
    { }

    constexpr auto
    X() noexcept -&gt; int&amp;
    { return x; }

    constexpr auto
    Y() noexcept -&gt; int&amp;
    { return y; }

private:
    int x;
    int y;

};  /// class Point

auto main() -&gt; int
{
    Point p1{ 2, 5 };
    Point p2{ p1 };   ///&lt; Copy Constructor Called

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p1.X() &lt;&lt; &quot;, &quot; &lt;&lt; p1.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p2.X() &lt;&lt; &quot;, &quot; &lt;&lt; p2.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;
    
    p2.X() = 8;
    p2.Y() = 9;

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p1.X() &lt;&lt; &quot;, &quot; &lt;&lt; p1.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p2.X() &lt;&lt; &quot;, &quot; &lt;&lt; p2.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/YYhf9baW3">Example</a></p>
<h3 id="move-constructors"><a class="header" href="#move-constructors">Move Constructors</a></h3>
<p>While our <code>Point</code> class has gotten pretty sophisticated there is one file base constructor we need in order to complete its baseline functionality. In C++, all data has an owner. We can get pointers and references to data so that other can borrow the data. We can even copy data so that a new owner can have the same values as another however, there is one missing piece. The transfer of ownership, what if we want to give ownership of some data to a new owner. We see this principle with rvalue references. When we initialise an <code>int</code> with a literal; say <code>1</code>, we are transferring ownership of the data associated with the literal <code>1</code> to the named variable. In C++ this is called a move. Moves occur when a constructor (or assignment) of a type is called on a rvalue reference which invokes the class's move constructor. Moves will rip the data of a type out of it and transfer the ownership of the data and resource to the new object, leaving the old owner in a default initialised state (usually). Moves can be induced using the <code>std::move()</code> function from the <code>&lt;utility&gt;</code> header.</p>
<blockquote>
<p>Note: Moves of literal types will often invoke a copy over a move because they are primitive types and this cheap to copy. Moves are mostly relevant to more complex types.</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;utility&gt;

class Point
{
public:

    /// Default Constructor
    constexpr
    Point() noexcept
        : x{ 0 }, y{ 0 }
    { }

    /// Explicit Constructor for initialising `x` and `y`
    explicit constexpr
    Point(int x, int y) noexcept
        : x{ x }, y{ y }
    { }

    /// Copy Constructor
    constexpr Point(const Point&amp; p) noexcept
        : x{ p.x }, y{ p.y }
    { }

    /// Move Constructor
    constexpr Point(Point&amp;&amp; p) noexcept
        : x{ std::move(p.x) }, y{ std::move(p.y) }
    { 
        p.x = int();
        p.y = int();
    }

    constexpr auto
    X() noexcept -&gt; int&amp;
    { return x; }

    constexpr auto
    Y() noexcept -&gt; int&amp;
    { return y; }

private:
    int x;
    int y;

};  /// class Point

auto main() -&gt; int
{
    Point p1{ 2, 5 };

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p1.X() &lt;&lt; &quot;, &quot; &lt;&lt; p1.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;
    
    Point p2{ std::move(p1) };   ///&lt; Move Constructor Called

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p1.X() &lt;&lt; &quot;, &quot; &lt;&lt; p1.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p2.X() &lt;&lt; &quot;, &quot; &lt;&lt; p2.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/TfGEWW7qM">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/utility/move"><code>std::move()</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/header/utility"><code>&lt;utility&gt;</code></a></li>
</ul>
<h3 id="destructors"><a class="header" href="#destructors">Destructors</a></h3>
<p>So far we have built a pretty sophisticated type of our own with many ways to construct it however, what happens when it gets destroyed. This will invoke the classes destructor. The destructor is declared the same as the default constructor however, it is prefixed with a tilde ('~') in the constructors name. Destructors are used to properly free resources from the type. Resources include things such as dynamic memory, device handles, web sockets etc. For our <code>Point</code> class our destructor is really a no-op as all of its members are trivial to destruct and will automatically occur. A trivial constructor will look like this.</p>
<pre><code class="language-cxx">/// ... Rest of `Point` class's constructors

constexpr ~Point() noexcept {}

/// ... Members variables
</code></pre>
<h3 id="raii"><a class="header" href="#raii">RAII</a></h3>
<p>So why have all these means of specifying creation and deletion of objects? One of the core faults of many programs in C is the requirement to explicitly create and destroy resources, even of structures. One of the first things introduced to C++ where constructors and destructors so that the creation of object of a type and its subsequent destruction were tied to the type itself anf could be implicitly handled by the compiler. It also allowed for classes to acquire all resources they needed at the time of construction. This principle is known as 'Resource Acquisition Is Initialisation' or RAII. This means that the lifetime of any resource owned by a class is tied to the lifetime of an instance of that class.</p>
<p>How this works is that a constructor acquires all the required resources at construction meaning that after construction the object must be initialised. Similarly, the destructor releases resources in reverse-acquisition-order to prevent resource leaks.
This also means that if a constructor should fail (by throwing an exception), any already acquired resources are released in reverse acquisition order and destructors must never throw.</p>
<p>Classes with member functions named <code>open()</code>/<code>close()</code>, <code>lock()</code>/<code>unlock()</code>, or <code>init()</code>/<code>copyFrom()</code>/<code>destroy()</code>
(or similar, carrying the same semantics meaning) are typical examples of non-RAII classes.</p>
<h3 id="letting-the-compiler-do-the-work-for-you"><a class="header" href="#letting-the-compiler-do-the-work-for-you">Letting the compiler do the work for you</a></h3>
<p>Because our <code>Point</code> class is superficial and almost trivial, it can be annoying to define all the constructors and when the resources being initialised are trivial. It would be nice to not have to specify every constructor. What if we could make the compiler generate the constructors for us? Well, we can. By just declaring the constructors signature with no member initialiser list or body, we can use the <code>= default</code> suffix specifier indicating for the compiler to generate the constructor for us. We will do this for the default constructor.</p>
<pre><code class="language-cxx">/// ... Point details 

constexpr Point() noexcept = default;

/// ... Point details
</code></pre>
<blockquote>
<p>Note: It should be noted that you should only do this if the operation of performed by a particular constructor is trivial and predictable and doesn't require specific set of operations to occur.</p>
</blockquote>
<p>You can also disallow the use of a particular constructor entirely by deleting it.</p>
<pre><code class="language-cxx">/// ... Point details

constexpr Point(const Point&amp; p) noexcept = delete;  ///&lt; Point objects cannot be copied.

/// ... Point details
</code></pre>
<h2 id="members--methods"><a class="header" href="#members--methods">Members &amp; Methods</a></h2>
<p>While constructors and destructors ensure resource and lifetime safety for classes they are only half the story. Member functions or methods allow us to define operations that we want to on or using the data help by a class. They allow for stateful modification of data while ensuring type safety. To define a methods for a class you simply define a function within the classes body. Normal rules for naming and overloading apply however methods are able to access all members (function and variable) of the immediate class and any <code>protected</code> and <code>public</code> members of parent classes. In our <code>Point</code> class we already have to members; <code>Point::X()</code> and <code>Point::Y()</code> which return <code>int&amp;</code> of the members <code>Point::x</code> and <code>Point::y</code> respectively.</p>
<pre><code class="language-cxx">/// ... Point details

constexpr auto
X() noexcept -&gt; int&amp;
{ return x; }

constexpr auto
Y() noexcept -&gt; int&amp;
{ return y; }

/// ... Point details
</code></pre>
<h3 id="const-and-reference-qualifiers"><a class="header" href="#const-and-reference-qualifiers">Const and Reference Qualifiers</a></h3>
<p>Members can restrict and customize their usage on particular instances of its class through the class objects value category and cv-qualifiers. By postfixing the symbols <code>const</code>, <code>&amp;</code> and <code>&amp;&amp;</code> to a member function we can restrict the usage of that member function to instances of the class object to being a constant object and/or having either value category of lvalue or rvalue respectively.</p>
<blockquote>
<p>Note: A combination of cv- and ref- qualifiers can be used ie <code>const&amp;</code> or <code>const&amp;&amp;</code> but not both</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;utility&gt;

auto print(auto n) -&gt; void
{ std::cout &lt;&lt; n &lt;&lt; std::endl; }

class A
{
public:

    auto f() &amp; -&gt; int&amp;
    { 
        print(&quot;lvalue&quot;);
        return n; 
    }

    auto f() const&amp; -&gt; int
    { 
        print(&quot;const lvalue&quot;);
        return n; 
    }

    auto f() &amp;&amp; -&gt; int
    { 
        print(&quot;rvalue&quot;);
        return std::move(n); 
    }

    auto f() const&amp;&amp; -&gt; int
    { 
        print(&quot;const rvalue&quot;);
        return std::move(n); 
    }

private:
    
    int n = 0;
};

auto main() -&gt; int
{
    A a;
    const A ca;

    a.f();
    std::move(a).f();
    A().f();

    ca.f();
    std::move(ca).f();

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/TGoh9Yrjc">Example</a></p>
<h3 id="this"><a class="header" href="#this">This</a></h3>
<p>It is useful for a class to be self aware and have some means of referring to itself, for example when working with another instance of the same class in a method it can be ambiguous when you are using members from your instance and from the other objects instance. Classes in C++ implicitly have a member called <code>this</code>. <code>this</code> is a pointer to the current instance of a class in memory. Using <code>this</code> allows for qualified lookup of names for the current object. Like any other pointer it can be dereferenced so that it can be used as a reference or have its members accessed using <code>this-&gt;</code>. <code>this</code> can only be used in methods and has the type of the class type the method was called with including cv-qualifications.</p>
<pre><code class="language-cxx">/// ... Point details

constexpr auto
X() noexcept -&gt; int&amp;
{ return this-&gt;x; }

constexpr auto
Y() noexcept -&gt; int&amp;
{ return this-&gt;y; }

/// ... Point details
</code></pre>
<p><a href="https://en.cppreference.com/w/cpp/language/this">The <code>this</code> pointer</a></p>
<h3 id="operator-overloading"><a class="header" href="#operator-overloading">Operator Overloading</a></h3>
<p>Much like how you can overload operators as free functions, classes can define there own overloads for operators. operator overloads for classes are defined just like regular methods for classes however, the first argument is implicitly <code>this</code> object.</p>
<pre><code class="language-cxx">/// ... Point details

constexpr auto
operator+ (const Point&amp; p) noexcept -&gt; Point
{ return Point{ x + p.x, y + p.y }; }

constexpr auto
operator- (const Point&amp; p) noexcept -&gt; Point
{ return Point{ x - p.x, y - p.y }; }

constexpr auto
operator== (const Point&amp; p)
    noexcept -&gt; bool
{ return (x == p.x) &amp;&amp; (y == p.y); }

constexpr auto
operator!= (const Point&amp; p)
noexcept -&gt; bool
{ return !(*this == p); }

/// ... Point details
</code></pre>
<p><a href="https://www.godbolt.org/z/TG9WW74bo">Example</a></p>
<h3 id="assignment-overloads"><a class="header" href="#assignment-overloads">Assignment Overloads</a></h3>
<p>One of the most useful operator overloads we can define for a class is an overload for <code>=</code>; two in fact, one for each of copy semantics and move semantics. This methods work identical to their constructor counterparts except they must have an explicit return type and value, cannot have a member initializer list and must only be defined for a single argument.</p>
<pre><code class="language-cxx">/// ... Point details

constexpr auto
operator= (const Point&amp; p) noexcept -&gt; Point&amp;
{
    if (p != *this)
    {
        x = p.x;
        y = p.y;
    }

    return *this;
}

constexpr auto
operator= (Point&amp;&amp; p) noexcept -&gt; Point&amp;
{
    if (p != *this)
    {
        x = std::move(p.x);
        y = std::move(p.y);
    }

    return *this;
}

/// ... Point details
</code></pre>
<blockquote>
<p>Note: The <code>if (p != *this)</code> check ensures self assignment does not occur.</p>
</blockquote>
<p><a href="https://www.godbolt.org/z/xvcf57xcT">Example</a></p>
<h3 id="friend-methods"><a class="header" href="#friend-methods">Friend Methods</a></h3>
<p>Sometimes it is useful to access the internal <code>private</code> and <code>protected</code> data of a class without having to make it exposed to everyone. This is were friends come in handy. The <code>friend</code> keyword can be attached to nested class forward specifications and functions. This makes free functions able to access and modify the internal data of a class. Friendship is most useful for creating relationships between hierarchal unrelated classes interoperate with each other such as in certain operator overloads.</p>
<blockquote>
<h4 id="notes"><a class="header" href="#notes">Notes:</a></h4>
<ul>
<li>Friendship is not transitive - A friend of your friend is not your friend</li>
<li>Friendship is not inherited - Your friends children are not your friends</li>
</ul>
</blockquote>
<p>Here I've defined an overload for <code>&lt;&lt;</code> as a <code>friend</code> function. This is because <code>std::ostream</code> is an unrelated type to <code>Point</code> but we want to be able to access the non-public members of a <code>Point</code> object. With this, we can delete the <code>Point::X()</code> and <code>Point::Y()</code> methods.</p>
<pre><code class="language-cxx">/// ... Point details

friend auto
operator&lt;&lt; (std::ostream&amp; os, const Point&amp; p)
    noexcept -&gt; std::ostream&amp;
{ 
    os &lt;&lt; &quot;( &quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot; )&quot;;
    return os;
}

/// ... Point details
</code></pre>
<p><a href="https://www.godbolt.org/z/MxacvscTY">Example</a></p>
<p><a href="/content/chapter5/examples/point-v1.hxx">Version 1 of <code>Point</code></a></p>
<h2 id="dynamic-inheritance"><a class="header" href="#dynamic-inheritance">Dynamic Inheritance</a></h2>
<p>You are able to inherit the members of another class into your own class. This allows for many OOP concepts to be applied such as inheritance and polymorphism. Base classes are specified after the derived classes name specification. All classes can be inherited from (unless declared as <code>final</code>).</p>
<blockquote>
<p>Note: OOP principles are not the focus of this series and is only covered lightly. C++ is by no means a Object Oriented language (despite similar naming). Rather C++ supports OOP principles in order to benefit from these principles however, many chapters of the language (Standard Library) will utilise these features and principles in a far more general sense.</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;iostream&gt;

struct A
{
    int n;
};

struct B : public A
{
    float f;
};

auto main() -&gt; int
{
    A a();
    std::cout &lt;&lt; a.n &lt;&lt; std::endl;
    a.n = 7;
    std::cout &lt;&lt; a.n &lt;&lt; std::endl;

    B b();
    std::cout &lt;&lt; b.n &lt;&lt; std::endl;
    std::cout &lt;&lt; b.f &lt;&lt; std::endl;
    b.n = 4;
    std::cout &lt;&lt; b.n &lt;&lt; std::endl;
    std::cout &lt;&lt; a.n &lt;&lt; std::endl;

    b.f = 8.53464f;
    std::cout &lt;&lt; b.f &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/xvMdeq3n5">Example</a></p>
<h3 id="virtual-methods"><a class="header" href="#virtual-methods">Virtual Methods</a></h3>
<p>A method can be marked as virtual with the <code>virtual</code> specifier. This means that classes that derive this method can override them by specifying them as overridden with the <code>override</code> keyword in the derived class.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

struct A
{
    virtual void foo();
};

void A::foo() { std::cout &lt;&lt; &quot;A::foo()&quot; &lt;&lt; std::endl; }

struct B : public A
{
    void foo() override;
};

void B::foo() { std::cout &lt;&lt; &quot;B::foo()&quot; &lt;&lt; std::endl; }

auto main() -&gt; int
{
    A a;
    a.foo();

    B b;
    b.foo();

    return 0;
}
</code></pre>
<ul>
<li>
<blockquote>
<p>Note: <code>virtual</code> and <code>override</code> methods cannot have deduced return types</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Note: The definition of virtual functions must be defined separate from the declaration.</p>
</blockquote>
</li>
</ul>
<p><a href="https://www.godbolt.org/z/zrMs4EhKn">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/virtual"><code>virtual</code> function specifier</a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/override"><code>override</code> specifier</a></li>
</ul>
<h3 id="virtual-inheritance"><a class="header" href="#virtual-inheritance">Virtual Inheritance</a></h3>
<p>Classes can also inherit base classes virtually. For each base class that is specified as virtual, the most derived object will contain only one sub-object of that <code>virtual</code> base class, even if the class appears many times in the inheritance hierarchy (as long as it is inherited <code>virtual</code> every time)*.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

struct B 
{ int n; };

class X : public virtual B {};
class Y : virtual public B {};
class Z : public B {};
 
// every object of type AA has one X, one Y, one Z, and two B's:
// one that is the base of Z and one that is shared by X and Y
struct AA : X, Y, Z
{
    AA()
    {
        X::n = 1; // modifies the virtual B sub-object's member
        Y::n = 2; // modifies the same virtual B sub-object's member
        Z::n = 3; // modifies the non-virtual B sub-object's member
 
        std::cout &lt;&lt; X::n &lt;&lt; Y::n &lt;&lt; Z::n &lt;&lt; '\n';
    }
};

auto main() -&gt; int
{
    AA aa;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/qT5v7aEPx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/derived_class">Derived Classes</a></p>
<blockquote>
<p>*Note: This is an adaptation (paraphrase) from <a href="https://en.cppreference.com/w/cpp/language/derived_class#:%7E:text=initializer%20list.-,Virtual%20base%20classes,-For%20each%20distinct">cppreference</a></p>
</blockquote>
<h3 id="abstract-classes"><a class="header" href="#abstract-classes">Abstract Classes</a></h3>
<p>Abstract classes are classes which define or inherit at least one 'pure' <code>virtual</code> methods. Pure <code>virtual</code> methods are <code>virtual</code> methods whose declaration are suffixed by the <code>= 0;</code> pure-specifier expression. Abstract classes cannot be instantiated but can be pointer to or referred to.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

struct Base
{
    virtual void g() = 0;
    virtual ~Base() {}
};

void Base::g() { std::cout &lt;&lt; &quot;Base::g()&quot; &lt;&lt; std::endl; }
 
struct A : Base
{
    virtual void g() override;
};

void A::g() 
{ 
    Base::g();
    std::cout &lt;&lt; &quot;A::g()&quot; &lt;&lt; std::endl; 
}

auto main() -&gt; int
{
    // Base b;  ///&lt; Fails `cannot declare variable 'b' to be of abstract type 'Base'`

    A a;
    a.g();

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/axj9Tbr4v">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/abstract_class">Abstract class</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter5/chapter5.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../chapter5/templates.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter5/chapter5.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../chapter5/templates.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
