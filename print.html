<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>High Performance Programming</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Monash DeepNeuron&#x27;s High Performance Programming Curriculum">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="home.html">Home</a></li><li class="chapter-item expanded affix "><div>Foreword</div></li><li class="chapter-item expanded "><a href="chapter1/chapter1.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter1/wsl.html"><strong aria-hidden="true">1.1.</strong> WSL</a></li><li class="chapter-item expanded "><a href="chapter1/software.html"><strong aria-hidden="true">1.2.</strong> Installing Software</a></li><li class="chapter-item expanded "><a href="chapter1/helloworld.html"><strong aria-hidden="true">1.3.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="chapter1/godbolt.html"><strong aria-hidden="true">1.4.</strong> Compiler Explorer</a></li><li class="chapter-item expanded "><a href="chapter1/slides1.html"><strong aria-hidden="true">1.5.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="chapter2/chapter2.html"><strong aria-hidden="true">2.</strong> Basics of C++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter2/typesystem.html"><strong aria-hidden="true">2.1.</strong> The C++ Type System</a></li><li class="chapter-item expanded "><a href="chapter2/types.html"><strong aria-hidden="true">2.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="chapter2/variables.html"><strong aria-hidden="true">2.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="chapter2/operators.html"><strong aria-hidden="true">2.4.</strong> Operators</a></li><li class="chapter-item expanded "><a href="chapter2/io.html"><strong aria-hidden="true">2.5.</strong> IO</a></li><li class="chapter-item expanded "><a href="chapter2/eqordlogic.html"><strong aria-hidden="true">2.6.</strong> Equality, Ordering &amp; Logical Operators</a></li><li class="chapter-item expanded "><a href="chapter2/condexpr.html"><strong aria-hidden="true">2.7.</strong> Conditional Expressions</a></li><li class="chapter-item expanded "><a href="chapter2/loops.html"><strong aria-hidden="true">2.8.</strong> Loops</a></li><li class="chapter-item expanded "><a href="chapter2/functions.html"><strong aria-hidden="true">2.9.</strong> Functions</a></li><li class="chapter-item expanded "><a href="chapter2/slides2.html"><strong aria-hidden="true">2.10.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="chapter3/chapter3.html"><strong aria-hidden="true">3.</strong> Memory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter3/pointers.html"><strong aria-hidden="true">3.1.</strong> Pointers</a></li><li class="chapter-item expanded "><a href="chapter3/slices.html"><strong aria-hidden="true">3.2.</strong> Slices</a></li><li class="chapter-item expanded "><a href="chapter3/references.html"><strong aria-hidden="true">3.3.</strong> References</a></li><li class="chapter-item expanded "><a href="chapter3/memory.html"><strong aria-hidden="true">3.4.</strong> Dynamic Memory</a></li><li class="chapter-item expanded "><a href="chapter3/stdlib.html"><strong aria-hidden="true">3.5.</strong> The Standard Library</a></li><li class="chapter-item expanded "><a href="chapter3/slides3.html"><strong aria-hidden="true">3.6.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="chapter4/chapter4.html"><strong aria-hidden="true">4.</strong> Intermediate C++ Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter4/advfunc.html"><strong aria-hidden="true">4.1.</strong> Advanced Function Concepts</a></li><li class="chapter-item expanded "><a href="chapter4/namespaces.html"><strong aria-hidden="true">4.2.</strong> Namespaces</a></li><li class="chapter-item expanded "><a href="chapter4/enums.html"><strong aria-hidden="true">4.3.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="chapter4/unions.html"><strong aria-hidden="true">4.4.</strong> Unions</a></li><li class="chapter-item expanded "><a href="chapter4/structs.html"><strong aria-hidden="true">4.5.</strong> Structures</a></li><li class="chapter-item expanded "><a href="chapter4/task1.html"><strong aria-hidden="true">4.6.</strong> Task 1</a></li><li class="chapter-item expanded "><a href="chapter4/slides4.html"><strong aria-hidden="true">4.7.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="chapter5/chapter5.html"><strong aria-hidden="true">5.</strong> Generic Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter5/classes.html"><strong aria-hidden="true">5.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="chapter5/templates.html"><strong aria-hidden="true">5.2.</strong> Templates</a></li><li class="chapter-item expanded "><a href="chapter5/generics.html"><strong aria-hidden="true">5.3.</strong> Generics</a></li><li class="chapter-item expanded "><a href="chapter5/concepts.html"><strong aria-hidden="true">5.4.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="chapter5/task2.html"><strong aria-hidden="true">5.5.</strong> Task 2</a></li><li class="chapter-item expanded "><a href="chapter5/slides5.html"><strong aria-hidden="true">5.6.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="chapter6/chapter6.html"><strong aria-hidden="true">6.</strong> Algorithms &amp; Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter6/iterators.html"><strong aria-hidden="true">6.1.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="chapter6/data-structures.html"><strong aria-hidden="true">6.2.</strong> Data Structures</a></li><li class="chapter-item expanded "><a href="chapter6/algorithms.html"><strong aria-hidden="true">6.3.</strong> Algorithms</a></li><li class="chapter-item expanded "><a href="chapter6/ranges.html"><strong aria-hidden="true">6.4.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="chapter6/views.html"><strong aria-hidden="true">6.5.</strong> Views</a></li><li class="chapter-item expanded "><a href="chapter6/task3.html"><strong aria-hidden="true">6.6.</strong> Task 3</a></li><li class="chapter-item expanded "><a href="chapter6/slides6.html"><strong aria-hidden="true">6.7.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="chapter7/chapter7.html"><strong aria-hidden="true">7.</strong> Concurrent Computing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter7/parallel-alg.html"><strong aria-hidden="true">7.1.</strong> Parallel Algorithms</a></li><li class="chapter-item expanded "><a href="chapter7/atomics.html"><strong aria-hidden="true">7.2.</strong> Atomics</a></li><li class="chapter-item expanded "><a href="chapter7/threads.html"><strong aria-hidden="true">7.3.</strong> Threads</a></li><li class="chapter-item expanded "><a href="chapter7/mutexes.html"><strong aria-hidden="true">7.4.</strong> Mutexes</a></li><li class="chapter-item expanded "><a href="chapter7/async.html"><strong aria-hidden="true">7.5.</strong> Asynchronous Programming</a></li><li class="chapter-item expanded "><a href="chapter7/slides7.html"><strong aria-hidden="true">7.6.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="GODBOLT.html">Godbolt Examples</a></li><li class="chapter-item expanded affix "><a href="planned.html">Planned Additions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">High Performance Programming</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/MonashDeepNeuron/HPP" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="high-performance-programming"><a class="header" href="#high-performance-programming">High Performance Programming</a></h1>
<p><em>by Tyler Swann, in collaboration with Monash DeepNeuron</em></p>
<h2 id="welcome"><a class="header" href="#welcome">Welcome</a></h2>
<p>Welcome to Monash DeepNeuron's <em>High Performance Programming (C++ edition)</em>, a book aimed at teaching techniques for developing programs that are both fast and safe. Throughout this book you will be learning the C++ programming language along with techniques for; computer memory, algorithm intuition, parallel computing and more.</p>
<h2 id="how-to-use-this-book"><a class="header" href="#how-to-use-this-book">How to use this book</a></h2>
<p>This book is designed to be read cover-to-cover. Concepts in later chapters will build upon concepts from previous chapters. On either side of the page there are arrow buttons that will move you between pages and chapters. You can also search for specific content using the search button in the top left or by pressing the <kbd>S</kbd> key.</p>
<h2 id="synopsis"><a class="header" href="#synopsis">Synopsis</a></h2>
<ul>
<li><a href="./chapter1/chapter1.html">Chapter 1 - Getting Started</a> - Setup &amp; Introduction to C++</li>
<li><a href="./chapter2/chapter2.html">Chapter 2 - Basics of C++</a> - Types, Variables, Operators, IO, Conditionals, Loops and Functions</li>
<li><a href="./chapter3/chapter3.html">Chapter 3 - Memory</a> - Pointers, Slices, References, Dynamic Memory and The Standard Library</li>
<li><a href="./chapter4/chapter4.html">Chapter 4 - Intermediate C++</a> - Functional Programming, Namespaces, Enumerations, Unions, Structures</li>
<li><a href="./chapter5/chapter5.html">Chapter 5 - Generic Programming</a> - Classes, Templates, Generics and Concepts</li>
<li><a href="./chapter6/chapter6.html">Chapter 6 - Algorithms &amp; Data Structures</a> - Iterators, Data Structures, Algorithms, Ranges and Views</li>
<li><a href="./chapter7/chapter7.html">Chapter 7 - Parallel Programming</a> - Parallel Algorithms, Atomics, Threads, Mutexes &amp; Locks and Async</li>
</ul>
<h2 id="suggestions-fixes-and-contributions"><a class="header" href="#suggestions-fixes-and-contributions">Suggestions, Fixes and Contributions</a></h2>
<p>Refer to the <a href="https://github.com/MonashDeepNeuron/HPP">source code</a> of this book for details on how to contribute changes, fix typos or create new content for this book.</p>
<h2 id="external-resources"><a class="header" href="#external-resources">External Resources</a></h2>
<ul>
<li><a href="https://en.cppreference.com/w/Main_Page">cppreference</a></li>
<li><a href="https://www.godbolt.org/">Compiler Explorer</a></li>
<li><a href="https://bpt.pizza/docs/latest/index.html">bpt docs</a></li>
</ul>
<div style="font-size: 0.75em;">
  <center>
    <code>
      version: 1.0.0
    </code>
  </center>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Let's begin by setting up your device for developing with C++. In this chapter we will discuss:</p>
<ul>
<li>Installing WSL (Windows)</li>
<li>Installing Homebrew for system package management</li>
<li>Setting up Git and the basics of source version control</li>
<li>Installing a C++ compiler</li>
<li>Installing bpt, a C++ package and build tool</li>
<li>Installing VSCode, a text editor</li>
<li>Writing a C++ program that prints &quot;Hello World!&quot;</li>
<li>How to compile and execute programs</li>
<li>How to use Compiler Explorer to share code snippets.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wsl"><a class="header" href="#wsl">WSL</a></h1>
<p>In this section we will install WSL. This is a virtualized Linux Kernel for Windows. This makes managing developer tools far easier and separates your development OS (Linux) from your personal OS (Windows).</p>
<blockquote>
<p>Note: This section only applies to Windows users.</p>
</blockquote>
<h2 id="update-windows-and-virtualization-check"><a class="header" href="#update-windows-and-virtualization-check">Update Windows and Virtualization Check</a></h2>
<p>Before we begin, it is best to ensure we have the most recent Windows update available. Go to <strong>Settings &gt; Updates</strong> and install any updates to your system.</p>
<p>Secondly, you will want to ensure that virtualization is enabled on your device. To do this open 'Task Manager', click more details, open the performance tab and make sure you are on the CPU performance section. In the details below the CPU's graph there should be an option called 'virtualization'. This should have the value 'Enabled' next to it. If it doesn't, you will need to enable a feature called SVM in your computers BIOS. If you are comfortable doing this; go for it but if you do not want to do this yourself do not worry. We will ensure everyone is setup correctly in the first meetup. Continue reading through as there will be a way you can start coding at the end of the sections.</p>
<p><img src="chapter1/./imgs/taskmanager.png" alt="Task Manager Example" /></p>
<h2 id="windows-terminal"><a class="header" href="#windows-terminal">Windows Terminal</a></h2>
<p>To get started with WSL we will want a new terminal environment for the WSL shell. Fortunately, Microsoft has an awesome project called Windows Terminal (WT). It is able to hold many instances of different shells an dis fully customizable. To install it, simply open the <a href="https://www.microsoft.com/store/productId/9N0DX20HK701">Microsoft Store</a> apps and search for &quot;Windows Terminal&quot; and click &quot;install&quot;.</p>
<h2 id="wsl-install"><a class="header" href="#wsl-install">WSL Install</a></h2>
<p>To install WSL, we need to open PowerShell terminal with administrative privileges. Click on the Windows Start button (bottom left icon on the sectionbar) and type &quot;PowerShell&quot;, select &quot;Run as Administrator&quot;. This will open a new shell. Now run:</p>
<pre><code class="language-ps">&gt; wsl --install -d Ubuntu-20.04
</code></pre>
<p>This may require a reboot. This will install WSL as well as an image of Ubuntu. Click Start again and type &quot;Ubuntu&quot; and run the application. Follow the on screen instructions to create your user and password for WSL. This is different from you Windows credentials. Now open WT and press <code>ctrl + ,</code> again. On the settings page that pops up, the first drop down called &quot;Default Profile&quot; should now have an option called Ubuntu (or something similar). Choose this as your default profile.</p>
<p>WSL is now installed. Create a new shell tab with <code>ctrl + shift + t</code> and the shell prompt should now display you WSL username.</p>
<blockquote>
<h3 id="command-line-notation"><a class="header" href="#command-line-notation">Command Line Notation</a></h3>
<p>In this chapter and throughout the book, we’ll show some commands used in the
terminal. Lines that you should enter in a terminal all start with <code>$</code>. You
don’t need to type the <code>$</code> character; it’s the command line prompt shown to
indicate the start of each command. Lines that don’t start with <code>$</code> typically
show the output of the previous command. Additionally, PowerShell-specific
examples will use <code>&gt;</code> rather than <code>$</code>.</p>
</blockquote>
<h3 id="apt--packages"><a class="header" href="#apt--packages">APT &amp; Packages</a></h3>
<p>Before you begin, you will need to update your systems packages. Packages on Ubuntu are managed by a tool called <code>apt</code>. For some context, updating packages takes two steps typically, first you update the package index, then you can update the relevant packages.</p>
<pre><code class="language-sh"># `sudo` represents 'super user do'. 
# This runs a command with admin. privileges.
# Update apt's local package index.
$ sudo apt update

# The `-y` flag means upgrade yes to all.
# This bypasses confirming package upgrades.
# Upgrade packages with new versions
$ sudo apt upgrade -y
</code></pre>
<p>You will also want some packages <code>apt</code> that we will need for C++ development.</p>
<pre><code class="language-sh"># Installs specified packages (separated by spaces).
$ sudo apt install git curl wget ca-certificates build-essential
</code></pre>
<p>WSL should be installed and ready to go.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing-software"><a class="header" href="#installing-software">Installing Software</a></h1>
<p>In this section we will install all the relevant software for developing C++ programs.</p>
<h2 id="wsl--linux"><a class="header" href="#wsl--linux">WSL &amp; Linux</a></h2>
<p>To get started open a new terminal session (for WSL, use the WSL terminal) and update your system package managers local package index. This is a list of all available packages and their versions. We can then install some system critical packages that we need in order to develop C++ programs. From there we can install Homebrew, a cross platform package manager which we will use to install our C++ compiler(s) and debuggers.</p>
<pre><code class="language-sh"># Update apt (replace apt with relevant package manager if you are not on Ubuntu)
$ sudo apt update
$ sudo apt upgrade -y

# Install system packages
$ sudo apt install git curl wget ca-certificates build-essential

# Install Homebrew and update
$ /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;
$ brew update
$ brew upgrade

# Install C++ compiler(s), debuggers
$ brew install gcc llvm gdb
</code></pre>
<h2 id="macos"><a class="header" href="#macos">MacOS</a></h2>
<p>To begin, open a new terminal session install Homebrew, a cross platform package manager which will then use to install our C++ compiler(s), debuggers, cURL and Git.</p>
<pre><code class="language-sh">$ /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;
$ brew update
$ brew upgrade
$ brew install gcc llvm gdb curl git
</code></pre>
<h2 id="verify-installation"><a class="header" href="#verify-installation">Verify Installation</a></h2>
<p>You can verify that GCC installed the correct version by running the following command. The output should be similar to this.</p>
<pre><code class="language-sh">$ gcc-12 -v
Reading specs from /home/linuxbrew/.linuxbrew/Cellar/gcc/12.2.0/bin/../lib/gcc/current/gcc/x86_64-pc-linux-gnu/12/specs
COLLECT_GCC=gcc-12

# Other info ...

gcc version 12.2.0 (Homebrew GCC 12.2.0)
</code></pre>
<h2 id="authenticating-git-with-github"><a class="header" href="#authenticating-git-with-github">Authenticating Git with GitHub</a></h2>
<p>If you have a GitHub (or other) account and you want to link it to your machine, run the following commands, replacing <code>&lt;&gt;</code> with your personal details.</p>
<pre><code class="language-sh">$ git config --global user.name &quot;&lt;github-username&gt;&quot;
$ git config --global user.email &quot;&lt;github-email&gt;&quot;
</code></pre>
<h2 id="installing-bpt"><a class="header" href="#installing-bpt">Installing bpt</a></h2>
<p>bpt is a build and packaging tool for C++. It makes consuming C++ libraries, running tests and packaging your code much easier compared to conventional methods (notably Cmake).</p>
<pre><code class="language-sh"># Linux (WSL included)
curl bpt.pizza/get/linux -Lo bpt

# MacOS
curl bpt.pizza/get/macos -Lo bpt

# Both
chmod a+x bpt
./bpt install-yourself
</code></pre>
<h2 id="installing-vscode"><a class="header" href="#installing-vscode">Installing VSCode</a></h2>
<p>Go to <a href="https://code.visualstudio.com/download">VSCode's Download page</a> and install it for your machines host OS.</p>
<blockquote>
<p>Note: For WSL users, this means install on the Windows side.</p>
</blockquote>
<p>On its own VSCode is just a text editor like Windows Notepad but with coloured text however, using extensions we can set it up for developing with any language. Open VSCode as you would any other app in Windows, MacOS or Linux. In VSCode, open the extension marketplace tab. In the search bar, search for the following extensions click on the extension and click and click the install button for them.</p>
<blockquote>
<p>Note: For WSL users, only install the extensions marked 'WSL only' on the Windows side. The other extensions must be installed on the WSL. Install the them after opening VSCode in WSL (instructions below).</p>
</blockquote>
<ul>
<li>C/C++</li>
<li>GitLens</li>
<li>Git Graph</li>
<li>GitHub Pull Requests and Issues</li>
<li>Sonarlint</li>
<li>Remote development (WSL only)</li>
<li>WSL (WSL only)</li>
<li>Remote SSH (WSL only)</li>
</ul>
<p>You may have to restart VSCode for the extensions to load. Finally, press <code>ctrl + ,</code> to open settings. in the search bar search for &quot;cpp default standard&quot;. In the drop down select <code>c++20</code>.</p>
<p>To open VSCode from the terminal, open a new terminal window and type.</p>
<pre><code class="language-sh"># `.` represents 'this' directory
$ code .
</code></pre>
<p>This will open VSCode in the current user directory which should be <code>~</code> which represents your users home directory. WSL users, make sure to launch VSCode from your WSL terminal this time. And that is it, everything should be set up and ready to go.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World!</a></h1>
<p>If you've never programmed before, a &quot;Hello World&quot; program is a simplest program and is often used to introduce a language. The first Hello World was created in Brian Kernighan's 1972 &quot;A Tutorial Introduction to the Language B&quot;.</p>
<h2 id="introducing-c"><a class="header" href="#introducing-c">Introducing C++</a></h2>
<p>Before you write you first C++ program I will cover a basic synopsis of the language's features.</p>
<p>C++ is a high-level, general purpose compiled programming language. It is strongly-typed with a static-type system and supports multi-paradigm programming.</p>
<p>Most of you would have had exposure to interpreted languages (Python, Ruby, Java, Bash etc.) who have a secondary program; called the interpreter, that runs alongside your code, converting the &quot;higher level&quot; instructions into machine code (binary) as it reads through the code.</p>
<p>C++ works differently, it is a compiled language. This simply means all of the C++ code is converted into machine instructions (by a compiler) before you execute the program. This has the benefit of allowing software to run on &quot;bare metal&quot;, meaning the code you write is actually running on the machine (to some degree).</p>
<p>Because of C++ ability to run on baremetal, many people claim it is a &quot;low-level&quot; language however, this could not be more false. Almost all programming languages are mid-to-high level. This is because most support general abstraction techniques take you away from dealing with the machine directly. Only assembly and bytecode languages could be considered &quot;low-level&quot; like; LLVM, x86_64 etc., as these give control over memory and CPU instructions.</p>
<p>But C++ can style more directly interact with the hardware, how can that be if it isn't a low level language. Two things give C++ its power over hardware, first is its <em>memory model</em>. Many languages have little or no notion of memory. Data is data and it is as big or small as it is. How big is <code>int</code> in Python? To many this doesn't cross their minds when writing Python because you don't need to and that is one of the many benefits of Python. However, there is limits to resources you can use in some circumstances and sometimes you need to be able to guarantee certain memory usages from your software. C++ is one of the language that has a &quot;conscious&quot; notion of memory usage and gives you control over these resources. There is one problem with this, not all computer architectures are the same and don't have the same notion of memory. To tackle this, C++ uses the notion of a universal abstract machine. This is C++ second power over hardware. It has mechanisms for interacting with the underlying hardware through the OS but how it gets there is not to the concern of the developer (unless developing in kernel-space as opposed to user-space). You can use standardized features to access these resources effectively.</p>
<p>I mentioned above that C++ is strongly typed with a static type system. What does this mean? A strong typing basically means that types will not be implicitly cast (converted) to a different type (there are some exceptions to this but we'll cover this in chapter 2). A static type system means that all data must have an explicit type that must be known at compile time.</p>
<p>To wrap it off I'll briefly discuss the paradigms and styles you can write C++ in. The most obvious is procedural, similar to C. This paradigm simply uses free functions that operate on free data, performing instructions according to a procedure or set of instructions. Paired with procedural programming, C++ also allows for imperative programming style programming which consists of functions changing the systems state. This style centers mostly on telling the computer what exactly what you want done. C++ also support object-oriented-programming (OOP) with its primary IO library using many OOP patterns to create runtime polymorphism. The most popular paradigm used in C++ today is generic programming. C++ has many features that allows you to write code for generic types as opposed to creating new functions for every possible combination of types. Finally, C++ also supports functional programming patterns that allow for for creating general purpose algorithms that are composed create more specific data manipulation.</p>
<p>Hopefully this gives you an idea into the kind of language C++.</p>
<h2 id="hello-c"><a class="header" href="#hello-c">Hello C++</a></h2>
<p>To begin we are going to open a new terminal window. We are going to create a directory called &quot;hello&quot;, enter it and create some files and open VSCode there.</p>
<pre><code class="language-sh"># Makes new directory
$ mkdir hello

# Enter `hello`
$ cd hello

# Create files `hello.cxx` and `README.md`
$ touch hello.cxx README.md

# Open VSCode
$ code .
</code></pre>
<p>Open the <code>hello.cxx</code> file by clicking it on the left file view.</p>
<p>Here is &quot;Hello World&quot; in C++.</p>
<pre><code class="language-cxx">// This is a comment, these are ignored by the compiler

/// Preprocessor statement using `#` symbol
/// The preprocessor runs at compile time before the code is compiled
/// `#include` copies the header `iostream` into the current file
#include &lt;iostream&gt;

/// Main function
/// Entry point of the executable.
/// Takes no arguments and returns an `int`.
auto main () -&gt; int
{
    /// From the namespace `std`.
    /// Use `cout` (character out).
    /// Put (&lt;&lt;) the string literal to stream.
    /// From `std` put a `endl` specifier. 
    std::cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; std::endl;

    /// Return 0 on successful termination.
    return 0;
}
</code></pre>
<p><a href="chapter1/./examples/hello/hello.cxx">Example</a></p>
<h2 id="build-and-run"><a class="header" href="#build-and-run">Build and Run</a></h2>
<p>Press <code>ctrl + `</code> to open an integrated terminal window in VSCode. Make a new directory called <code>build</code> and run the following command to compile the code.</p>
<pre><code class="language-sh"># Make `build` directory
$ mkdir build

# Compile with GCC
$ g++-12 -std=c++20 -o build/hello hello.cxx

$ ./build/hello
Hello World!
</code></pre>
<p>Let's break this command down.</p>
<ul>
<li><code>g++-12</code> - This is the GNU C++ compiler from the GCC package. The <code>-12</code> just indicates that this is version twelve of GCC.</li>
<li><code>-std=c++20</code> - This sets the C++ standard. The C++ standard is like the version of the language. C++20 is the most recent version.</li>
<li><code>-o build/hello</code> - The <code>-o</code> flag indicates and output file name. Because we wrote it with a path in front of it (<code>build/*</code>), it will output to that path.</li>
<li><code>hello.cxx</code> - The source file we want to compile.</li>
</ul>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<p>Debugging is the crux of fixing issues in code. Debuggers allow us to step through the running code and diagnose any issues that are occurring as they occur. Debugging a single executable is pretty trivial but a sufficiently large codebase can become quite complex.</p>
<p>For that reason we are going to go into debugging a little bit more at the meetup as configuring VSCode is a bit tricky. The debugging also doesn't show anything particularly interesting for a simple &quot;Hello World&quot; program.</p>
<p>If you know how a debugger works, you can have a play with VSCode and see if you can get it to work.</p>
<h2 id="hello-world-using-bpt"><a class="header" href="#hello-world-using-bpt">Hello World using bpt</a></h2>
<p><code>make</code> is a useful tool and paired with <code>cmake</code> you can configure and build very large and complex code bases, but these configuration files are hard to read, tedious to write and error prone. Cmake is also a good and pretty standard in industry for C and C++ developers, but this standard is pretty outdated. So for the majority of this series we're going to be using a new tool called <code>bpt</code>. bpt is a lot like <code>pip</code> (Python), <code>gem</code> (Ruby), <code>hackage</code> (Haskell) and <code>cargo</code> (Rust) allow near seamless control over control over dependencies, testing and distribution of our software.</p>
<blockquote>
<p>Note: bpt is experimental but robust enough to handle most cases. bpt only has a few libraries however, we won't need any dependencies as we are mostly look at the C++ language and C++ Standard Library.</p>
</blockquote>
<p>To start off open a new terminal window and run the following command. Keep the default options by pressing enter for each instruction.</p>
<pre><code class="language-sh">$ bpt new hello-bpt
$ code hello-bpt
</code></pre>
<p>The directory structure should look like this:</p>
<pre><code class="language-sh">hello-bpt
├── README.md
├── bpt.yaml
└── src
    └── hello-bpt
        ├── hello-bpt.cpp
        └── hello-bpt.hpp
</code></pre>
<p>You can delete the <code>hello-bpt</code> directory that is within the <code>src/</code> directory as these are just template files. Create a file in <code>src/</code> called <code>hello.main.cxx</code>. Copy the &quot;Hello World&quot; program from your other directory (or above again) and past into the newly created file.</p>
<blockquote>
<p>Note: bpt uses 'stem-leaf' file extensions to determine the purpose of a file. e.g. the <code>*.main.*</code> middle stem indicates to bpt that this is a executable that is run (as opposed to a library). You'll learn more about these as we go along.</p>
</blockquote>
<p>Now simply run the following command to build the bpt project.</p>
<pre><code class="language-sh">$ bpt build -t :c++20:gcc-12 -o build
</code></pre>
<p>This will spit out the binary into <code>build/</code>, dropping both file extensions. To run the program, simply call.</p>
<pre><code class="language-sh">$ ./build/hello
Hello World!
</code></pre>
<p><a href="chapter1/./examples/hello-bpt/src/hello.main.cxx">Example</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compiler-explorer"><a class="header" href="#compiler-explorer">Compiler Explorer</a></h1>
<p>Compiler Explorer; sometimes referred to as Godbolt (after its creator Matthew Godbolt) is an online compiler for C++. It is good for testing and prototyping small code snippets from C++ across many different compiler versions, from different vendors and on different architectures.</p>
<p>It also displays the assembly output allowing you to have a closer look at what goes on under the hood in C++. It also allows sharing permalinks to instances of Godbolt with specific code and configuration running so you xan distribute working code to anyone as long as they got a browser.</p>
<h2 id="godbolt-"><a class="header" href="#godbolt-">Godbolt ⚡</a></h2>
<p>Head on over to <a href="https://www.godbolt.org/">Compiler Explorer</a> and copy the &quot;Hello World&quot; program into the editor window. It should automatically compile, build and display the results in one of the screens. An example of a sharable link from Godbolt is <a href="https://www.godbolt.org/z/GKxzfees6">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slides"><a class="header" href="#slides">Slides</a></h1>
<p><img src="chapter1/./imgs/hpp_chapter1-01.png" alt="Slides 01" />
<img src="chapter1/./imgs/hpp_chapter1-02.png" alt="Slides 02" />
<img src="chapter1/./imgs/hpp_chapter1-03.png" alt="Slides 03" />
<img src="chapter1/./imgs/hpp_chapter1-04.png" alt="Slides 04" />
<img src="chapter1/./imgs/hpp_chapter1-05.png" alt="Slides 05" />
<img src="chapter1/./imgs/hpp_chapter1-06.png" alt="Slides 06" />
<img src="chapter1/./imgs/hpp_chapter1-07.png" alt="Slides 07" />
<img src="chapter1/./imgs/hpp_chapter1-08.png" alt="Slides 08" />
<img src="chapter1/./imgs/hpp_chapter1-09.png" alt="Slides 09" />
<img src="chapter1/./imgs/hpp_chapter1-10.png" alt="Slides 10" />
<img src="chapter1/./imgs/hpp_chapter1-11.png" alt="Slides 11" />
<img src="chapter1/./imgs/hpp_chapter1-12.png" alt="Slides 12" />
<img src="chapter1/./imgs/hpp_chapter1-13.png" alt="Slides 13" />
<img src="chapter1/./imgs/hpp_chapter1-14.png" alt="Slides 14" />
<img src="chapter1/./imgs/hpp_chapter1-15.png" alt="Slides 15" />
<img src="chapter1/./imgs/hpp_chapter1-16.png" alt="Slides 16" />
<img src="chapter1/./imgs/hpp_chapter1-17.png" alt="Slides 17" />
<img src="chapter1/./imgs/hpp_chapter1-18.png" alt="Slides 18" />
<img src="chapter1/./imgs/hpp_chapter1-19.png" alt="Slides 19" />
<img src="chapter1/./imgs/hpp_chapter1-20.png" alt="Slides 20" />
<img src="chapter1/./imgs/hpp_chapter1-21.png" alt="Slides 21" />
<img src="chapter1/./imgs/hpp_chapter1-22.png" alt="Slides 22" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics-of-c"><a class="header" href="#basics-of-c">Basics of C++</a></h1>
<p>In this chapter you will be introduced to C++ the type system, how it differs from other languages and how types reflect machine architecture. You will also learn about variable declarations, type qualifiers and a few of the key operators and IO facilities in C++. You will also be exposed to the concept of ordering, equality and the logical operators in C++. You will also learn about conditional logic and how it can be used to create structure and control the flow of a program. You will also learn about C++ looping facilities and how it can be used to perform iterative programming. Finally, you will learn the basics of functions in C++.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-c-type-system"><a class="header" href="#the-c-type-system">The C++ Type System</a></h1>
<h2 id="strong-vs-weak-typing"><a class="header" href="#strong-vs-weak-typing">Strong vs Weak Typing</a></h2>
<p>In <a href="chapter2/../chapter1/helloworld.html">1.3 Hello World</a> we discussed a bit about C++'s types system. But what is a type system? A type system is a formal notion of which terms have which properties. The rules and constructs of a type system underpin the meaning help by any discourse written in any and all programming languages. Without a type system, programming languages cannot construct grammar or structure and thus cannot become coherent and cohesive expressions of language.</p>
<p>This is all a bit abstract and delves into <a href="https://en.wikipedia.org/wiki/Type_theory">Type Theory</a> which is a more formal, mathematical notion of types. For our purposes we will just look at what C++'s type system does.</p>
<p>First and foremost, C++ is considered by many (but not universally) to be a strongly typed language. There isn't a universal definition of a strong or weak types but the basic premise is based around the question:</p>
<blockquote>
<p>Does the type system allow implicit conversions between type?</p>
</blockquote>
<p>In the case of C++, 90% of types have no implicit conversions. The only contradiction to this is type promotion or narrowing, this is when types of the same <em>kind</em> get promoted or narrowed to a similar yet different type. This occurs for some type in C++ because the bit width, layout and structure are so similar; due to how memory in computers work, that some types will implicitly meet the requirements of of another type. While this can occur in C++, it is limited to only a handful of primitive <em>data types</em>. Weaker typing allows for this implicit conversions to happen more frequently (think JavaScript's type system).</p>
<h2 id="static-vs-dynamic-type-systems"><a class="header" href="#static-vs-dynamic-type-systems">Static vs Dynamic Type Systems</a></h2>
<p>So what about static and dynamic typing? These characterisations refer to the type checking techniques used in a language and how a language expresses the notion of types. These are the two key ways to look at either static or dynamic typing.</p>
<p>In a dynamically typed language, the type of an object does not have to be explicitly stated, but is inferred at runtime based on its contexts and the surrounding expressions. Python is a good example of this as you can create an object and assign it a type without ever declaring what type the object should be. This allows interpreters to forego type checking until a particular operation is performed on an object which may or may not fail. In a statically typed language, this is the opposite. You must formally declare the type of an object and i must be known to the system before the program ever runs. Most often, it must be known at compile time. However, some languages can forego an explicit <strong>notation</strong> of an object type and allow the compiler to infer the type. C++ and many other compiled languages; like Rust, are capable of type inference using various <strong>argument deduction</strong> techniques.</p>
<h2 id="a-pinch-of-type-theory"><a class="header" href="#a-pinch-of-type-theory">A Pinch of Type Theory</a></h2>
<p>Before we move on, there a some important definitions that are good to know going forward.</p>
<ul>
<li>Literals - A literal is a constant that refers to a determined value. For example, the character for 'three', <code>3</code>, has the value of three.</li>
<li>Values - A value is the independent data of a type. Think of it as an instance or object.</li>
<li>Types - A type is the formal definition and classification of values that is exhibit particular properties related properties. Examples of types include primitive data; like <code>int</code> from Python, as well as user defined types, often called classes in many languages. In C++ types are created using the <code>struct</code> and <code>class</code> keywords.</li>
<li>Typeclasses - A typeclass is a polymorphic type constraint. It defines the expected properties of a type including methods, functions and patterns. In C++ typeclasses are created using the <code>concept</code> keyword.</li>
<li>Kinds - A kind is, well; to put it bluntly, a type of a type. It describes the type of a nullary type constructor, ie. the constructor of primitive data-types which take no parameters. What this basically means is something that can hold a value.</li>
</ul>
<p>In C++ supports everything except Kinds. We will go more into a little more depth during Chapter 5.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h1>
<p>Like most languages, C++ comes with a small set of types that are built into the language. Almost every other type created and used in the language is some combination or composition of these types.</p>
<h2 id="size-and-width"><a class="header" href="#size-and-width">Size and Width</a></h2>
<p>In C++, all types have an implicit property called width or size. This refers to how much memory; in bits or bytes, a given type maximally occupies. This leaves enough room for any value of the given type to fit in the allocated spot. The minimum size a type can occupy in C++ is 8-bits or a byte.</p>
<h2 id="integral-types"><a class="header" href="#integral-types">Integral Types</a></h2>
<p>Integral types are the most basic kind of type in C++. These types represent whole numerical values of varying sizes. Some are used to represent logical values, other character code point and some are just plain old number types.</p>
<h3 id="boolean-type"><a class="header" href="#boolean-type">Boolean Type</a></h3>
<p>The first type we will look at is <code>bool</code>. <code>bool</code> represents a Boolean value, meaning it is either <code>true</code> or <code>false</code>. This is a specialization of a unique type-function called a sum type. A sum type is a type that can hold one of its possible variants (also called 'appends' or 'injections'), in this case these are the type constructors <code>true</code> and <code>false</code>. However, in C++ <code>bool</code> is built-in to the language and thus these properties are hidden away.</p>
<p><code>bool</code> occupies a memory space of 8-bits or a byte. It is also worth pointing out that <code>true</code> and <code>false</code> are literals (as they are built-in keywords) holding there respective values independently. Booleans are used to denote truthiness and logic in a programming language. In C++, <code>bool</code> can be implicitly promoted to another integral type such as <code>int</code> with <code>false</code> becoming <code>0</code> and <code>true</code> becoming <code>1</code>. Other integral types also can be narrowed to a <code>bool</code> with <code>0</code> becoming <code>false</code> and anything else becoming <code>true</code>.</p>
<h3 id="character-types"><a class="header" href="#character-types">Character Types</a></h3>
<p>The next type we will look is the <code>char</code>. This is C++ standard character type. These are values such as <code>'a'</code> or even escape characters like <code>'\n'</code>. It holds only a single byte (same as <code>bool</code>) allowing it to represent \( 2^8 = 256 \) different values. Depending on the system is is either <code>signed</code> or <code>unsigned</code>, meaning either the leading bit is dedicated to the sign of the value or is another number point. Depending on the representation, <code>char</code> can have a value between <code>0..255</code> (unsigned) or <code>-127..128</code> (signed). Character literals exclusively use single quotes in C++.</p>
<p>There is another character type in C++ called <code>wchar_t</code>. This is a 'wide character' which can hold more bits than the <code>char</code> type. On Windows systems it is 16-bits (2-bytes) while on Unix based systems (Linux, macOS etc.) this is typically 32-bits (4-bytes). This allows for <code>wchar_t</code> to be to store many more different codepoints. A wide character literal also uses single quotes however, the quote pair is prefixed with a 'L' eg. 'a' as a <code>wchar_t</code> literal looks like <code>L'a'</code>.</p>
<p>Like <code>bool</code>, <code>char</code> and <code>wchar_t</code> are integral types, this means that they are really numbers however, the system will treat them differently, eg. for IO.</p>
<h3 id="number-types"><a class="header" href="#number-types">Number Types</a></h3>
<p>There is only one primary number type in C++ called <code>int</code>. This represents a (typically) 32-bit (4-byte), signed number. It can store \( 2^{32} = 4,294,967,296 \) values has a value range of <code>-2'147'483'647..2'147'483'648</code>. <code>int</code> is probably the most basic type in terms of bit layout in C++ with every bit storing data from the number with only the first bit indicating the sign of the number.</p>
<h2 id="float-point-types"><a class="header" href="#float-point-types">Float Point Types</a></h2>
<p>C++ has two distinct floating point number types. These are <code>float</code> and <code>double</code>. <code>float</code> implements the IEEE-754 binary32 floating point format while <code>double</code> implements the IEEE-754 binary64 floating point format, hence the name <code>double</code> indicating double floating point precision.</p>
<p>Floating point numbers are a unique problem in computing. It is impossible to represent all precisions a decimal number can have (number of decimal places) which still being able to compute large numbers with limited memory. To tackle this, floating point numbers break up the bit-space of the floating point into the sign, fraction and exponents chapters. The IEEE-754 binary32 format uses 1-bit for the sign, 8-bits (a byte) for the exponent and and 23-bits (3-bytes - 1-bit) for the fraction. The IEEE-754 binary64 format has; again 1-bit for the sign, 11-bits for the exponent and 52-bits for the fraction chapter. This gives you (greater than) double the number bits you can use represent your fraction chapter or \( 536,870,912 \) times more possible values for the fraction chapter of a <code>double</code> over a <code>float</code> (\( 2^{52}=4.5035996\cdot10^{15} \) vs \( 2^{23}=8,388,608 \)).</p>
<h2 id="void"><a class="header" href="#void">Void</a></h2>
<p>In C++ there is a unique type called called <code>void</code>. This is an incomplete and it can not be completed. It is a unique type of literal but it holds no value. <code>void</code> is used to indicate the absence of a return value (and input parameter value in C). It is different from the unit type (which is not explicitly present in C++) which has the type <code>()</code> and value <code>()</code>, <code>void</code> has the type of <code>void</code> but not the value of <code>void</code>. It has no value.</p>
<h2 id="nullptr"><a class="header" href="#nullptr">Nullptr</a></h2>
<p><code>nullptr</code> is a literal type which has type of <code>std::nullptr_t</code> and value of <code>nullptr</code>. This is a unique type used by pointers to indicate that they point to nothing.</p>
<h2 id="other-types"><a class="header" href="#other-types">Other Types</a></h2>
<p>There are two more types in C++ that are worth talking about. These are <code>std::size_t</code> and <code>std::ptrdiff_t</code>. <code>std::size_t</code> is a platform dependent type that indicates the maximum possible size of an unsigned integer in C++. This is typically a 32-bit or 64-bit number types.</p>
<p><code>std::ptrdiff_t</code> is a signed number type that is returned by subtracting two pointers in C++.</p>
<h2 id="auto"><a class="header" href="#auto">Auto</a></h2>
<p>While C++ is a statically typed language, it is able to infer and deduce the types of many things at compile time. This is achieve with a non-type keyword called <code>auto</code>. While <code>auto</code> is used in many places that type specifiers are used (more on this in the next section), it is important to note that it itself is not a type but rather a automatic type, essentially a placeholder for the to-be deduced type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Variables are the first form of abstraction in any mathematical and logical system and computers are no exception. In C++ a variable is an owner of some value. You can use variables to store the value of something and use it in different places throughout your software. Variables can only be of one type, this is the type of the value they hold.</p>
<p>To declare a variable in C++ is super simple and follows the following pattern <code>&lt;type&gt; &lt;name&gt; &lt;initialiser&gt;;</code>. That's it, pretty simple. However, like many things in C++ there is a slight catch. How does a variable acquire a value. In C++ there is a concept known as Resource Acquisition Is Initialisation (RAII). This essentially means that when a type obtains a resource; or rather, obtains all its necessary resources it can be considered initialised.</p>
<p>So what does this all mean? This means that C++ has strict rules about how values can be given to variables and that certain requirements need to be made by the constructor of a type and the variable receiving the newly constructed value of that type. However, this is mostly technical speak but seeing a bit of it now can give you a better foundation to understand some weird quirks C++ has that you will most likely encounter in the future. We will cover constructors at a later date and focus on how to initialise a variable.</p>
<h2 id="initialisation"><a class="header" href="#initialisation">Initialisation</a></h2>
<p>To begin, open a new file or compiler explorer window so we can start writing. Make sure to have the main function so the program can run. Look in <a href="chapter2/../../resources/blueprint.cxx">/resources/blueprint.cxx</a> for a copy of main.</p>
<h3 id="default-initialisation"><a class="header" href="#default-initialisation">Default Initialisation</a></h3>
<p>Before we saw that creating a variable has the pattern <code>&lt;type&gt; &lt;name&gt; &lt;initialiser&gt;</code>. <code>&lt;type&gt;</code> can be any type we've seen so far or the <code>auto</code> keyword. <code>&lt;name&gt;</code> can be any alphanumeric (plus _) combination of characters (as long as the first character is not a number). For example an <code>int</code> called <code>i</code> would be.</p>
<pre><code class="language-cpp">int i /* &lt;initialiser&gt; */;
</code></pre>
<p>But what is an initialiser? This is something that creates a value for a variable. In fact we can remove the comment as <code>i</code> has already been initialised at this point. What you are seeing above is what is called default initialisation. This is when a type is in its default or empty state which is typically an undetermined state. For <code>int</code> and in fact for all builtin types, the default initialiser will leave the corresponding variable; <code>i</code> in this case` in what's called an indeterminate state, as in its value cannot be guaranteed. In accessing default initialised variable is undefined behavior (UB) so there is no telling what can happen if you do but most like and hopefully, it will fail to compile or the program will crash when it gets to the line accessing the default initialised variable.</p>
<pre><code class="language-cxx">/// Primitive Data Types
bool b = true
int i;
char c;
wchar_t wc;
float f;
double d;
void foo();
std::nullptr_t;
nullptr;
std::size_t sz;
std::ptrdiff_t pd;
auto a = {1};  ///&lt; must have initialiser for type deduction.
</code></pre>
<p><a href="https://en.cppreference.com/w/cpp/language/default_initialization">Default Initialisation</a></p>
<h3 id="value-initialisation"><a class="header" href="#value-initialisation">Value Initialisation</a></h3>
<p>Value initialisation is used to zero-initialise a scalar variable (eg. <code>int</code> etc.) or default initialise a user defined type such as a <code>class</code>. The syntax for value initialisation varies but it typically uses <code>&lt;type&gt; &lt;name&gt; {}</code> or <code>&lt;type&gt; ()</code>. This is the preferred and recommended way to to initialise variables without giving them an explicit value.</p>
<pre><code class="language-cxx">int a{};                ///&lt; zero-initialises `a` to `0`.
int();                  ///&lt; zero-initialises a temporary to `0`.
T t{};                  ///&lt; Default initialises `t` using `T` default constructor
</code></pre>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/value_initialization">Value Initialisation</a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/zero_initialization">Zero Initialisation</a></li>
</ul>
<h3 id="copy-initialisation"><a class="header" href="#copy-initialisation">Copy Initialisation</a></h3>
<p>Copy initialisation is the most common type of initialisation found in C++ as it is the method originally derived from C. Copy initialisation revolves around the assignment operator <code>=</code> but is not exclusive to it. By default, most operations in C++ use copies and thus are initialised using copy initialisation. Copy initialisation copies any expression on the right-hand-side of the <code>=</code>, provided the type is correct.</p>
<pre><code class="language-cxx">int a = 1;              ///&lt; Copies the value of the literal `1`.
int b = {2};            ///&lt; List initialisation through copy. Narrowing conversions are prohibited.
int c = foo();          ///&lt; Copies through `return` of `foo`.
T t2(t1);               ///&lt; Copies `t1` to `t2` using `T` copy constructor.
</code></pre>
<p>Up until now, we haven't been able to give our variables custom values. With copy initialisation we can copy literals and values from other variables giving use access to any and all data. While <code>T t = v</code> is allowed for any correct value <code>v</code> of type <code>T</code>, it is preferred to use <code>T t = {v}</code> as this prevents implicit conversions.</p>
<p><a href="https://en.cppreference.com/w/cpp/language/copy_initialization">Copy Initialisation</a></p>
<h3 id="direct-initialisation"><a class="header" href="#direct-initialisation">Direct Initialisation</a></h3>
<p>Direct initialisation allows you to initialise a variable with an explicit set of constructor arguments. This is mostly useful for custom constructor beyond the trivial ones the compiler can provide.</p>
<pre><code class="language-cxx">int a{1};       ///&lt; Single element, brace-enclosed initialiser. Must be of the same type.
T t(2, 3);      ///&lt; Direct initialisation of `t` with literals `2` and `3`.
U u(v);         ///&lt; Direct initialisation of `u` with `v` which may be of a different type `V`.
W(x);           ///&lt; Direct initialisation of temporary of type `W` with existing `x` of possible different type `X`.
Y(4, 6, 5);        ///&lt; Direct initialisation of temporary of type `Y` with literals `4`, `5` and `6`.
</code></pre>
<p><a href="https://en.cppreference.com/w/cpp/language/direct_initialization">Direct Initialisation</a></p>
<h3 id="aggregate-initialisation"><a class="header" href="#aggregate-initialisation">Aggregate Initialisation</a></h3>
<p>Aggregate initialisation is special list initialisation for aggregate types. These are slice, <code>struct</code>, <code>class</code> or <code>union</code> types with (for the formers) no private data-members or user-defined constructors. This allows them to be initialised with a list.</p>
<pre><code class="language-cxx">T t = {1, 2, 3};                ///&lt; Copy list initialisation of aggregate `t` of type `T`.
U u{ 4, 5, 6};                  ///&lt; List initialisation of aggregate `u` of type `U`.
V v = { .v1 = 7, .v2{8} };      ///&lt; Copy list initialisation of aggregate `v` of type `V` with designated initialisers for `v`'s members.
W w{ .w1 = 9, .w2{10} };        ///&lt; List initialisation of aggregate `w` of type `W` with designated initialisers for `w`'s members.
</code></pre>
<p>We want use this directly all to much as list initialisation generally applies in more cases.</p>
<p><a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization">Aggregate Initialisation</a></p>
<h3 id="list-initialisation"><a class="header" href="#list-initialisation">List Initialisation</a></h3>
<p>List initialisation is a generalisation of aggregate initialisation but can be applied to user-defined types. This allows you to specify a list of values to be used as arguments for a constructor.</p>
<pre><code class="language-cxx">T t {1, 2, 3, 4};           ///&lt; Direct-list initialisation.
U u = {5, 6, 7, 8};         ///&lt; Copy-list initialisation.
t = {4, 3, 2, 1};           ///&lt; Copy-list assignment.
foo({1, 2, 3});             ///&lt; Argument copy-list initialisation.
W w({4, 5, 6});             ///&lt; Direct constructor list initialisation.
</code></pre>
<p>Have a play with with these and see what works with the compiler. In general, stick to using copy and direct initialisation. It might be easier to play with on <a href="https://www.godbolt.org/z/Y34xxoahz">Example _</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/list_initialization">List Initialisation</a></p>
<h2 id="qualifiers"><a class="header" href="#qualifiers">Qualifiers</a></h2>
<p>Types can have different qualifiers that change how a type behaves from its size to mutability. Qualifiers go before the type declaration.</p>
<h3 id="signed-ness"><a class="header" href="#signed-ness">Signed-ness</a></h3>
<p>The <code>signed</code> and <code>unsigned</code> qualifiers are used to indicate whether the first bit of the integral type is used for the sign of a number or not. All integral types are implicitly <code>signed</code> (<code>char</code> can vary). <code>unsigned</code> increases the maximum number an integral can be but disallows negative values. <code>unsigned</code> only works on integer types and not floating point types.</p>
<h3 id="size"><a class="header" href="#size">Size</a></h3>
<p>Size qualifiers are used to indicate the number of bits (which is platform specific) an <code>int</code> type must have at least.</p>
<ul>
<li><code>short int</code> - 16-bits at least</li>
<li><code>int</code> - 16-bits at least (typically 32-bits)</li>
<li><code>long int</code> - 32-bits at least</li>
<li><code>long long int</code> - 64-bits at least</li>
</ul>
<p>You can also combined size qualifiers with the <code>unsigned</code> (and <code>signed</code> though not strictly necessary) to allow much larger numbers. You are also able to drop the <code>int</code> type in favour of just the size qualifiers and C++ will infer it to be <code>int</code>. <code>long</code> can also be used with <code>double</code> to create a (on some systems) binary128 floating point number.</p>
<table><thead><tr><th align="center">Size Qualifiers / Primitive Type</th><th align="center"><code>short</code></th><th align="center"><code>unsigned short</code></th><th align="center"><code>signed</code></th><th align="center"><code>unsigned</code></th><th align="center"><code>long</code></th><th align="center"><code>unsigned long</code></th><th align="center"><code>long long</code></th><th align="center"><code>unsigned long long</code></th></tr></thead><tbody>
<tr><td align="center"><code>bool</code></td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr>
<tr><td align="center"><code>char</code></td><td align="center">❌</td><td align="center">❌</td><td align="center">✅</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr>
<tr><td align="center"><code>wchar_t</code></td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr>
<tr><td align="center"><code>int</code></td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr>
<tr><td align="center"><code>float</code></td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr>
<tr><td align="center"><code>double</code></td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td><td align="center">✅</td><td align="center">❌</td><td align="center">❌</td><td align="center">❌</td></tr>
</tbody></table>
<p><a href="https://en.cppreference.com/w/cpp/language/types">Fundamental Types</a></p>
<h3 id="storage"><a class="header" href="#storage">Storage</a></h3>
<p>Storage qualifiers allow you to specify the lifetime of variables. All variables implicitly have automatic storage duration. The exist only in a certain scope, are created when the program enters that scope and dropped at the end of that scope. <code>static</code> (and implicitly global variables) are created at the beginning of the program and are dropped only at the end of the program. Only one variable of the same name can be declared static in a given translation unit.</p>
<pre><code class="language-cxx">static int si = {1};  ///&lt; static variables

{
    int li = {2};  ///&lt; local automatically dropped variable
}
</code></pre>
<p><code>inline</code> is more of a hint to the compiler for functions and methods. It indicates to the compiler that a function call should be inlined at call, ie. the functions definition gets moved to the call site. This qualifier is mostly used in OOP classes hierarchies as its more general use has be dropped in favour of a different qualifier.</p>
<h3 id="mutability"><a class="header" href="#mutability">Mutability</a></h3>
<p>In C++, variables are mutable by default. There are various ways to limit the mutability of variables as well as constrain the optimisations a compiler can apply.</p>
<ul>
<li><code>const</code> - A <code>const</code> object is an immutable object, it cannot be changes. It must be initialised with a values.</li>
<li><code>constexpr</code> - A <code>constexpr</code> is; as the names suggests, a constant expression. It is an expression that <em>may</em> be evaluated at compile time. Similar to <code>const</code>.</li>
<li><code>volatile</code> - Indicates to the compiler that the variable may change in ways that it is unaware of and to avoid optimising this variables use in case of undesired behavior.</li>
<li><code>mutable</code> - Indicates a member variable may be modified even through const-qualified methods (we'll see this in <a href="chapter2//content/week5/README.html">Week 5</a>).</li>
</ul>
<pre><code class="language-cxx">int i = {0};
const int ci = {1};
constexpr int cx = {2};
volatile int vi = {3};
const volatile int cv = {4};

i = 6;      ///&lt; Ok
ci = 7;     ///&lt; Error
cx = 8;     ///&lt; Error
vi = 9;     ///&lt; Ok
cv = 10;    ///&lt; Error
</code></pre>
<blockquote>
<p>Note: The usage of <code>volatile</code> is highly discouraged.</p>
</blockquote>
<h2 id="automatic-types"><a class="header" href="#automatic-types">Automatic Types</a></h2>
<p>The final type we look at is an automatic type. As we will see later, declaring the type of variables can get cumbersome. Since C++11, a new type introducer was create with the keyword <code>auto</code>. Variables with type <code>auto</code> will have there true type deduced at compile time based on the initialiser.</p>
<pre><code class="language-cxx">auto ai int{1};                 ///&lt; `ai` deduced to have the type `int`
auto al = {2L};                 ///&lt; `al` deduced to have the type `long` or `long int` (uses 'L' literal)
auto ac {'c'};                  ///&lt; `ac` deduced to have the type `char`
auto as = &quot;hello&quot;;              ///&lt; `as` deduced to have the type `const char*` (more on these later)
</code></pre>
<h2 id="value-categories"><a class="header" href="#value-categories">Value Categories</a></h2>
<p>In C++, there are different categories of values. These determine the operations that can be performed on them. There are a few value categories in C++ but we will focus on only two of them, lvalues and rvalues.</p>
<h3 id="lvalues"><a class="header" href="#lvalues">lvalues</a></h3>
<p>In C++ and lvalue is kind of value that you would find on the left-hand-side of the <code>=</code>, hence the name lvalue or 'left-value'. You can also find lvalues on the right-hand-side of <code>=</code>. This is the semantics of a copy (may or may not be an initialisation). Typically, a variable that has an assigned value is an lvalue.</p>
<h3 id="rvalues"><a class="header" href="#rvalues">rvalues</a></h3>
<p>rvalues are; as the name suggests, variables or values found on the right-hand-side of <code>=</code>. This includes literals, temporaries and moves. For example the literal <code>3</code> is an rvalue. rvalues are also used to indicate move-semantics (more on this later on).</p>
<h3 id="literals"><a class="header" href="#literals">Literals</a></h3>
<p>Literals are types that have a explicit value to them. The literal <code>0</code> has the value of <code>int{0}</code> and type <code>int</code>. Literals allow the to be common code-point to define values into a specific character or character sequence. Essentially, literals hold the value and type they indicate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>Operators are unique symbols that are used to perform changes to data. They often have infix notation with some having prefix or postfix notation. In C++, all operators are functions however, they are built into the language fpr primitive data types.</p>
<h2 id="basic-arithmetic"><a class="header" href="#basic-arithmetic">Basic Arithmetic</a></h2>
<p>So enough about types and values. Lets write some code that does something. In C++ there are a lot, and I mean a lot of operators but we will only cover the arithmetic based one this week. The first ones we will look at are the basic arithmetic operators. These include your standard:</p>
<ul>
<li><code>+</code> - Addition</li>
<li><code>-</code> - Subtraction</li>
<li><code>*</code> - Multiplication</li>
<li><code>/</code> - Division</li>
<li><code>%</code> - Modulo</li>
</ul>
<p>For the meanwhile we will only look at operations on integers and floating point types. For these types the operators do what you would expect. Try out the following operations.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a{10};
    auto b{3};

    std::cout &lt;&lt; &quot;a + b = &quot; &lt;&lt; a + b &lt;&lt; std::endl;  ///&lt; a + b = 13
    std::cout &lt;&lt; &quot;a - b = &quot; &lt;&lt; a - b &lt;&lt; std::endl;  ///&lt; a - b = 7
    std::cout &lt;&lt; &quot;a * b = &quot; &lt;&lt; a * b &lt;&lt; std::endl;  ///&lt; a * b = 30
    std::cout &lt;&lt; &quot;a / b = &quot; &lt;&lt; a / b &lt;&lt; std::endl;  ///&lt; a / b = 3??
    std::cout &lt;&lt; &quot;a % b = &quot; &lt;&lt; a % b &lt;&lt; std::endl;  ///&lt; a % b = 1

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/xKMooTb4s">Example</a></p>
<blockquote>
<p>Note: for those unaware, <code>%</code> returns the remained of the division of \( \frac{a}{b} \)</p>
</blockquote>
<p>But hold up, why does <code>a / b</code> return <code>3</code>, should it not be <code>3.33...</code>? This correct.. sorta. In C++ when two integers divide it performs integer division, thus throwing away any remainder after the maximum even divisions. This is the same as Pythons <code>//</code> operator. To perform floating point division, either the numerator or denominator needs to be of a floating point type. This is so the alternate one (if it is an integer type) can be promoted to a floating point type to perform the floating point division.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a{10};
    auto b{3};
    auto c{3.};
    auto d{10.};

    std::cout &lt;&lt; &quot;a / c = &quot; &lt;&lt; a / c &lt;&lt; std::endl;  ///&lt; a / c = 3.33333
    std::cout &lt;&lt; &quot;d / b = &quot; &lt;&lt; d / b &lt;&lt; std::endl;  ///&lt; d / b = 3.33333

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/eeYqPbcaT">Example</a></p>
<blockquote>
<p>Note: The modulo operator does not work for floating point types as this illogical (can't return remainder of a floating point division as it is near impossible to regain the information).</p>
</blockquote>
<p>You can also use <code>+</code> and <code>-</code> to change/force the sign of a integer or floating point type.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto e{-5.43};
    auto f{0.71};

    std::cout &lt;&lt; &quot;e + f = &quot; &lt;&lt; e + f &lt;&lt; std::endl;          ///&lt; e + f = -4.72
    std::cout &lt;&lt; &quot;-e + f = &quot; &lt;&lt; -e + f &lt;&lt; std::endl;        ///&lt; -e + f = 6.14
    std::cout &lt;&lt; &quot;e - -f = &quot; &lt;&lt; e - f &lt;&lt; std::endl;         ///&lt; e - f = -6.14
    std::cout &lt;&lt; &quot;e - -f = &quot; &lt;&lt; e - -f &lt;&lt; std::endl;        ///&lt; e - -f = -4.72

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/o9afoszjP">Example</a></p>
<p>There are also in-place operators <code>++</code> and <code>--</code>. These allow you to increment/decrement integer types in place. There are two variations, prefix and postfix. Prefix will increment/decrement the value and then provide a lvalue of the new value of the object to whatever is reading it (if any). Postfix will provide an lvalue to copy of the old value and then increment/decrement the value.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto g{1};
    auto h{5};

    std::cout &lt;&lt; &quot;g++ = &quot; &lt;&lt; g++ &lt;&lt; std::endl;      ///&lt; g++ = 1
    std::cout &lt;&lt; &quot;g = &quot; &lt;&lt; g &lt;&lt; std::endl;          ///&lt; g = 2
    std::cout &lt;&lt; &quot;++g = &quot; &lt;&lt; ++g &lt;&lt; std::endl;      ///&lt; ++g = 3
    std::cout &lt;&lt; &quot;g = &quot; &lt;&lt; g &lt;&lt; std::endl;          ///&lt; g = 3

    std::cout &lt;&lt; &quot;h-- = &quot; &lt;&lt; h-- &lt;&lt; std::endl;      ///&lt; h-- = 5
    std::cout &lt;&lt; &quot;h = &quot; &lt;&lt; h &lt;&lt; std::endl;          ///&lt; h = 4
    std::cout &lt;&lt; &quot;--h = &quot; &lt;&lt; --h &lt;&lt; std::endl;      ///&lt; --h = 3
    std::cout &lt;&lt; &quot;h = &quot; &lt;&lt; h &lt;&lt; std::endl;          ///&lt; h = 3

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/5Ps5ezhaT">Example</a></p>
<h2 id="casts"><a class="header" href="#casts">Casts</a></h2>
<p>In C++ you can change the type of an object via casting. There are quite a few different casting operators.</p>
<ul>
<li><code>const_cast&lt;T&gt;(expr)</code> - Changes cv-qualifications (cv := const-volatile)</li>
<li><code>static_cast&lt;T&gt;(expr)</code> - Attempts to cast <code>expr</code> entirely different type <code>T</code>.</li>
<li><code>reinterpret_cast&lt;T&gt;(expr)</code> - Reinterprets the underlying bit pattern of <code>expr</code>.</li>
<li><code>dynamic_cast&lt;T&gt;(expr)</code> - Allows for casting up, down and sideways through class hierarchies.</li>
</ul>
<blockquote>
<p>Note: <code>T</code> is the type that the <code>expr</code> is being cast to.</p>
</blockquote>
<p>You will likely not come across needing to any of the casts except <code>static_cast&lt;T&gt;(expr)</code>. Reach for this first.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a{10};
    auto b{3};

    /// Explicitly cast `b` to a `double`
    std::cout &lt;&lt; &quot;a / b = &quot; &lt;&lt; a / static_cast&lt;double&gt;(b) &lt;&lt; std::endl;  ///&lt; a / b = 3.33333

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/E6GTExxEj">Example</a></p>
<h2 id="bitwise-operations"><a class="header" href="#bitwise-operations">Bitwise Operations</a></h2>
<p>In C++ there is another category of operators called bitwise operators. These operators only apply to integer types but allow for you to individually control the bits of an integer.</p>
<ul>
<li><code>&amp;</code> - Bitwise And</li>
<li><code>|</code> - Bitwise Or</li>
<li><code>^</code> - Bitwise Xor</li>
<li><code>&lt;&lt;</code> - Bitwise Left Shift (Left Rotate)</li>
<li><code>&gt;&gt;</code> - Bitwise Right Shift (Right Rotate)</li>
</ul>
<blockquote>
<p>Note: We've seen <code>&lt;&lt;</code> before with <code>std::cout</code>. In the case of <code>std::cout</code> <code>&lt;&lt;</code> means 'put (to)'. It is simply an overloaded operator used for ease of use. It doesn't correlate to the bitwise meaning.</p>
</blockquote>
<p>Each of the bitwise operators perform their respective logical operations on each of the bits the the two values or points and returns the new value.</p>
<pre><code class="language-cxx">#include &lt;bitset&gt;
#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto i{5};
    auto j{4};

    std::cout &lt;&lt; &quot;i &amp; j = &quot; &lt;&lt; (i &amp; j) &lt;&lt; std::endl;                            ///&lt; i &amp; j = 4
    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; std::bitset&lt;8&gt;{i} &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&amp; &quot; &lt;&lt; std::bitset&lt;8&gt;{j} &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;----------&quot; &lt;&lt; std:: endl;
    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; std::bitset&lt;8&gt;{i &amp; j} &lt;&lt; std::endl;                    ///&lt; i &amp; j =  00000100

    std::cout &lt;&lt; &quot;i | j = &quot; &lt;&lt; (i | j) &lt;&lt; std::endl;                            ///&lt; i | j = 4
    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; std::bitset&lt;8&gt;{i} &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;| &quot; &lt;&lt; std::bitset&lt;8&gt;{j} &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;----------&quot; &lt;&lt; std:: endl;
    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; std::bitset&lt;8&gt;{i | j} &lt;&lt; std::endl;                    ///&lt; i | j =  00000101

    std::cout &lt;&lt; &quot;i ^ j = &quot; &lt;&lt; (i ^ j) &lt;&lt; std::endl;                            ///&lt; i ^ j = 4
    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; std::bitset&lt;8&gt;{i} &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;^ &quot; &lt;&lt; std::bitset&lt;8&gt;{j} &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;----------&quot; &lt;&lt; std:: endl;
    std::cout &lt;&lt; &quot;  &quot; &lt;&lt; std::bitset&lt;8&gt;{i ^ j} &lt;&lt; std::endl;                    ///&lt; i ^ j =  00000001

    std::cout &lt;&lt; &quot;i &lt;&lt; j = &quot; &lt;&lt; (i &lt;&lt; j) &lt;&lt; std::endl;                          ///&lt; i &lt;&lt; j = 4
    std::cout &lt;&lt; &quot;   &quot; &lt;&lt; std::bitset&lt;8&gt;{i} &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&lt;&lt; &quot; &lt;&lt; std::bitset&lt;8&gt;{j} &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;-----------&quot; &lt;&lt; std:: endl;
    std::cout &lt;&lt; &quot;   &quot; &lt;&lt; std::bitset&lt;8&gt;{i &lt;&lt; j} &lt;&lt; std::endl;                  ///&lt; i &lt;&lt; j =  01010000

    std::cout &lt;&lt; &quot;i &gt;&gt; j = &quot; &lt;&lt; (i &gt;&gt; j) &lt;&lt; std::endl;                          ///&lt; i &gt;&gt; j = 4
    std::cout &lt;&lt; &quot;   &quot; &lt;&lt; std::bitset&lt;8&gt;{i} &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;&gt;&gt; &quot; &lt;&lt; std::bitset&lt;8&gt;{j} &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;-----------&quot; &lt;&lt; std:: endl;
    std::cout &lt;&lt; &quot;   &quot; &lt;&lt; std::bitset&lt;8&gt;{i &gt;&gt; j} &lt;&lt; std::endl;                  ///&lt; i &gt;&gt; j =  00000000

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/37b58aTjf">Example</a></p>
<h3 id="a-bit-about-shift-operations"><a class="header" href="#a-bit-about-shift-operations">A bit about shift operations</a></h3>
<p>For the shift operations, the general pattern is as follows <code>&lt;shifted&gt; &lt;shift-op&gt; &lt;additive&gt;</code>. This means the value that is being shifted is always on the left-hand-side and is always shifted by the number indicated on the right-hand-side. For left-shifts, the bit pattern is moved <code>N</code> spot to the left, pushing zeros at the end of the right side and popping any bit off the left end. For right shifts, the opposite occurs. The bit pattern is move right by <code>N</code> spots, popping any bit off the right end and push the same bit as the sign bit of the number being shifted (1's if negative and 0's if positive).</p>
<h2 id="arithmetic-assignment"><a class="header" href="#arithmetic-assignment">Arithmetic Assignment</a></h2>
<p>There is one final set of arithmetic operators in C++. These are the arithmetic assignment operators. These will perform the operation between two points and assign the result to the left point.</p>
<ul>
<li><code>+=</code> - Add assign - <code>a = a + b == a += b</code></li>
<li><code>-=</code> - Subtract assign - <code>a = a - b == a -= b</code></li>
<li><code>*=</code> - Multiply assign - <code>a = a * b == a *= b</code></li>
<li><code>/=</code> - Divide assign - <code>a = a / b == a /= b</code></li>
<li><code>%=</code> - Modulo assign - <code>a = a % b == a %= b</code></li>
<li><code>&amp;=</code> - And assign - <code>a = a &amp; b == a &amp;= b</code></li>
<li><code>|=</code> - Or assign - <code>a = a | b == a |= b</code></li>
<li><code>^=</code> - Xor assign - <code>a = a ^ b == a ^= b</code></li>
<li><code>&lt;&lt;=</code> - Left-shift assign - <code>a = a &lt;&lt; b == a &lt;&lt;= b</code></li>
<li><code>&gt;&gt;=</code> - Right-shift assign - <code>a = a &gt;&gt; b == a &gt;&gt;= b</code></li>
</ul>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto k{5};
    auto l{2};

    k += l;
    std::cout &lt;&lt; &quot;k += l -&gt; k = &quot; &lt;&lt; k &lt;&lt; std::endl;    ///&lt; k = 7

    k *= l;
    std::cout &lt;&lt; &quot;k *= l -&gt; k = &quot; &lt;&lt; k &lt;&lt; std::endl;    ///&lt; k = 14

    l |= k;
    std::cout &lt;&lt; &quot;l |= k -&gt; l = &quot; &lt;&lt; l &lt;&lt; std::endl;    ///&lt; l = 14

    k &lt;&lt;= l;
    std::cout &lt;&lt; &quot;k &lt;&lt;= l -&gt; k = &quot; &lt;&lt; k &lt;&lt; std::endl;   ///&lt; k = 229376

    l ^= k;
    std::cout &lt;&lt; &quot;l ^= k -&gt; l = &quot; &lt;&lt; l &lt;&lt; std::endl;    ///&lt; l = 229390

    k &amp;= l;
    std::cout &lt;&lt; &quot;k &amp;= l -&gt; k = &quot; &lt;&lt; k &lt;&lt; std::endl;    ///&lt; k = 229376

    l -= k;
    std::cout &lt;&lt; &quot;l -= k -&gt; l = &quot; &lt;&lt; l &lt;&lt; std::endl;    ///&lt; l = 14

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/33hP5o4v7">Example</a></p>
<p>Have a play with these operators and try and perform some computations that you might do in another languages.</p>
<h2 id="size-operator"><a class="header" href="#size-operator">Size Operator</a></h2>
<p>Another useful operator is the <code>sizeof</code> and <code>sizeof...</code> operator. It returns the number of bytes if a type parameter pack (more on parameter packs later).</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a {10};
    auto b {3.5};
    auto c {'c'};

    std::cout &lt;&lt; &quot;sizeof (a) = &quot; &lt;&lt; sizeof (a) &lt;&lt; std::endl;  ///&lt; sizeof (a) = 4
    std::cout &lt;&lt; &quot;sizeof (b) = &quot; &lt;&lt; sizeof (b) &lt;&lt; std::endl;  ///&lt; sizeof (b) = 8
    std::cout &lt;&lt; &quot;sizeof (c) = &quot; &lt;&lt; sizeof (c) &lt;&lt; std::endl;  ///&lt; sizeof (c) = 1

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/8E4vTdPbc">Example</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io"><a class="header" href="#io">IO</a></h1>
<p>IO means input and output. IO operations are used to consume or emit data at the boundary of a program. This allows for a program to interact with the outside would, including writing or reading from the console, displaying graphics, capturing images etc. In C++, almost all of the IO is performed through streams.</p>
<h2 id="what-is-a-stream"><a class="header" href="#what-is-a-stream">What is a stream?</a></h2>
<p>What is a stream. A stream is a sequence of an indeterminate amount of data connecting a source to a destination. In C++, streams are used to connect a perform a variety of IO operations. You have already used on of these streams in C++, this is of course <code>std::cout</code>.</p>
<h2 id="c-standard-streams"><a class="header" href="#c-standard-streams">C Standard Streams</a></h2>
<p>In C++ there are a few pre-defined stream objects. This are mounted to the the C languages <code>stdout</code>, <code>stdin</code> and <code>stderr</code>. These output devices are how C (and these stream objects) connect to the terminal screen and keyboard of your device.</p>
<ul>
<li><code>std::cin</code> - Output stream to C's <code>stdin</code></li>
<li><code>std::cout</code> - Output stream to C's <code>stdout</code></li>
<li><code>std::cerr</code> - Output stream to C's <code>stderr</code> (dependent on <code>stdout</code>)</li>
<li><code>std::clog</code> - Output stream to C's <code>stderr</code> (not dependent on <code>stdout</code>)</li>
</ul>
<p>These are pre-existing objects of the type <code>std::istream</code> and <code>std::ostream</code> respectively. The use of streams allows for C++ developer to have a uniform way of addressing different IO devices. In particular the <code>&lt;&lt;</code> operator is available to all streams types allowing for similar usage of streams that may be mounted to alternative IO devices, eg. files, graphics card, cameras etc.</p>
<p>All stream objects and types are found in the <code>&lt;iostream&gt;</code> header.</p>
<p><a href="https://en.cppreference.com/w/cpp/io">IO Library</a></p>
<h2 id="input"><a class="header" href="#input">Input</a></h2>
<p>We have seen how to print stuff to the console but how do we get input? There are two ways. One uses the stream directly with the <code>&gt;&gt;</code> operator while the other defers using a function call. We will only look at the direct usage for now.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a {0};
    auto b {0};

    std::cout &lt;&lt; &quot;Enter two numbers: &quot;;
    std::cin &gt;&gt; a &gt;&gt; b;

    std::cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;a + b = &quot; &lt;&lt; (a + b) &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/3zoz1517r">Example</a></p>
<h2 id="io-manipulators"><a class="header" href="#io-manipulators">IO Manipulators</a></h2>
<p>Because streams are used for IO operations in C++, they are naturally composable, allowing for the streams manipulation mid-stream. The C++ standard library has a variety of manipulators that allow you to change a streams format. Manipulators are found in the <code>&lt;iomanip&gt;</code> header.</p>
<pre><code class="language-cxx">#include &lt;iomanip&gt;
#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a {255};
    auto b {0.01};

    std::cout &lt;&lt; &quot;a: oct = &quot; &lt;&lt; std::oct &lt;&lt; a &lt;&lt; std::endl;  ///&lt; 377
    std::cout &lt;&lt; &quot;a: hex = &quot; &lt;&lt; std::hex &lt;&lt; a &lt;&lt; std::endl;  ///&lt; ff
    std::cout &lt;&lt; &quot;a: dec = &quot; &lt;&lt; std::dec &lt;&lt; a &lt;&lt; std::endl;  ///&lt; 255

    std::cout &lt;&lt; std::fixed &lt;&lt; b &lt;&lt; std::endl;          ///&lt; 0.010000
    std::cout &lt;&lt; std::scientific &lt;&lt; b &lt;&lt; std::endl;     ///&lt; 1.000000e-02
    std::cout &lt;&lt; std::hexfloat &lt;&lt; b &lt;&lt; std::endl;       ///&lt; 0x1.47ae147ae147bp-7
    std::cout &lt;&lt; std::defaultfloat &lt;&lt; b &lt;&lt; std::endl;   ///&lt; 0.01

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/s8rGc4heM">Example</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="equality-ordering-and-logical-operators"><a class="header" href="#equality-ordering-and-logical-operators">Equality, Ordering and Logical Operators</a></h1>
<p>The notion of equality and ordering is a common principle in Computer Science. It allows for data to be verified, organised and sorted. This fundamental principles underpin a lot of programming. C++ has many facilities not just for testing equality or ordering of types, value and other entities but also for customizing the behaviour.</p>
<h2 id="equality"><a class="header" href="#equality">Equality</a></h2>
<p>A common operation in all of programming is to test for equality. In C++ primitive types are compared as arithmetic types, that is the systems ALU (Arithmetic and Logic Unit) will compare the bits of a value and return to the system whether the result is <code>true</code> or <code>false</code>.</p>
<p>Unlike JavaScript, C++ has a sense of strictly equal, that is two values are either equal or are not. To compare for equality or inequality of two values, C++ has the <code>==</code> and <code>!=</code> operators respectively.</p>
<ul>
<li><code>a == b</code> - <code>true</code> if <code>a</code> equals <code>b</code> otherwise <code>false</code></li>
<li><code>a != b</code> - <code>false</code> if <code>a</code> equals <code>b</code> otherwise <code>true</code></li>
</ul>
<pre><code class="language-cxx">#include &lt;iomanip&gt;
#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a {1};
    auto b {2};

    std::cout &lt;&lt; std::boolalpha;
    std::cout &lt;&lt; &quot;a == b =&gt; &quot; &lt;&lt; (a == b) &lt;&lt; std::endl;  ///&lt; false
    std::cout &lt;&lt; &quot;a != b =&gt; &quot; &lt;&lt; (a != b) &lt;&lt; std::endl;  ///&lt; true

    std::cout &lt;&lt; &quot;a == a =&gt; &quot; &lt;&lt; (a == a) &lt;&lt; std::endl;  ///&lt; true
    std::cout &lt;&lt; &quot;a != a =&gt; &quot; &lt;&lt; (a != a) &lt;&lt; std::endl;  ///&lt; false
    std::cout &lt;&lt; std::noboolalpha;
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/EK14h6fhd">Example</a></p>
<h2 id="ordering"><a class="header" href="#ordering">Ordering</a></h2>
<p>Checking for equality is pretty straight forward. Some more interesting operations are the ordering operators. What is ordering? Ordering is a relationship of different values of the same type. Ordering is what gives numbers their sequence (<code>2 &lt; 3</code>). Ordering operators allow use to check if some ordering condition is met.</p>
<ul>
<li><code>&lt;</code>  - Less than</li>
<li><code>&gt;</code>  - Greater than</li>
<li><code>&lt;=</code> - Less than or Equal</li>
<li><code>&gt;=</code> - Greater than or Equal</li>
</ul>
<pre><code class="language-cxx">#include &lt;iomanip&gt;
#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a {1};
    auto b {2};

    std::cout &lt;&lt; std::boolalpha;
    std::cout &lt;&lt; &quot;a &lt; b =&gt; &quot; &lt;&lt; (a &lt; b) &lt;&lt; std::endl;       ///&lt; true
    std::cout &lt;&lt; &quot;a &gt; b =&gt; &quot; &lt;&lt; (a &gt; b) &lt;&lt; std::endl;       ///&lt; false

    std::cout &lt;&lt; &quot;a &lt;= a =&gt; &quot; &lt;&lt; (a &lt;= a) &lt;&lt; std::endl;     ///&lt; true
    std::cout &lt;&lt; &quot;a &gt;= a =&gt; &quot; &lt;&lt; (a &gt;= a) &lt;&lt; std::endl;     ///&lt; true

    std::cout &lt;&lt; &quot;a &lt;= b =&gt; &quot; &lt;&lt; (a &lt;= b) &lt;&lt; std::endl;     ///&lt; true
    std::cout &lt;&lt; &quot;a &gt;= b =&gt; &quot; &lt;&lt; (a &gt;= b) &lt;&lt; std::endl;     ///&lt; false
    std::cout &lt;&lt; std::noboolalpha;
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/v4EYf1n3j">Example</a></p>
<h2 id="spaceships-and-ordering-types"><a class="header" href="#spaceships-and-ordering-types">Spaceships and Ordering Types</a></h2>
<p>As of C++20 there as a new ordering operator introduced called the three-way-comparison operator or, the spaceship operator <code>&lt;=&gt;</code>. The spaceship operator different ordering types based on the strictness of the ordering.</p>
<ul>
<li><code>(a &lt;=&gt; b) &lt; 0</code> if <code>a &lt; b</code></li>
<li><code>(a &lt;=&gt; b) &gt; 0</code> if <code>a &gt; b</code></li>
<li><code>(a &lt;=&gt; b) == 0</code> if <code>a == b</code></li>
</ul>
<p><code>&lt;=&gt;</code> also returns an ordering category. This indicates the level of strictness for the ordered type.</p>
<table><thead><tr><th align="center">Category</th><th align="center">Equivalent values are..</th><th align="center">Incomparable values are..</th></tr></thead><tbody>
<tr><td align="center"><code>std::strong_ordering</code></td><td align="center">indistinguishable</td><td align="center">not allowed</td></tr>
<tr><td align="center"><code>std::weak_ordering</code></td><td align="center">distinguishable</td><td align="center">not allowed</td></tr>
<tr><td align="center"><code>std::partial_ordering</code></td><td align="center">distinguishable</td><td align="center">allowed</td></tr>
</tbody></table>
<ul>
<li>indistinguishable : if <code>a == b</code> then <code>f(a) == f(b)</code></li>
<li>distinguishable : if <code>a == b</code> then <code>f(a) != f(b)</code></li>
<li><code>std::partial_ordering</code> can return <code>std::partial_ordering::unordered</code> eg. <code>/* anything */ &lt;=&gt; NaN == std::partial_ordering::unordered</code>.</li>
</ul>
<blockquote>
<p>Note: floating point comparisons return <code>std::partial_ordering</code></p>
</blockquote>
<h3 id="strong-ordering"><a class="header" href="#strong-ordering">Strong Ordering</a></h3>
<p><code>std::strong_ordering</code> can have the values:</p>
<ul>
<li><code>std::strong_ordering::less</code></li>
<li><code>std::strong_ordering::equivalent</code></li>
<li><code>std::strong_ordering::equal</code></li>
<li><code>std::strong_ordering::greater</code></li>
</ul>
<p>and can be implicitly converted into <code>std::partial_ordering</code> or <code>std::weak_ordering</code>.</p>
<h3 id="weak-ordering"><a class="header" href="#weak-ordering">Weak Ordering</a></h3>
<p><code>std::weak_ordering</code> can have the values:</p>
<ul>
<li><code>std::weak_ordering::less</code></li>
<li><code>std::weak_ordering::equivalent</code></li>
<li><code>std::weak_ordering::greater</code></li>
</ul>
<p>and can be implicitly converted into <code>std::partial_ordering</code>.</p>
<h3 id="partial-ordering"><a class="header" href="#partial-ordering">Partial Ordering</a></h3>
<p><code>std::partial_ordering</code> can have the values:</p>
<ul>
<li><code>std::strong_ordering::less</code></li>
<li><code>std::strong_ordering::equivalent</code></li>
<li><code>std::strong_ordering::greater</code></li>
<li><code>std::strong_ordering::unordered</code></li>
</ul>
<pre><code class="language-cxx">#include &lt;compare&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a {1};
    auto b {2};

    auto aa = a &lt;=&gt; a;
    auto ab = a &lt;=&gt; b;

    std::cout &lt;&lt; std::boolalpha;
    std::cout &lt;&lt; &quot;((a &lt;=&gt; a) &lt; 0) =&gt; &quot; &lt;&lt; ((a &lt;=&gt; a) &lt; 0) &lt;&lt; std::endl;      ///&lt; false
    std::cout &lt;&lt; &quot;((a &lt;=&gt; a) == 0) =&gt; &quot; &lt;&lt; ((a &lt;=&gt; a) == 0) &lt;&lt; std::endl;    ///&lt; true
    std::cout &lt;&lt; &quot;((a &lt;=&gt; a) &gt; 0) =&gt; &quot; &lt;&lt; ((a &lt;=&gt; a) &gt; 0) &lt;&lt; std::endl;      ///&lt; false

    std::cout &lt;&lt; &quot;((a &lt;=&gt; b) &lt; 0) =&gt; &quot; &lt;&lt; ((a &lt;=&gt; b) &lt; 0) &lt;&lt; std::endl;      ///&lt; true
    std::cout &lt;&lt; &quot;((a &lt;=&gt; b) == 0) =&gt; &quot; &lt;&lt; ((a &lt;=&gt; b) == 0) &lt;&lt; std::endl;    ///&lt; false
    std::cout &lt;&lt; &quot;((a &lt;=&gt; b) &gt; 0) =&gt; &quot; &lt;&lt; ((a &lt;=&gt; b) &gt; 0) &lt;&lt; std::endl;      ///&lt; false

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/asKsxKc1W">Example</a></p>
<h2 id="logical-operators"><a class="header" href="#logical-operators">Logical Operators</a></h2>
<p>In programming, it is useful to be able to check a multitude of Boolean expression. This allows programs to have more complex conditional logic structures.</p>
<ul>
<li><code>!</code>  - Logical Not</li>
<li><code>&amp;&amp;</code> - Logical And</li>
<li><code>||</code> = Logical Or</li>
</ul>
<p>Logical And and Or have special short circuiting properties. This means that the outcome of a Boolean expressions can be evaluated early. For And, if one Boolean point is <code>false</code>, it doesn't matter what the second point evaluates to as the expression's condition has already failed, thus whole expression would <code>false</code>. Inversely for Or, if one Boolean point is <code>true</code> the whole expression is true</p>
<blockquote>
<p>Note: There is no logical Xor. This is because Xor cannot short circuited as the result depends on the result of both points. However, we have already seen the logical Xor, it is the <code>!=</code>. If the two points of <code>!=</code> are either both <code>true</code> or both <code>false</code>, the inequality condition is not met and thus achieving the exclusivity properties of Xor. In C++ because <code>bool</code> can be implicitly converted to other integral types, it is best that logicalXor is used as: <code>!(a) != !(b)</code>.</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;iomanip&gt;
#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a {1};
    auto b {2};
    auto c {3};

    std::cout &lt;&lt; std::boolalpha;

    /// if `a` is less than `b` and if `a` is less than `c`
    std::cout &lt;&lt; &quot;((a &lt; b) &amp;&amp; (a &lt; c)) =&gt; &quot; &lt;&lt; ((a &lt; b) &amp;&amp; (a &lt; c)) &lt;&lt; std::endl;       ///&lt; true

    /// if `c` is greater than `b` or if `a` is greater than `c`
    std::cout &lt;&lt; &quot;((c &gt; b) || (a &gt; c)) =&gt; &quot; &lt;&lt; ((c &gt; b) || (a &gt; c)) &lt;&lt; std::endl;       ///&lt; true

    /// if `a` is not greater than `b` or if `a` is equal to `c`
    std::cout &lt;&lt; &quot;(!(a &gt; b) || (a == c)) =&gt; &quot; &lt;&lt; (!(a &gt; b) || (a == c)) &lt;&lt; std::endl;   ///&lt; true
    /// if `a` is not greater than `b` is not equal to if `a` is not greater than `c`
    /// if `a` is not greater than `b` xor if `a` is not greater than `c`
    std::cout &lt;&lt; &quot;(!(a &gt; b) != !(a &lt; c)) =&gt; &quot; &lt;&lt; (!(a &gt; b) != !(a &gt; c)) &lt;&lt; std::endl;   ///&lt; false

    std::cout &lt;&lt; std::noboolalpha;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/xqx3o4hW6">Example</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditional-expressions"><a class="header" href="#conditional-expressions">Conditional Expressions</a></h1>
<p>Conditional expressions use the concepts of equality and ordering to allow programs to branch. This means that different parts of a program will execute depending on the current state of a program. This allows for programs to be more adaptive and flexible to create.</p>
<h2 id="scope"><a class="header" href="#scope">Scope</a></h2>
<p>One important concept in programming is the idea of scope. In C++, scope is very important as it can have an important impact on the design, performance in the safety of a program. Currently we have been running a program purely in the scope of the <code>main()</code> function. What denotes a scope in C++ is a pair of braces <code>{}</code>. Anything introduced within the braces is now in a new scope separate from the outside program. Objects from outside the new scope can be captured but anything created in a new scope is dropped at the end of the scope.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a {4};

    {
        auto b {6};
        std::cout &lt;&lt; a &lt;&lt; std::endl;
        std::cout &lt;&lt; b &lt;&lt; std::endl;
    }

    std::cout &lt;&lt; a &lt;&lt; std::endl;
    std::cout &lt;&lt; b &lt;&lt; std::endl;  ///&lt; Will fail here, comment out to run

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/57hne667f">Example</a></p>
<p>Scope blocks (or sometimes code blocks) allow us to encapsulate expressions.</p>
<h2 id="if-expressions"><a class="header" href="#if-expressions">if-expressions</a></h2>
<p>Control flow allows for programs to branch and follow non-linear execution patterns. In C++, this is done through structured conditional expressions. The primary one being an <code>if</code> expression. <code>if</code> expressions are followed by a code block surrounded in <code>{}</code>. If the condition is met, then the code block executes.</p>
<ul>
<li><code>if (/* Boolean condition */) { /* code */ }</code></li>
</ul>
<blockquote>
<p>Note: One-liner execution blocks don't have to be in <code>{}</code>.</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a {1};
    auto b {2};

    if (a &lt; b)
    {
        std::cout &lt;&lt; &quot;a is less then b&quot; &lt;&lt; std::endl;
    }

    if (a == b)
        std::cout &lt;&lt; &quot;a is equal to b&quot; &lt;&lt; std::endl;

    if (a &gt; b)
        std::cout &lt;&lt; &quot;a is greater then b&quot; &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/4dK3P17ax">Example</a></p>
<p>We can also use an <code>else</code> clause at the end. This indicates that if and <code>if</code> expression fails, the <code>else</code> clause will execute instead.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a {1};
    auto b {2};

    if (a == b)
        std::cout &lt;&lt; &quot;a is equal to b&quot; &lt;&lt; std::endl;
    else
        std::cout &lt;&lt; &quot;a is not equal to b&quot; &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/31TcjvYrP">Example</a></p>
<h2 id="else-expression"><a class="header" href="#else-expression">else-expression</a></h2>
<p>We can combine the <code>else</code> clause with an <code>if</code> expression to create and <code>else if</code> expression. This allows for you to create multiple branches in a single <code>if</code> statement.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a {1};
    auto b {2};

    if (a &lt; b)
        std::cout &lt;&lt; &quot;a is less then b&quot; &lt;&lt; std::endl;
    else if (a == b)
        std::cout &lt;&lt; &quot;a is equal to b&quot; &lt;&lt; std::endl;
    else if (a &gt; b)
        std::cout &lt;&lt; &quot;a is greater then b&quot; &lt;&lt; std::endl;
    else
        std::cout &lt;&lt; &quot;a is unordered to b&quot; &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/Md3Mfx3MK">Example</a></p>
<h2 id="ternary-operator"><a class="header" href="#ternary-operator">Ternary Operator</a></h2>
<p><code>if</code> statements are the first step to building much more complex programs however, they are quite bulky in syntax for short conditional expressions. Instead we can use the ternary operator <code>?:</code> to build short and concise conditional expressions. A ternary expression has the following syntax.</p>
<p><code>auto /* result */ = /* Boolean expression */ ? /* expression is true */ : /* expression is false */;</code></p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a {1};
    auto b {2};

    auto msg = a &lt; b ? &quot;a is less then b&quot; : &quot;b is less then a&quot;;

    std::cout &lt;&lt; msg &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/4n4xYh7T8">Example</a></p>
<h2 id="switch-statements"><a class="header" href="#switch-statements">Switch Statements</a></h2>
<p>Another useful construct in C++ is a <code>switch</code> statement. <code>switch</code> statements encapsulate the idea of a jump table however, it is limited to integral types, thus the <code>switch</code> condition must be an integral type and have integral case labels.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a {1};

    switch (a)
    {
        case 1:
            std::cout &lt;&lt; &quot;a + 1 = &quot; &lt;&lt; a + 1 &lt;&lt; std::endl;
            break;
        case 2:
            std::cout &lt;&lt; &quot;a * 2 = &quot; &lt;&lt; a * 2 &lt;&lt; std::endl;
            break;
        case 3:
            std::cout &lt;&lt; &quot;a - 3 = &quot; &lt;&lt; a - 3 &lt;&lt; std::endl;
            break;
        default:
            std::cout &lt;&lt; &quot;a / 5 = &quot; &lt;&lt; a / 5 &lt;&lt; std::endl;
            break;
    }

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/nz6TYWodK">Example</a></p>
<h3 id="fallthroughs"><a class="header" href="#fallthroughs">Fallthroughs</a></h3>
<p>You will note that at the end of each of the case blocks there are <code>break</code> statements. These are used to exit the switch statement entirely. If this weren't there, each case would run in sequence. This is called fallthrough. most compilers will warn you of this.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a {1};

    switch (a)
    {
        case 1:
            std::cout &lt;&lt; &quot;a + 1 = &quot; &lt;&lt; a + 1 &lt;&lt; std::endl;
        case 2:
            std::cout &lt;&lt; &quot;a * 2 = &quot; &lt;&lt; a * 2 &lt;&lt; std::endl;
        case 3:
            std::cout &lt;&lt; &quot;a - 3 = &quot; &lt;&lt; a - 3 &lt;&lt; std::endl;
        default:
            std::cout &lt;&lt; &quot;a / 5 = &quot; &lt;&lt; a / 5 &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/9oEfYrMMq">Example</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops"><a class="header" href="#loops">Loops</a></h1>
<p>Along with conditional expressions another powerful language facility is loops. Loops allow for programs to run in an iterative manner, that is a block will be executed in series. This is powerful feature that enables us to repeat a set of instructions effectively and efficiently.</p>
<h2 id="while-loop"><a class="header" href="#while-loop">While Loop</a></h2>
<p>A <code>while</code> loop is the most basic kind of loop. <code>while</code> loops will repeat its code block as long as its condition is met.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a {10};

    while (a &gt; 0)
    {
        std::cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; std::endl;
        --a;
    }

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/Pxa3G8T4o">Example</a></p>
<h2 id="do-while-loop"><a class="header" href="#do-while-loop">Do-While Loop</a></h2>
<p>There is another kind of <code>while</code> loop in C++ called a <code>do-while</code> loop. This works the exact same way a regular <code>while</code> loop works except that the condition is checked at the end of each loop rather than the start. This means that the code block will be executed at least once.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto a {0};

    do
    {
        std::cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; std::endl;
        --a;
    } while (a &gt; 0);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/od31P37d7">Example</a></p>
<blockquote>
<p>Note: You can break out of a <code>while</code> or <code>do-while</code> loop with <code>break</code> or a <code>return</code>-expression.</p>
</blockquote>
<h2 id="for-loop"><a class="header" href="#for-loop">For Loop</a></h2>
<p>Another common loop in C++ is the <code>for</code> loop. <code>for</code> loops will generate an initial value, validate it meets a condition and proceed through the sequences.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    for (auto i {0}; i &lt; 10; ++i)
        std::cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/KKTrYP5Pe">Example</a></p>
<p>As we can see, loops  through the power of conditional checking make programs much smaller and allow us to abstract repeated actions into a single statement.</p>
<h2 id="range-for"><a class="header" href="#range-for">Range For</a></h2>
<p>There is one other loop in C++. This is the <code>range-for</code>. This is a special <code>for</code> loop that is able to iterate through a sequence of values, yielding a single value from the sequence each loop. It automatically knows the size of the sequence and when to stop.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    std::cout &lt;&lt; &quot;[ &quot;;
    for (auto i : {1, 2, 3, 4, 5, 6, 7, 8, 9, 10})
        std::cout &lt;&lt; i &lt;&lt; &quot;, &quot;;

    std::cout &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;

    for (auto s : {&quot;It's over Anakin!&quot;, &quot;I have the high ground!&quot;})
        std::cout &lt;&lt; s &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/P78T9c1Ev">Example</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<h2 id="what-is-a-functions"><a class="header" href="#what-is-a-functions">What is a functions?</a></h2>
<p>A function is the most basic form of abstraction in programming. They allow software to be broken down into more simple pieces of code and compose and reuse them as we please.</p>
<p>Much like functions in mathematics, functions in C++ (an every programming language) take in some input parameters (aka arguments or points) and return a single output value. This creates a transformation or mapping between input values and types to output values and types.</p>
<h2 id="function-syntax"><a class="header" href="#function-syntax">Function Syntax</a></h2>
<p>Functions in C++ consist of a declaration and definition. A declaration is the functions signature which consists of the functions name, its points and its return type. The definition is a code block with at least on <code>return</code> expression.</p>
<pre><code class="language-cxx">T f(A1 a1, A2 a2)
{ 
    /* code */ 
    
    return ...;
}
</code></pre>
<ul>
<li><code>T</code> is the return type</li>
<li><code>A1</code> is the type of argument one stored in parameter <code>a1</code></li>
<li><code>A2</code> is the type of argument one stored in parameter <code>a2</code></li>
<li><code>return ...;</code> is the return expression</li>
</ul>
<p>Functions have to be invoked to be used. This involves using the invocation operator <code>()</code> on the functions name. You can pass literals and objects to functions. You can also initialise and assign variables from the return of a function.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

int add(int x, int y)
{ return x + y; }

auto main () -&gt; int
{
    auto a {4};
    auto b {7};
    auto c {-3};

    int d = add(5, 7);

    std::cout &lt;&lt; add(a, b) &lt;&lt; std::endl;
    std::cout &lt;&lt; add(a, c) &lt;&lt; std::endl;
    std::cout &lt;&lt; add(a, d) &lt;&lt; std::endl;
    std::cout &lt;&lt; add(b, c) &lt;&lt; std::endl;
    std::cout &lt;&lt; add(b, d) &lt;&lt; std::endl;
    std::cout &lt;&lt; add(c, d) &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/Gx4P9jTej">Example</a></p>
<p>Functions allow us to abstract any common pattern into reusable code.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

int sum(int s, int f)
{
    auto acc {0};
    for (auto i {s}; i &lt; f; ++i)
        acc += i;
    return acc;
}

auto main () -&gt; int
{

    std::cout &lt;&lt; sum(0, 5) &lt;&lt; std::endl;
    std::cout &lt;&lt; sum(-3, 8) &lt;&lt; std::endl;
    std::cout &lt;&lt; sum(-11, -5) &lt;&lt; std::endl;
    std::cout &lt;&lt; sum(4, 19) &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/radjo93bx">Example</a></p>
<h3 id="void-functions"><a class="header" href="#void-functions">Void Functions</a></h3>
<p>Functions can also return nothing. This is often the case when functions have side effects. Side effects are operations that occur outside the input and outputs domains of a function. Printing with <code>std::cout</code> (or rather the underlying function that `std::cout calls) is an example of a function with side effects. It takes the string literal as input and returns, nothing but the effect of the text printing still occurs.</p>
<p>In C++, the lack of a return type is denoted by the <code>void</code> literal.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

void println(auto s)
{ std::cout &lt;&lt; s &lt;&lt; std::endl; }

auto main () -&gt; int
{
    println(&quot;Hello World!&quot;);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/jeb77d165">Example</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slides-1"><a class="header" href="#slides-1">Slides</a></h1>
<p><img src="chapter2/./imgs/hpp_chapter2-01.png" alt="Slides 01" />
<img src="chapter2/./imgs/hpp_chapter2-02.png" alt="Slides 02" />
<img src="chapter2/./imgs/hpp_chapter2-03.png" alt="Slides 03" />
<img src="chapter2/./imgs/hpp_chapter2-04.png" alt="Slides 04" />
<img src="chapter2/./imgs/hpp_chapter2-05.png" alt="Slides 05" />
<img src="chapter2/./imgs/hpp_chapter2-06.png" alt="Slides 06" />
<img src="chapter2/./imgs/hpp_chapter2-07.png" alt="Slides 07" />
<img src="chapter2/./imgs/hpp_chapter2-08.png" alt="Slides 08" />
<img src="chapter2/./imgs/hpp_chapter2-09.png" alt="Slides 09" />
<img src="chapter2/./imgs/hpp_chapter2-10.png" alt="Slides 10" />
<img src="chapter2/./imgs/hpp_chapter2-11.png" alt="Slides 11" />
<img src="chapter2/./imgs/hpp_chapter2-12.png" alt="Slides 12" />
<img src="chapter2/./imgs/hpp_chapter2-13.png" alt="Slides 13" />
<img src="chapter2/./imgs/hpp_chapter2-14.png" alt="Slides 14" />
<img src="chapter2/./imgs/hpp_chapter2-15.png" alt="Slides 15" />
<img src="chapter2/./imgs/hpp_chapter2-16.png" alt="Slides 16" />
<img src="chapter2/./imgs/hpp_chapter2-17.png" alt="Slides 17" />
<img src="chapter2/./imgs/hpp_chapter2-18.png" alt="Slides 18" />
<img src="chapter2/./imgs/hpp_chapter2-19.png" alt="Slides 19" />
<img src="chapter2/./imgs/hpp_chapter2-20.png" alt="Slides 20" />
<img src="chapter2/./imgs/hpp_chapter2-21.png" alt="Slides 21" />
<img src="chapter2/./imgs/hpp_chapter2-22.png" alt="Slides 22" />
<img src="chapter2/./imgs/hpp_chapter2-23.png" alt="Slides 23" />
<img src="chapter2/./imgs/hpp_chapter2-24.png" alt="Slides 24" />
<img src="chapter2/./imgs/hpp_chapter2-25.png" alt="Slides 25" />
<img src="chapter2/./imgs/hpp_chapter2-26.png" alt="Slides 26" />
<img src="chapter2/./imgs/hpp_chapter2-27.png" alt="Slides 27" />
<img src="chapter2/./imgs/hpp_chapter2-28.png" alt="Slides 28" />
<img src="chapter2/./imgs/hpp_chapter2-29.png" alt="Slides 29" />
<img src="chapter2/./imgs/hpp_chapter2-30.png" alt="Slides 30" />
<img src="chapter2/./imgs/hpp_chapter2-31.png" alt="Slides 31" />
<img src="chapter2/./imgs/hpp_chapter2-32.png" alt="Slides 32" />
<img src="chapter2/./imgs/hpp_chapter2-33.png" alt="Slides 33" />
<img src="chapter2/./imgs/hpp_chapter2-34.png" alt="Slides 34" />
<img src="chapter2/./imgs/hpp_chapter2-35.png" alt="Slides 35" />
<img src="chapter2/./imgs/hpp_chapter2-36.png" alt="Slides 36" />
<img src="chapter2/./imgs/hpp_chapter2-37.png" alt="Slides 37" />
<img src="chapter2/./imgs/hpp_chapter2-38.png" alt="Slides 38" />
<img src="chapter2/./imgs/hpp_chapter2-39.png" alt="Slides 39" />
<img src="chapter2/./imgs/hpp_chapter2-40.png" alt="Slides 40" />
<img src="chapter2/./imgs/hpp_chapter2-41.png" alt="Slides 41" />
<img src="chapter2/./imgs/hpp_chapter2-42.png" alt="Slides 42" />
<img src="chapter2/./imgs/hpp_chapter2-43.png" alt="Slides 43" />
<img src="chapter2/./imgs/hpp_chapter2-44.png" alt="Slides 44" />
<img src="chapter2/./imgs/hpp_chapter2-45.png" alt="Slides 45" />
<img src="chapter2/./imgs/hpp_chapter2-46.png" alt="Slides 46" />
<img src="chapter2/./imgs/hpp_chapter2-47.png" alt="Slides 47" />
<img src="chapter2/./imgs/hpp_chapter2-48.png" alt="Slides 48" />
<img src="chapter2/./imgs/hpp_chapter2-49.png" alt="Slides 49" />
<img src="chapter2/./imgs/hpp_chapter2-50.png" alt="Slides 50" />
<img src="chapter2/./imgs/hpp_chapter2-51.png" alt="Slides 51" />
<img src="chapter2/./imgs/hpp_chapter2-52.png" alt="Slides 52" />
<img src="chapter2/./imgs/hpp_chapter2-53.png" alt="Slides 53" />
<img src="chapter2/./imgs/hpp_chapter2-54.png" alt="Slides 54" />
<img src="chapter2/./imgs/hpp_chapter2-55.png" alt="Slides 55" />
<img src="chapter2/./imgs/hpp_chapter2-56.png" alt="Slides 56" />
<img src="chapter2/./imgs/hpp_chapter2-57.png" alt="Slides 57" />
<img src="chapter2/./imgs/hpp_chapter2-58.png" alt="Slides 58" />
<img src="chapter2/./imgs/hpp_chapter2-59.png" alt="Slides 59" />
<img src="chapter2/./imgs/hpp_chapter2-60.png" alt="Slides 60" />
<img src="chapter2/./imgs/hpp_chapter2-61.png" alt="Slides 61" />
<img src="chapter2/./imgs/hpp_chapter2-62.png" alt="Slides 62" />
<img src="chapter2/./imgs/hpp_chapter2-63.png" alt="Slides 63" />
<img src="chapter2/./imgs/hpp_chapter2-64.png" alt="Slides 64" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3"><a class="header" href="#chapter-3">Chapter 3</a></h1>
<p>This week you will be introduced to C++'s memory model and how it allows us to have precise control over memory resources in C++. You will also cover the difference in stack and heap based memory and the facilities for obtaining memory. You will learn about pointers, references and how they allow you to reference data located elsewhere. You will also be introduced to C++'s slice type allowing to store multiple values in a single object. Finally, you get and introduction into a few fundamental types found in C++'s standard library that make working with memory and collections far easier.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pointers"><a class="header" href="#pointers">Pointers</a></h1>
<h2 id="what-is-a-pointer"><a class="header" href="#what-is-a-pointer">What is a pointer?</a></h2>
<p>Many people seem to struggle with the concept of a pointer. This is mostly due to either, bad teaching or that someone learning C++ (or C or Rust) do not have a concise understanding of memory. Memory can be thought of as a cell that has some value and lives at some address or location in the physical memory. Cells can be as small as a byte and as large a single machine register, typically 8-bytes.</p>
<blockquote>
<p>Note: Registers are the circuit components that hold some value in the CPU that is be operated on. It can be an instruction or some data.</p>
</blockquote>
<p>The following data can be mapped to a memory layout below it.</p>
<pre><code class="language-cxx">int a {4};
int b {37365};
</code></pre>
<table><thead><tr><th align="center">Address</th><th align="center">Value</th></tr></thead><tbody>
<tr><td align="center">0x00007fff59ae6e9d</td><td align="center">...</td></tr>
<tr><td align="center">0x00007fff59ae6e99</td><td align="center">0x00000004</td></tr>
<tr><td align="center">0x00007fff59ae6e94</td><td align="center">0x000091f5</td></tr>
<tr><td align="center">0x00007fff59ae6e90</td><td align="center">...</td></tr>
</tbody></table>
<blockquote>
<h3 id="notes"><a class="header" href="#notes">Notes:</a></h3>
<ul>
<li><code>...</code> means garbage values.</li>
<li><code>0x...</code> is just an indicator that the value is a hexadecimal value</li>
<li>We jump backwards because the stack (local memory of your program) starts from the largest address and goes down. This is because the code when stored in memory (as instructions) starts from the lowest value and increases. This prevents overwrites between instructions and data, if managed correctly.</li>
<li>The memory addresses here are just random, it differs on every computer and every run of the program, usually.</li>
</ul>
</blockquote>
<p>We can see that the value of <code>a</code> is stored at address <code>0x00007fff59ae6e99</code> and <code>b</code> is stored at address <code>0x00007fff59ae6e94</code>. The reason the memory address jumps by four is because each memory address stores a single byte, thus to store a 32-bit value (<code>int</code>) you need for bytes thus the next memory address will be four addresses away, in this case the value for <code>b</code>.</p>
<p>But lets say we wanted to refer to the value already stored in <code>a</code>. We don't want a copy but we wanted some way to <em>point</em> to the value at that address. Well we could store the address of <code>a</code> in another location in memory like so.</p>
<table><thead><tr><th align="center">Address</th><th align="center">Value</th></tr></thead><tbody>
<tr><td align="center">0x00007fff59ae6e9d</td><td align="center">...</td></tr>
<tr><td align="center">0x00007fff59ae6e99</td><td align="center">0x00000004</td></tr>
<tr><td align="center">0x00007fff59ae6e94</td><td align="center">0x000091f5</td></tr>
<tr><td align="center">0x00007fff59ae6e90</td><td align="center">0x00007fff59ae6e99</td></tr>
<tr><td align="center">0x00007fff59ae6e88</td><td align="center">...</td></tr>
</tbody></table>
<blockquote>
<p>Notes: We jump 8-bytes in the address space for the stored address as addresses (in the example at least) are 64-bit in size.</p>
</blockquote>
<p>As we can see, address <code>0x00007fff59ae6e90</code> stores the value <code>0x00007fff59ae6e94</code> which happens to be the number indicating the address where <code>a</code> is stored.</p>
<p>This is the premise of a pointer. It is a numerical value that holds some address in memory. This is address of another value in a program.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>To create a pointer in C++ is super simple. Given some type <code>T</code> the type of a pointer to a value of that type is <code>T*</code>.</p>
<p>We can store the address in an object like any other value in C++. To obtain the address of an object you can use the unary <code>&amp;</code> operator prefixed to an objects name or use the <code>std::addressof()</code> function found in the header <code>&lt;memory&gt;</code>. Using the function is highly recommended as it is more consistent with more complex types.</p>
<p>To obtain the value pointed to by a pointer, we use the unary indirection operator (often called the dereference operator) <code>*</code> prefixed to an object name.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;memory&gt;

auto main () -&gt; int
{
    int a {4};
    int b {37365};
    int* pa {&amp;a};
    int* pb {std::addressof(b)};

    std::cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;pa = &quot; &lt;&lt; pa &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;*pa = &quot; &lt;&lt; *pa &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;pb = &quot; &lt;&lt; pb &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;*pb = &quot; &lt;&lt; *pb &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/aaf33YEYW">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/memory/addressof"><code>std::addressof</code></a></p>
<h2 id="const-qualifications"><a class="header" href="#const-qualifications">const qualifications</a></h2>
<p>Because pointers are an independent type, they are able to have to have <code>const</code> (among other) qualifications however, the ordering of the qualifications can matter.</p>
<ul>
<li><code>const T*</code> - Pointer to constant data. The data cannot be changed but the pointer can point to a new location. (<code>T const*</code> is identical)</li>
<li><code>T* const</code> - Constant pointer to data. The data can be modified but the pointer can only point to the original value (address).</li>
</ul>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;memory&gt;

auto main () -&gt; int
{
    int a {4};
    int b {37365};
    const int* pa {&amp;a};
    int* const pb {std::addressof(b)};

    std::cout &lt;&lt; &quot;*pa = &quot; &lt;&lt; *pa &lt;&lt; std::endl;
    *pa += 3;  ///&lt; Fails, comment out to run
    pa = std::addressof(b);
    std::cout &lt;&lt; &quot;*pa = &quot; &lt;&lt; *pa &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;*pb = &quot; &lt;&lt; *pb &lt;&lt; std::endl;
    *pb += 3;
    pb = std::addressof(a);  ///&lt; Fails, comment out to run
    std::cout &lt;&lt; &quot;*pb = &quot; &lt;&lt; *pb &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/sed7Wcf7s">Example</a></p>
<h2 id="void-pointers"><a class="header" href="#void-pointers">void pointers</a></h2>
<p>Because of C++'s static type system, the type of a pointer must be declared however you can circumvent the type system using <code>void</code>. A pointer can be a <code>void*</code>, meaning that the type it points to is unbound. When you need to use the type you can then use <code>static_cast&lt;&gt;()</code> to create the type that you need. This is actually how C's <code>malloc()</code> function works. It returns a <code>void*</code> and it is up to the user to cast it to the desired type.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;memory&gt;

auto main () -&gt; int
{
    int a {4};
    void* pa {std::addressof(a)};

    std::cout &lt;&lt; &quot;*pa = &quot; &lt;&lt; *static_cast&lt;int*&gt;(pa) &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;*pa = &quot; &lt;&lt; *pa &lt;&lt; std::endl;  ///&lt; This will fail, comment out to run

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/n9Ynd7fYq">Example</a></p>
<p><a href="https://en.cppreference.com/w/c/memory/malloc">C's <code>malloc()</code></a></p>
<h2 id="pointer-arithmetic"><a class="header" href="#pointer-arithmetic">Pointer Arithmetic</a></h2>
<p>Because pointers are just numbers (addresses) we can add and subtract from then as if they were integral types. We can use the increment, decrement, addition, subtraction and subscript (index) operators on pointers (<code>+</code>, <code>-</code>, <code>++</code>, <code>--</code> and <code>[]</code> respectively).</p>
<p>This can used to create and access a sequence or memory. This is how a string literal (<code>&quot;&quot;</code>) works in C++, they are really sequence of <code>char</code> that exist in your program statically. C++ then decays them into the type <code>const char*</code> so functions can refer to them such as <code>std::cout &lt;&lt;</code>.</p>
<p>However, pointer arithmetic is very error prone. and leads to low readability and maintainability, but is useful to understand and for highly controlled manipulation of data.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    auto greeting {&quot;Hello!&quot;};
    const char* response {&quot;Hi!!!&quot;};

    for (auto i {0}; i &lt; 7; ++i)
        std::cout &lt;&lt; greeting[i];
    std::cout &lt;&lt; std::endl;

    for (auto i {0}; i &lt; 6; ++i)
        std::cout &lt;&lt; *(response + i);
    std::cout &lt;&lt; std::endl;

    /// These will have the same type
    std::cout &lt;&lt; &quot;typeid(greeting).name() = &quot; &lt;&lt; typeid(greeting).name() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;typeid(response).name() = &quot; &lt;&lt; typeid(response).name() &lt;&lt; std::endl;

    for (auto i {0}; i &lt; 6; ++i)
        std::cout &lt;&lt; *(response++) &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;response = &quot; &lt;&lt; response &lt;&lt; std::endl;  ///&lt; This now points to whatever is stored after `response`.

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/qdx6csE7x">Example</a></p>
<h2 id="dereferencing-nullptr"><a class="header" href="#dereferencing-nullptr">Dereferencing nullptr</a></h2>
<p>In C++, any assignment and initialisation is is copy by default even when passed to functions. This can be really costly for objects that have a large amount of data stored in them. Pointers make it cheap to pass the data around as you now just have to pass a pointer to it instead of all the data. However, there is a catch to pointers. Pointers can point to nothing, this nothing value is actually the literal <code>nullptr</code> we saw in week 0. And you cannot dereference a pointer to <code>nullptr</code> as <code>nullptr</code> is nothing. This can be really dangerous as this is considered UB which may work, may not compile, may crash the entire program or do something entirely unexpected.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    int* p {nullptr};

    std::cout &lt;&lt; &quot;p = &quot; &lt;&lt; p &lt;&lt; std::endl;      ///&lt; p = 0

    /// Compiles (on Godbolt) but throws a runtime error (see return of program is not zero)
    std::cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/594hMbcz6">Example</a></p>
<h2 id="pointers-to-pointers"><a class="header" href="#pointers-to-pointers">Pointers to Pointers</a></h2>
<p>It is also possible in C++ to have a pointer to a pointer. This mostly a feature inherited from C and remains in for C++ to interoperate with C and for completeness. Pointers to pointers may seem daunting but are straight forward if you apply the concept of a pointer again. The pointer-to-pointer object points to the address of the pointer object that holds the address of some other object. Pointer-to-pointers have the type <code>T**</code> and can be dereferenced to the their value, ie. the address the nested pointer points to or again to get the bottom value.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;memory&gt;

auto main () -&gt; int
{
    int a {6};
    int* p {std::addressof(a)};
    int** pp {std::addressof(p)};

    std::cout &lt;&lt; &quot;pp = &quot; &lt;&lt; pp &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;*pp = &quot; &lt;&lt; *pp &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;**pp = &quot; &lt;&lt; **pp &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/MPPczrWzd">Example</a></p>
<blockquote>
<p>Note: <code>auto</code> is able to deduce the type if the right-hand-side is a rvalue however, the <code>const</code> qualifications cannot be specified. ie. <code>T* -&gt; auto</code> and <code>T** -&gt; auto</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slices"><a class="header" href="#slices">Slices</a></h1>
<h2 id="what-is-a-slice"><a class="header" href="#what-is-a-slice">What is a slice?</a></h2>
<p>Working with single value objects and variables can be be tedious and doesn't allow for collecting common data efficiently into a single, easy to refer to object. This is were C++ slices come in. Slices are contiguous sequences of values. The length of a slice must be known at compile time and cannot change. Slices can hold any type including primitive types, user-defined types or even pointers.</p>
<p>We have already been using slices in C++ thus far. String literals are actually slices of <code>char</code>.</p>
<blockquote>
<p>Note: Technically slices are called 'built-in arrays' in C++ but I'm opting for an alternative naming convention to avoid confusion later and because 'built-in arrays' is annoying to say.</p>
</blockquote>
<h2 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h2>
<p>The syntax for a slice is strait forward and goes as follows: <code>T v[N] { ... };</code>, where</p>
<ul>
<li><code>T</code> is the type of the slices elements</li>
<li><code>v</code> is the variable name</li>
<li><code>N</code> is the size of the array (at compile time)</li>
<li><code>{ ... }</code> is the brace-list of literals that will be copied to the array. This list must be of the same size as <code>N</code></li>
</ul>
<blockquote>
<ul>
<li>Note: <code>N</code> can be elided if <code>{ ... }</code> is a fixed size.</li>
<li>Note: <code>{ ... }</code> is called an aggregate initialiser</li>
</ul>
</blockquote>
<h3 id="iteration"><a class="header" href="#iteration">Iteration</a></h3>
<p>To access the elements of a slice you use the subscript (index) operator <code>[i]</code> where <code>i</code> is an unsigned integral from <code>0..N-1</code>, where <code>[0]</code> gets the first element and <code>[1]</code> gets the second element etc.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

void print(int arr[], std::size_t s)
{
    std::cout &lt;&lt; &quot;[ &quot;;
    for (auto i {0}; i &lt; s; ++i)
        std::cout &lt;&lt; arr[i] &lt;&lt; &quot;, &quot;;
    std::cout &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
}

auto main () -&gt; int
{
    int nums[] { 1, 2, 3, 4, 5 };

    print(nums, 5);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/eGs9PTvfb">Example</a></p>
<h2 id="slices-vs-pointers"><a class="header" href="#slices-vs-pointers">Slices vs Pointers</a></h2>
<p>In C++, slices can; and often will, decay into a pointer. This is because, under the hood, slices are just pointers to a sequence of elements that are contiguous in memory. This makes it efficient to refer to arrays as you can pass around the pointer to its first element. Using the same example as above, if we change <code>print()</code> to take an integer pointer <code>int* arr</code> instead of <code>int arr[]</code> we get the exact some behavior. This is because C++ efficiently packs data together so the exist next to each other in memory.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

void print(int* arr, std::size_t s)
{
    std::cout &lt;&lt; &quot;[ &quot;;
    for (auto i {0}; i &lt; s; ++i)
        std::cout &lt;&lt; arr[i] &lt;&lt; &quot;, &quot;;
    std::cout &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
}

auto main () -&gt; int
{
    int nums[] { 1, 2, 3, 4, 5 };

    print(nums, 5);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/r7or3x7Tj">Example</a></p>
<h2 id="string-literals-and-character-slices"><a class="header" href="#string-literals-and-character-slices">String Literals and Character Slices</a></h2>
<p>In C++, the string literal is a <code>char[]</code> or can (usually) decay into a <code>const char*</code>. This make them efficient to create and refer to but can have some unfortunate caveats. The biggest issue is that slices are not very user friendly. This is mostly due to them being inherited from C which is; in contrast to C++, a much simpler language that could not afford; at the time of its creation, the more user friendly abstractions C++ has available to it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<h2 id="what-is-a-reference"><a class="header" href="#what-is-a-reference">What is a reference?</a></h2>
<p>So far we have learnt about pointers and how they are useful in distributing access to a memory resource that is expensive to copy as well as create contiguous sequences of values or slices. We have also seen how to get larger memory resources from the OS using <code>new</code> and <code>delete</code> expressions. However, we have also seen that pointers have caveats. They can lead to memory leaks and other various issues about ownership and lifetime of objects.</p>
<p>In C++ there is another facility that allows for you to refer to objects in different scopes that do not feature the same pitfalls of pointers. These are called references. References are; as the the name suggests a reference to an existing object or in other words an alias for an existing object. Operations done on a reference are truly done on the original object. This helps to avoid the cumbersome and error prone nature of pointers.</p>
<h2 id="pointers-vs-references"><a class="header" href="#pointers-vs-references">Pointers vs References</a></h2>
<table><thead><tr><th align="center">Pitfall</th><th align="center">Pointers</th><th align="center">References</th><th align="center">Meaning</th></tr></thead><tbody>
<tr><td align="center">Nullable</td><td align="center">✅</td><td align="center">❌</td><td align="center">Pointers can point to nothing, references cannot</td></tr>
<tr><td align="center">Dereferencable</td><td align="center">✅</td><td align="center">❌</td><td align="center">You cannot dereference a reference</td></tr>
<tr><td align="center">Rebindable</td><td align="center">✅</td><td align="center">❌</td><td align="center">A reference cannot be rebound to a new value. Operations done on the reference affect the underlying value, even assignment.</td></tr>
<tr><td align="center">Multiple levels of indirection</td><td align="center">✅</td><td align="center">❌</td><td align="center">You cannot have a reference of a reference.</td></tr>
<tr><td align="center">Pointer arithmetic</td><td align="center">✅</td><td align="center">❌</td><td align="center">You cannot increment (etc.) a reference like a pointer</td></tr>
</tbody></table>
<h2 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h2>
<p>References are declared as <code>T&amp;</code>. References must also have an initialiser.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    int i {7};
    int&amp; ir {i};

    std::cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;ir = &quot; &lt;&lt; ir &lt;&lt; std::endl;

    ir += 6;
    std::cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; std::endl;

    i -= 4;
    std::cout &lt;&lt; &quot;ir = &quot; &lt;&lt; ir &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/7TWjK5rKe">Example</a></p>
<h2 id="const-qualifications-1"><a class="header" href="#const-qualifications-1">const qualifications</a></h2>
<p>Because references cannot be rebound to reference a new object <code>const</code> qualifications are must simpler than pointers. References themselves are alway constant, that is always point to the same thing however, you can specify that the object itself is constant with <code>const T&amp;</code>. This means that the the object the reference refers to cannot be modified.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    int i {7};
    int&amp; ir {i};
    const int&amp; cir {i};

    std::cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;ir = &quot; &lt;&lt; ir &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;cir = &quot; &lt;&lt; cir &lt;&lt; std::endl;

    ir += 6;
    std::cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; std::endl;

    i -= 4;
    std::cout &lt;&lt; &quot;ir = &quot; &lt;&lt; ir &lt;&lt; std::endl;

    cir += 7;   ///&lt; Fails, `cir` is read-only
    std::cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/as3rTWavj">Example</a></p>
<blockquote>
<p>Note: You can substitute just the type <code>T</code> of a reference for <code>auto</code> ie. <code>T&amp; -&gt; auto&amp;</code> and <code>const T&amp; -&gt; const auto&amp;</code></p>
</blockquote>
<h2 id="move-semantics"><a class="header" href="#move-semantics">Move Semantics</a></h2>
<p>References are also used to denote move semantics in functions. So far we have only seen value, pointer and reference semantics. Move semantics allow for a function to take ownership of an objects resources. Move semantics are denoted using the <code>T&amp;&amp;</code> type signature, this is also called a rvalue. This allows us to rip out the guts of an object and use it how we please. To create a rvalue from an existing object we use the <code>std::move()</code> function from the <code>&lt;utility&gt;</code> header.</p>
<p>The difficulty of move semantics is it only applies to objects that can move ie. types with move constructors and move assignments. Without these constructors <code>T&amp;&amp;</code> just becomes a regular reference. This is the case for primitive types in C++. We will cover more on the specifics of moves in chapter 5.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-memory"><a class="header" href="#dynamic-memory">Dynamic Memory</a></h1>
<p>C++ gives us precise control of how memory is used. This allows programs to be highly optimised and control the amount of overhead a program has but means that memory must be managed by manually.</p>
<h2 id="stack-vs-heap"><a class="header" href="#stack-vs-heap">Stack vs Heap</a></h2>
<p>In almost all computers there are two kinds of memory resource pools. The first kind, which we have been using exclusively so far is called the stack. Stack memory is the local memory resources that the computers OS is willing give the program when it runs. However, the stack is limited in size and it is very easy to use up all of the stacks available memory very quickly.</p>
<p>This is where the second memory resource pool comes in called the heap or the free store. The heap is a much larger pool of memory programs can access and utilise but there is a catch to its use. You must go through the operating system each time you want memory from the heap. You are also responsible for returning ownership of that memory to the OS when you are done.</p>
<h2 id="new-and-delete"><a class="header" href="#new-and-delete"><code>new</code> and <code>delete</code></a></h2>
<p>So, how do we get memory from the heap. This is done with a <code>new</code> expression. <code>new</code> is a keyword that invokes the OS's memory resource allocator giving you access to memory from the OS. <code>new</code> returns a pointer of the allocated resources type. You can use this pointer however you need to like any other pointer but, after you have finished using the memory resource you must relinquish ownership of it using <code>delete</code> on the pointer holding the resource. Not doing so will cause a memory leak.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

auto main () -&gt; int
{
    int* ip = new int(7);   ///&lt; Creates an `int` initialised with the value `7` on the heap

    std::cout &lt;&lt; &quot;ip = &quot; &lt;&lt; ip &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;*ip = &quot; &lt;&lt; *ip &lt;&lt; std::endl;

    delete ip;
    ip = nullptr;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/v13hfhM54">Example</a></p>
<h2 id="dynamic-slices"><a class="header" href="#dynamic-slices">Dynamic Slices</a></h2>
<p>You can also allocate slices using <code>new[]</code> expressions and deallocate with <code>delete[]</code>.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

void print(int arr[], std::size_t s)
{
    std::cout &lt;&lt; &quot;[ &quot;;
    for (auto i {0}; i &lt; s; ++i)
        std::cout &lt;&lt; arr[i] &lt;&lt; &quot;, &quot;;
    std::cout &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
}

auto main () -&gt; int
{
    int* nums = new int[]{ 1, 2, 3, 4, 5 }; ///&lt; Creates a slice of `int` initialised with brace list

    print(nums, 5);

    delete[] nums;
    nums = nullptr;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/fx7136qnv">Example</a></p>
<h2 id="forewarning-on-dynamic-memory-management"><a class="header" href="#forewarning-on-dynamic-memory-management">Forewarning on Dynamic Memory Management</a></h2>
<p>Dynamic memory management is hard to get right and very easy to get wrong. Memory leaks occur and cause dramatic problems for critical systems and slow a program and even an entire computer to a grinding halt. Avoid using raw <code>new</code> and <code>delete</code> expressions in anything beyond trivial programs or unless you know what you are doing. In chapter 5 we will look at various principles that will assists in resource usage; including memory, to ensure C++ program are safe. That being said, have a toy with <code>new</code> and <code>delete</code> now to get an idea of how they work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-the-standard-library"><a class="header" href="#introduction-to-the-standard-library">Introduction to the Standard Library</a></h1>
<h2 id="what-is-the-standard-library"><a class="header" href="#what-is-the-standard-library">What is the Standard Library</a></h2>
<p>The Standard Library is the full set of features in C++ that are available outside the pure language. These include mathematical functions, IO facilities, containers, algorithms and much more. These are tools that abstract a lot of the useful mechanics of C++ into safe, efficient and fast facilities that are easier to use, more consistent and far superior in functionality. The C++ Standard Library is included using headers. These are the files we have been importing using the <code>#include</code> preprocessor directive.</p>
<p>This week you will learn about the most useful and bare-bones features in the Standard Library that will make working with C++ much easier, more idiomatic and faster.</p>
<h2 id="initializer-lists"><a class="header" href="#initializer-lists">Initializer Lists</a></h2>
<p>Throughout the last few weeks we have been using <em>brace-init-lists</em> to initialise objects. This is super useful for <em>slice-like</em> types to be initialised without using for loops. In C++ these brace-init-lists are converted to <code>std::initializer_list&lt;T&gt;</code> (where <code>T</code> is the element type). This is a useful construct for building user-defined containers that are initialised using a brace-init-list. There is not much use for you in <code>std::initializer_list</code> now but it is useful to know about later. One important thing to know about <code>std::initializer_list</code> is that is is a construction only type. That is it is only used to create object, you cannot return a <code>std::initializer_list</code> from a function.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/initializer_list"><code>std::initializer_list</code></a></p>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>Slices are useful for packing contiguous data into a single object but because of the implicit nature of decaying into pointers they can be error prone. This is where C++'s array type come in.</p>
<p><code>std::array</code> comes in. This is a complete array type that store both its data and size. Like slices, <code>std::array</code> must know its type and size at compile time and the type must be the same throughout the array. Because <code>std::array</code> is a complete object you can use reference semantics on it in an intuitive way. It is highly recommended to use <code>std::array</code> instead of slices everywhere you can.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;array&gt;

void print(std::array&lt;int, 6&gt; arr)
{
    std::cout &lt;&lt; &quot;[ &quot;;
    for (auto i {0}; i &lt; arr.size(); ++i)
        std::cout &lt;&lt; arr[i] &lt;&lt; &quot;, &quot;;
    std::cout &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
}

auto main () -&gt; int
{
    auto a = std::array&lt;int, 6&gt;{ 1, 2, 3, 4, 5, 6 };
    auto b = std::to_array&lt;int&gt;({ -1, -2, -3, -4, -5, -6});  ///&lt; Size can be deduced

    print(a);
    print(b);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/dbcKqx53f">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/array"><code>std::array</code></a></p>
<h2 id="member-access"><a class="header" href="#member-access">Member Access</a></h2>
<p>Because we are know looking at some custom types from C++'s standard library it is important to point out how to access member functions and variables of both objects and pointers. For an object <code>T t();</code> with a member variable you access it using the <code>.</code> operator like <code>t.foo</code>. If <code>t::foo</code> is a member function you postfix parentheses to call the function like <code>t.foo()</code>. If the object is a pointer say <code>T* tp = &amp;t</code> then the <code>-&gt;</code> operator is used instead of <code>.</code>.</p>
<h2 id="spans"><a class="header" href="#spans">Spans</a></h2>
<p>Another useful <em>slice-like</em> structure is a <code>std::span</code>. Remember the <code>print()</code> function (in slices section of this chapter) that took a slice and a size. This is common place in many old C and C++ libraries that used pointer for all buffers. <code>std::span</code> removes the need for pointers altogether. <code>std::span</code> is a non-owning view of any object that has some contiguous data and a size. This allows libraries to accept a multitude of different intpu types that resemble the shape and work seamlessly with them all.</p>
<pre><code class="language-cxx">#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;span&gt;

void print(std::span&lt;int&gt; span)
{
    std::cout &lt;&lt; &quot;[ &quot;;
    for (auto&amp; e : span)
        std::cout &lt;&lt; e &lt;&lt; &quot;, &quot;;
    std::cout &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
}

auto main () -&gt; int
{
    auto array = std::to_array&lt;int&gt;({ 1, 2, 3, 4, 5, 6 });
    int slice[] = {4, 46, 57};

    print(array);
    print(slice);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/4Yo93e7Tr">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/span"><code>std::span</code></a></p>
<h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<p>Now that we have a much more powerful array type at out disposal it might be tempting to use it as a character array for strings and while this is viable we often want to form a very different set of operations on strings compared to arrays. For this we have <code>std::string</code>. <code>std::string</code> is a specialised type that has a much larger interface of string operations.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;string&gt;

auto main () -&gt; int
{
    auto str1 {&quot;Hello&quot;};
    auto str2(&quot;Goodbye&quot;);
    
    std::cout &lt;&lt; str1 &lt;&lt; std::endl;
    std::cout &lt;&lt; str2 &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<blockquote>
<p>Note: There are also string type for all of C++'s character types eg. <code>wchar_t</code>.</p>
</blockquote>
<p><a href="https://www.godbolt.org/z/hqT44PM7M">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::string</code></a></p>
<h3 id="string-views"><a class="header" href="#string-views">String Views</a></h3>
<p>There are also span like views for strings. This is called <code>std::string_view</code>. Like span it doesn't own its string but can be used to access its value. This is designed to be a replacement for character slices.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;string_view&gt;

void print(std::string_view s)
{ std::cout &lt;&lt; s &lt;&lt; std::endl; }

auto main () -&gt; int
{
    print(&quot;Hello&quot;);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/cbb95YWWj">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/string/basic_string_view"><code>std::string_view</code></a></p>
<h3 id="literal-operators"><a class="header" href="#literal-operators">Literal Operators</a></h3>
<p>In C++ the is a cool operator called the literal operator <code>&quot;&quot;</code>. This is used to construct literals from string literals. The are string literal operators for <code>std::string</code> and <code>std::string_view</code> which are <code>&quot;&quot;s</code> and <code>&quot;&quot;sv</code> respectively.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;

using namespace std::literals;

void print(std::string_view s)
{ std::cout &lt;&lt; s &lt;&lt; std::endl; }

auto main () -&gt; int
{
    print(&quot;Hello&quot;sv);

    std::cout &lt;&lt; typeid(&quot;Hello&quot;).name() &lt;&lt; std::endl;
    std::cout &lt;&lt; typeid(&quot;Hello&quot;s).name() &lt;&lt; std::endl;
    std::cout &lt;&lt; typeid(&quot;Hello&quot;sv).name() &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/jcMfrG76c">Example</a></p>
<h2 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h2>
<p>The final facility we will look at is C++'s smart pointers. Smart pointers allow for automatic lifetime management of heap allocated memory resources. It is highly recommended to only use smart pointers for for any kind of head resource.</p>
<p>All smart pointers are in the <code>&lt;memory&gt;</code> header.</p>
<h3 id="unique-pointer"><a class="header" href="#unique-pointer">Unique Pointer</a></h3>
<p><code>std::unique_ptr</code> is a pointer to a uniquely owned resource. It cannot be copied, only moved. When a <code>std::unique_ptr</code> goes out of scope it automatically deletes the allocated resource. Because <code>std::unique_ptr</code> is a complete object you can pass a reference of a <code>std::unique_ptr</code> and modify the underlying value like a pointer. It also offers a safer <code>std::unique_ptr::get()</code> method that returns <code>nullptr</code> if the <code>std::unique_ptr</code> points to nothing.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;memory&gt;

void print(std::unique_ptr&lt;int&gt;&amp; ptr)
{ 
    std::cout &lt;&lt; ptr &lt;&lt; std::endl;
    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;
}

void add_magic(std::unique_ptr&lt;int&gt;&amp; ptr)
{ *ptr += 42; }

auto main () -&gt; int
{
    std::unique_ptr&lt;int&gt; p1(new int(6));
    auto p2 = std::make_unique&lt;int&gt;(7);
    auto p3 = std::unique_ptr&lt;int&gt;{nullptr};

    print(p1);
    print(p2);

    add_magic(p1);
    // add_magic(p3);  ///&lt; Would fail 

    print(p1);
    // print(p3);  ////&lt; Would fails

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/G1T1j84nE">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/memory/unique_ptr"><code>std::unique_ptr</code></a></p>
<h3 id="shared-pointer"><a class="header" href="#shared-pointer">Shared Pointer</a></h3>
<p>Sometimes it useful to have multiple pointers refer to the same dynamic memory resource. However, one issue of this is there is know way to know if the memory resource is still needed but another pointer meaning a memory resource can be released accidently leaving all other pointers to the now deleted resource a dangling pointer. This is where <code>std::shared_ptr</code> comes in handy. This pointer will maintain a count or how many pointers refer to it. Only when this count reaches zero, indicating no more pointers are using the resource will the resource get deleted. This gives the behavior of many garbage collected languages without the massive overhead of a global gabage collecting program.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;memory&gt;

void print(std::shared_ptr&lt;int&gt; ptr)
{ 
    std::cout &lt;&lt; &quot;ptr = &quot; &lt;&lt; ptr &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;*ptr = &quot; &lt;&lt; *ptr &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;ptr.use_count() = &quot; &lt;&lt; ptr.use_count() &lt;&lt; std::endl;
}

void add_magic(std::shared_ptr&lt;int&gt;&amp; ptr)
{ *ptr += 42; }

auto main () -&gt; int
{
    auto p = std::make_shared&lt;int&gt;(7);

    std::cout &lt;&lt; &quot;p.use_count() = &quot; &lt;&lt; p.use_count() &lt;&lt; std::endl;

    print(p);
    add_magic(p);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/39dPYooTW">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a></p>
<h3 id="weak-pointer"><a class="header" href="#weak-pointer">Weak Pointer</a></h3>
<p>Sometimes it is useful to observe an existing resource that is managed by <code>std::shared_ptr</code> and only assume temporary ownership if the object still exists. This is where <code>std::weak_ptr</code> is used. It is constructed from an existing <code>std::shared_ptr</code> and observes the memory resource and is able to be converted to a <code>std::shared_ptr</code> when it needs to access the resource. This is useful for breaking reference cycles of <code>std::shared_ptr</code>'s and extend the lifetime of a memory resource to the scope of a <code>std::weak_ptr</code>. It is also able to check if the resource has been deleted already.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;memory&gt;

void print(std::weak_ptr&lt;int&gt; ptr)
{ 
    std::cout &lt;&lt; &quot;ptr.use_count() = &quot; &lt;&lt; ptr.use_count() &lt;&lt; std::endl;

    if (auto sp = ptr.lock())
    {
        std::cout &lt;&lt; &quot;sp.use_count() = &quot; &lt;&lt; sp.use_count() &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;sp = &quot; &lt;&lt; sp &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;*sp = &quot; &lt;&lt; *sp &lt;&lt; std::endl;
    }
    else
        std::cout &lt;&lt; &quot;ptr is expired&quot; &lt;&lt; std::endl;
}

auto main () -&gt; int
{
    auto p = std::make_shared&lt;int&gt;(7);

    std::cout &lt;&lt; &quot;p.use_count() = &quot; &lt;&lt; p.use_count() &lt;&lt; std::endl;

    print(p);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/PaonscnEG">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/memory/weak_ptr"><code>std::weak_ptr</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slides-2"><a class="header" href="#slides-2">Slides</a></h1>
<p><img src="chapter3/./imgs/hpp_chapter3-01.png" alt="Slides 01" />
<img src="chapter3/./imgs/hpp_chapter3-02.png" alt="Slides 02" />
<img src="chapter3/./imgs/hpp_chapter3-03.png" alt="Slides 03" />
<img src="chapter3/./imgs/hpp_chapter3-04.png" alt="Slides 04" />
<img src="chapter3/./imgs/hpp_chapter3-05.png" alt="Slides 05" />
<img src="chapter3/./imgs/hpp_chapter3-06.png" alt="Slides 06" />
<img src="chapter3/./imgs/hpp_chapter3-07.png" alt="Slides 07" />
<img src="chapter3/./imgs/hpp_chapter3-08.png" alt="Slides 08" />
<img src="chapter3/./imgs/hpp_chapter3-09.png" alt="Slides 09" />
<img src="chapter3/./imgs/hpp_chapter3-10.png" alt="Slides 10" />
<img src="chapter3/./imgs/hpp_chapter3-11.png" alt="Slides 11" />
<img src="chapter3/./imgs/hpp_chapter3-12.png" alt="Slides 12" />
<img src="chapter3/./imgs/hpp_chapter3-13.png" alt="Slides 13" />
<img src="chapter3/./imgs/hpp_chapter3-14.png" alt="Slides 14" />
<img src="chapter3/./imgs/hpp_chapter3-15.png" alt="Slides 15" />
<img src="chapter3/./imgs/hpp_chapter3-16.png" alt="Slides 16" />
<img src="chapter3/./imgs/hpp_chapter3-17.png" alt="Slides 17" />
<img src="chapter3/./imgs/hpp_chapter3-18.png" alt="Slides 18" />
<img src="chapter3/./imgs/hpp_chapter3-19.png" alt="Slides 19" />
<img src="chapter3/./imgs/hpp_chapter3-20.png" alt="Slides 20" />
<img src="chapter3/./imgs/hpp_chapter3-21.png" alt="Slides 21" />
<img src="chapter3/./imgs/hpp_chapter3-22.png" alt="Slides 22" />
<img src="chapter3/./imgs/hpp_chapter3-23.png" alt="Slides 23" />
<img src="chapter3/./imgs/hpp_chapter3-24.png" alt="Slides 24" />
<img src="chapter3/./imgs/hpp_chapter3-25.png" alt="Slides 25" />
<img src="chapter3/./imgs/hpp_chapter3-26.png" alt="Slides 26" />
<img src="chapter3/./imgs/hpp_chapter3-27.png" alt="Slides 27" />
<img src="chapter3/./imgs/hpp_chapter3-28.png" alt="Slides 28" />
<img src="chapter3/./imgs/hpp_chapter3-29.png" alt="Slides 29" />
<img src="chapter3/./imgs/hpp_chapter3-30.png" alt="Slides 30" />
<img src="chapter3/./imgs/hpp_chapter3-31.png" alt="Slides 31" />
<img src="chapter3/./imgs/hpp_chapter3-32.png" alt="Slides 32" />
<img src="chapter3/./imgs/hpp_chapter3-33.png" alt="Slides 33" />
<img src="chapter3/./imgs/hpp_chapter3-34.png" alt="Slides 34" />
<img src="chapter3/./imgs/hpp_chapter3-35.png" alt="Slides 35" />
<img src="chapter3/./imgs/hpp_chapter3-36.png" alt="Slides 36" />
<img src="chapter3/./imgs/hpp_chapter3-37.png" alt="Slides 37" />
<img src="chapter3/./imgs/hpp_chapter3-38.png" alt="Slides 38" />
<img src="chapter3/./imgs/hpp_chapter3-39.png" alt="Slides 39" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intermediate-c-features"><a class="header" href="#intermediate-c-features">Intermediate C++ Features</a></h1>
<p>Throughout this chapter you will delve deeper into the practical abilities of C++ from advanced function usage and functional programming idioms to logical code separation and modularization. You will also be introduced to a features that allow for the creation of custom types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-functions"><a class="header" href="#advanced-functions">Advanced Functions</a></h1>
<p>We saw in chapter 2 how to create functions to abstract usable pieces of code into smaller and more modular components. This is the bare-bones of functions of C++. Functions come in a lot of forms in C++ and have to make different guarantees about how they operate. This is done with various specifiers and labels that indicate to the compiler what a function is expected to do. Some of these we have seen including parameter and return value types along with these types various there CV-qualifications however, there are a few that have not been covered yet. Throughout this page we will build up a function signature from the blueprint below by adding new specifiers to showcase the syntax.</p>
<pre><code class="language-cxx">int f(int n)
{ return n; }
</code></pre>
<h2 id="no-exception-optimization"><a class="header" href="#no-exception-optimization">No exception optimization</a></h2>
<p>WE won't be covering exceptions in this course as they are quite an advanced topic that is hard to use and costly to get wrong. We may cover exceptions at a later date. In C++ some functions may throw exceptions when ill-formed behavior occurs and but it can be handled so the system can remain operational. However, some functions we can make guarantees at compile time that they will not throw an exception. This allows the compiler to optimise the execution path knowing that it will not need to recover the stack. To do this, we mark a function <code>noexcept</code> keyword. If a <code>noexcept</code> functions does throw, the program calls <code>std::terminate</code>.</p>
<pre><code class="language-cxx">int f(int n) noexcept
{ return n; }
</code></pre>
<p><a href="https://en.cppreference.com/w/cpp/language/noexcept_spec"><code>noexcept</code></a></p>
<h2 id="attributes"><a class="header" href="#attributes">Attributes</a></h2>
<p>Attributes are a declarator that indicates a condition of a function. Attributes are prefixed before the return type of the function using the double square-bracket notation <code>[[attribute-name]]</code>. C++ only has a few standard attributes so far but compilers often introduce their own for optimisation of the compiler.</p>
<ul>
<li><code>[[noreturn]]</code> - Indicates a function doesn't return</li>
<li><code>[[maybe_unused]]</code> - Indicates an entity maybe unused and suppresses relevant compiler warnings.</li>
<li><code>[[deprecated]]</code> &amp; <code>[[deprecated(&quot;reason&quot;)]]</code> - Indicated that the use of the marked entity is allowed but discouraged.</li>
<li><code>[[nodiscard]]</code> &amp; <code>[[nodiscard(&quot;reason&quot;)]]</code> - Indicated that the return value of a function should not be discarded and generates a compiler warning if it is.</li>
</ul>
<pre><code class="language-cxx">[[nodiscard]]
int f(int n) noexcept
{ return n; }
</code></pre>
<p><a href="https://en.cppreference.com/w/cpp/language/attributes"><strong><em>attributes</em></strong></a></p>
<h2 id="auto-function"><a class="header" href="#auto-function">Auto Function</a></h2>
<p>Sometimes the return value of a function is a complicated type or depends on the type of the parameters of the function. This can be solved using an <code>auto</code> declared function with a trailing-return-type.</p>
<pre><code class="language-cxx">[[nodiscard]]
auto f(int n) noexcept
    -&gt; int
{ return n; }
</code></pre>
<p><a href="https://en.cppreference.com/w/cpp/language/function"><strong><em>Function Declarations</em></strong></a></p>
<blockquote>
<p>Note: The styling used above is my own personal syntax styling. You are free to use your own.</p>
</blockquote>
<h2 id="function-overloading"><a class="header" href="#function-overloading">Function Overloading</a></h2>
<p>One difficulty in many programing languages is that you cannot have function symbols with the same name. This creates clashes and ambiguity meaning the compiler doesn't know which function to use. In C++ however, you can have functions with the same symbol (name) as long as there parameters are different. This is called function overloading. This is is achieved due to what is called name mangling. Function names are not simply just the name, say <code>f</code> from above but are mangled to include the type of the parameters the function takes. Thus <code>int f(int n)</code> is a different function to <code>float f(float n)</code>. This powerful feature allows us to create multiple functions that perform the same action but for multiple different types and move type resolution to compile time.</p>
<h3 id="operator-overloading"><a class="header" href="#operator-overloading">Operator Overloading</a></h3>
<p>Function overloading opens the opportunity to create user defined operators. This means you can overload the <code>+</code> or <code>&lt;&lt;</code> operators to work for custom types or introduce new functionality. This is how the <code>&lt;&lt;</code> and <code>&gt;&gt;</code> works for stream in C++. The <code>&lt;&lt;</code> and <code>&gt;&gt;</code> are overloaded to work differently for stream objects.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std::literals;

/// Comment out to see old behaviour
auto operator+ (std::string x, std::string y) -&gt; int
{ return std::stoi(x) + std::stoi(y); }

auto main() -&gt; int
{
    std::cout &lt;&lt; &quot;6&quot;s + &quot;5&quot;s &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/jaevh6dna">Example</a></p>
<h2 id="function-utilities"><a class="header" href="#function-utilities">Function Utilities</a></h2>
<h3 id="perfect-forwarding"><a class="header" href="#perfect-forwarding">Perfect Forwarding</a></h3>
<p>Often in C++ we want to pass arguments from one function to another without modification. An example of this is passing arguments to a wrapper function that might call some old legacy API. However, there can be issues with value categories, const-ness and reference values of parameters that create undefined behaviour, compiler errors etc. To fix this, C++ introduced perfect forwarding, a way to perfectly pass arguments from on function call to another without losing or changing the value category of the parameters. This is done with <code>std::forward&lt;T&gt;</code>. I am glossing over the details of this but if you are interested, this <a href="https://stackoverflow.com/a/3582313/13429386">SO answer</a> gives a great explanation of the problem, attempted solutions and the solution in C++ now.</p>
<p><a href="https://en.cppreference.com/w/cpp/utility/forward"><code>std::forward&lt;T&gt;</code></a></p>
<h3 id="value-and-type-helpers"><a class="header" href="#value-and-type-helpers">Value and Type Helpers</a></h3>
<p>Sometimes it is useful to work with the type of an object, not the value. To obtain the type of an object the <code>decltype</code> keyword. This declares the type of the entity or expression passed to the keyword in a function call style. This is useful for deducing the type of an expression once it has been evaluated.</p>
<pre><code class="language-cxx">#include &lt;type_traits&gt;

auto add(int x, float y) -&gt; decltype(x + y)
{ return x + y; }

auto main() -&gt; int
{
    static_assert(std::is_same_v&lt;decltype(add(9, 0.345)), float&gt;, &quot;Result is not a float&quot;);
    static_assert(std::is_same_v&lt;decltype(add(9, 0.345)), int&gt;, &quot;Result is not a int&quot;);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/6Gco6zsvs">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/header/type_traits"><code>&lt;type_traits&gt;</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/decltype"><code>decltype</code></a></li>
</ul>
<p>Sometimes though, it is impossible to find the return type of objects method calls as it requires constructing an actual value. To overcome this, C++ has a neat function called <code>std::declval</code>. This is able to construct an rvalue (temporary) in order to access object methods.</p>
<pre><code class="language-cxx">#include &lt;type_traits&gt;

auto main() -&gt; int
{
    static_assert(std::is_same_v&lt;decltype(std::declval&lt;int&gt;()), int&amp;&amp;&gt;, &quot;Result is rvalue&quot;);
    static_assert(std::is_same_v&lt;decltype(std::declval&lt;int&gt;()), int&gt;, &quot;Result is not rvalue&quot;);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/qbzqKcffa">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/utility/declval"><code>std::declval&lt;T&gt;</code></a></p>
<h2 id="functional-programming"><a class="header" href="#functional-programming">Functional Programming</a></h2>
<h3 id="function-types"><a class="header" href="#function-types">Function Types</a></h3>
<p>Functions; like variables, have a type. This makes it possible to use functions are variables that can be passed to other functions. But what is the type of a function? In general the type of a function is composed of its return type and the type of its arguments, ie. <code>R(P1, P2, P3, ...)</code>. In C functions are passed as function pointers. It is a powerful utility but can be error prone due to the nature of pointers. Instead, C++ has <code>std::function&lt;R(Args...)&gt;</code> which is able to bind to a function to a variable that can be easily passed around to other functions, copied and moved.</p>
<pre><code class="language-cxx">#include &lt;functional&gt;
#include &lt;iostream&gt;

auto print_num(double i)
    -&gt; void
{ std::cout &lt;&lt; i &lt;&lt; '\n'; }

auto add(int x, float y)
    -&gt; double
{ return x + y; }

auto mult_print(int x, float y, std::function&lt;void(double)&gt; f)
    -&gt; void
{ f(x * y); }

auto main() -&gt; int
{
    std::function&lt;void(double)&gt; print_f {print_num};
    std::function&lt;double(int, float)&gt; add_f {add};

    print_f(add_f(4, 6.6));
    mult_print(3, 0.056, print_f);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/TjrWfM5Th">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/utility/functional/function"><code>std::function&lt;R(Args...)&gt;</code></a></p>
<h3 id="lambdas-and-closures"><a class="header" href="#lambdas-and-closures">Lambdas and Closures</a></h3>
<p>Sometimes functions need to be able to enclose information about the global environment. This requires the use of closures, a local environment that can access the parent environment in which the closure exists in. In C++ this is accomplished with a lambda. Lambdas are anonymous functions that can capture local variables. Anonymous functions are able to be created and passed to other functions without having to exist as a stored function. Lambdas have a unique syntax consisting of three distinct sets of brackets. <code>[]</code> is used to specified the captured variables, <code>()</code> is the same as regular functions indicating the formal parameters of the lambda that are used when the lambda is invoked, and finally <code>{}</code> holds the body of the lambda.</p>
<p>The capture parameters can either capture by value or by reference. Value captures simply specify the variable names while reference captures prefix an <code>&amp;</code> to the variable name. You can also elide the names of captures and implicitly capture variables by using them in the body of the lambda and indicate whether all (or some) of the implicit captures are by value or reference using the symbols <code>=</code> or <code>&amp;</code> respectively.</p>
<pre><code class="language-cxx">#include &lt;functional&gt;
#include &lt;iostream&gt;

auto fmult(int x, float y, std::function&lt;void(double)&gt; f)
    -&gt; void
{ f(x * y); }

auto main() -&gt; int
{
    /// Use `std::function&lt;R(Args...)&gt;` for lambda type
    std::function&lt;double(int, float)&gt; add_f = [](int x, float y) -&gt; double { return x + y; };

    /// Lambda declared with `auto`
    auto print_f = [](double i){ std::cout &lt;&lt; i &lt;&lt; '\n'; };

    /// Lambda capture `print_f` by value
    auto print_mult = [=](int x, float y){ return fmult(x, y, print_f); };

    int a {7};
    int b {5};

    /// Capture `print_mult` and `a` by value and `b` by reference
    /// Elide names of `mult_print` and `a` with `=`
    auto print_7mult5 = [=, &amp;b](){ return print_mult(a, b); };

    /// Invoke lambdas like functions
    print_f(add_f(4, 6.6));
    fmult(7, 8.9, [](double i){ std::cout &lt;&lt; i &lt;&lt; '\n'; });     ///&lt; Use lambda as anonymous function,
    print_mult(7, 8.9);                                         ///&lt; or use captured version
    
    
    print_7mult5();     ///&lt; 35
    b = 9;              ///&lt; Modify `b`
    print_7mult5();     ///&lt; 63

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/he59bKxPf">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/lambda">Lambdas</a></p>
<h3 id="partial-application"><a class="header" href="#partial-application">Partial Application</a></h3>
<p>Another useful technique when working with functions is a technique known as partial application. This is similar to how closures with lambda work with a few key differences. Partial application allows you to partially apply the certain parameters of a function while leaving other empty to be passed at a later invocation. This is done with with the <code>std::bind</code> function which takes the function and a variable list of arguments that will be bound to the function in their respective order. The returned function can be invoked like any other function and will be invoked as if the bound variables were passed to it. The power of <code>std::bind</code> comes from its ability to accept placeholder values. These values follow the pattern of <code>_N</code> where N is any number starting at <code>1</code>. Placeholders are passed to <code>std::bind</code> can can be placed anywhere in the variable argument list. When the resulting function is invoked, any arguments passed to it will be passed to the underlying function. The first passed argument from the partially applied function will be passed to all instances of the <code>_1</code> placeholder and so on.</p>
<blockquote>
<p>Note: <code>std::bind</code> cannot bind (const) reference arguments functions take. For this, parameters must be wrapped in <code>std::ref</code> or <code>std::cref</code> to bind to references.</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;functional&gt;
#include &lt;iostream&gt;

auto fn(int n1, int n2, int n3, const int&amp; n4, int n5)
{ 
    std::cout &lt;&lt; n1 &lt;&lt; ' ' 
              &lt;&lt; n2 &lt;&lt; ' ' 
              &lt;&lt; n3 &lt;&lt; ' ' 
              &lt;&lt; n4 &lt;&lt; ' ' 
              &lt;&lt; n5 &lt;&lt; '\n';
}

/// Import placeholders
using namespace std::placeholders;

auto main() -&gt; int
{
    auto f1 = std::bind(fn, 1, _1, 4, _2, 6);
    auto f2 = std::bind(fn, _1, _1, _1, _1, _1);

    auto a {47676};
    auto f3 = std::bind(fn, _4, _3, _2, std::cref(a), _1);

    f3(4, 3, 2, 1);     ///&lt; 1 2 3 47676 4
    f1(4, a);           ///&lt; 1 4 4 47676 6
    a = 777; 
    f3(11, 10, 9, 8);   ///&lt; 8 9 10 777 11
    f1(3, a);           ///&lt; 1 3 4 777 6

    f2(6);              ///&lt; 6 6 6 6 6

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/79T3hYvea">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/utility/functional/bind"><code>std::bind</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/utility/functional/placeholders"><code>std::placeholders</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/utility/functional/ref"><code>std::ref</code> &amp; <code>std::cref</code></a></li>
</ul>
<p>There is also two new functions that have been added to the standard library. These are <code>std::bind_front</code> (C++20) and <code>std::bind_back</code> (C++23) that allow for efficiently binding parameters to the front or back of a function. These functions do not support the placeholder values like <code>std::bind</code>.</p>
<pre><code class="language-cxx">#include &lt;functional&gt;
#include &lt;iostream&gt;

auto fn(int n1, int n2, int n3, const int&amp; n4, int n5)
{ 
    std::cout &lt;&lt; n1 &lt;&lt; ' ' 
              &lt;&lt; n2 &lt;&lt; ' ' 
              &lt;&lt; n3 &lt;&lt; ' ' 
              &lt;&lt; n4 &lt;&lt; ' ' 
              &lt;&lt; n5 &lt;&lt; '\n';
}

auto main() -&gt; int
{
    auto f = std::bind_front(fn, 1, 2, 3);
    f(4, 5);  ///&lt; 1 2 3 4 5

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/vfxG95Eqr">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/utility/functional/bind_front"><code>std::bind_front</code> &amp; <code>std::bind_back</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h1>
<p>Namespaces create separation of symbols and names in C++. This allows for types, functions and variables to have the same name without causing collisions and ambiguity. We have already been using a namespace throughout this series, this being the <code>std</code> namespace. Namespaces a named scopes whose members can be accessed using the scope resolution operator <code>::</code>. To create a namespace you use the <code>namespace</code> keyword followed by the namespace name and a new scope. To use a namespace without having to go through scope resolution you can declare a namespaces use by <code>using namespace /* name */</code>.</p>
<blockquote>
<p>Note: Using <code>::</code> with no name looks in the global namespace eg. <code>::a</code>.</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;iostream&gt;

namespace A
{
    auto f(int n)
        -&gt; void
    { std::cout &lt;&lt; n &lt;&lt; '\n'; }
}

auto f(int n)
    -&gt; void
{ std::cout &lt;&lt; &quot;3 + n:(&quot; &lt;&lt; n &lt;&lt; &quot;) = &quot; &lt;&lt; 3 + n &lt;&lt; '\n'; }

auto main() -&gt; int
{
    // using namespace A;  ///&lt; Error: overload is ambiguous (redefinition)
    f(8);
    A::f(8);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/9oon3r944">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/namespace">Namespaces</a></p>
<h2 id="duplicate-namespaces"><a class="header" href="#duplicate-namespaces">Duplicate Namespaces</a></h2>
<p>Two namespaces with the same name will logically be merged, members and symbols from both can be looked up using the same namespace name given both headers containing the namespace symbols is available to be searched. This is how the <code>std</code> namespace can have all its components across different headers but be looked up using <code>std::</code>.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

namespace A
{
    auto f(int n)
        -&gt; void
    { std::cout &lt;&lt; n &lt;&lt; '\n'; }
}

namespace A
{
    auto g(int n)
        -&gt; void
    { std::cout &lt;&lt; &quot;3 + n:(&quot; &lt;&lt; n &lt;&lt; &quot;) = &quot; &lt;&lt; 3 + n &lt;&lt; '\n'; }
}

auto main() -&gt; int
{
    A::f(8);
    A::g(8);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/r9PPxbYh5">Example</a></p>
<h2 id="nested-namespaces"><a class="header" href="#nested-namespaces">Nested Namespaces</a></h2>
<p>Namespaces can also be declared to be nested. We saw this in the previous set of sections with the <code>std::placeholders</code> namespace. To access a nested namespace you use a double scope resolution operator <code>::</code>.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

namespace A
{
    auto f(int n)
        -&gt; void
    { std::cout &lt;&lt; n &lt;&lt; '\n'; }

    namespace B
    {
        auto f(int n)
            -&gt; void
        { std::cout &lt;&lt; &quot;3 + n:(&quot; &lt;&lt; n &lt;&lt; &quot;) = &quot; &lt;&lt; 3 + n &lt;&lt; '\n'; }
    }
}

auto main() -&gt; int
{
    A::f(8);
    A::B::f(8);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/afj6eEYe7">Example</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerations"><a class="header" href="#enumerations">Enumerations</a></h1>
<p>Enumerations (enums) are a distinct types whose value is one of a restricted range of named integral constants called enumerators. Enums allow for specify a type that may have a value of one of many possible named values. Enums have an underlying integral type where each enumerator is of the underlying type. Enums allow for the restriction of the possible values a type can hold. The value of the enumerators of an enum have begin at 0 and increment.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

enum Colour { Red, Green, Blue};

auto print_colour_name(Colour c)
    -&gt; void
{
    switch (c)
    {
        case Red:
            std::cout &lt;&lt; &quot;Red\n&quot;;
            break;
        case Green:
            std::cout &lt;&lt; &quot;Green\n&quot;;
            break;
        case Blue:
            std::cout &lt;&lt; &quot;Blue\n&quot;;
            break;
        default:
            std::cout &lt;&lt; &quot;Not a colour\n&quot;;
            break;
    }
}

auto main() -&gt; int
{
    Colour c1 {Red};            ///&lt; Unscoped Initialisation
    Colour c2 {Colour::Green};  ///&lt; Scoped Initialisation
    auto c3 {Colour::Blue};     ///&lt; `auto` type deduction
    auto c4 {4};                ///&lt; Non `Colour`

    print_colour_name(c1);
    print_colour_name(c2);
    print_colour_name(c3);
    print_colour_name(static_cast&lt;Colour&gt;(c4));

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/8PMbxxehb">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/enum">Enumerations</a></p>
<h2 id="underlying-types-and-values"><a class="header" href="#underlying-types-and-values">Underlying Types and Values</a></h2>
<p>In C++ you can specify the underlying type and and value of an enum. To specify the type, the enum's identifier can be followed by a colon with a integral type. To specify the values an enums enumerators are aliasing for, the enumerator name can be followed by a assignment operator and the integral value.</p>
<blockquote>
<h3 id="notes-1"><a class="header" href="#notes-1">Notes:</a></h3>
<ul>
<li>Not all enumerators have to have an explicit value if one or more other enumerators do.</li>
<li>If an enumerator has an explicit value and the proceeding one is not specified, the proceeding one will assume the next value after the explicit enumerator.</li>
<li>Enumerators can have the same underlying value.</li>
</ul>
</blockquote>
<pre><code class="language-cxx">#include &lt;iostream&gt;

/// Enum `Colour` whose underlying type is `short`
enum Colour : short
{ Red, Green = 57, Blue};

auto print_colour_name(Colour c)
    -&gt; void
{
    switch (c)
    {
        case Red:
            std::cout &lt;&lt; &quot;Red = &quot;;
            break;
        case Green:
            std::cout &lt;&lt; &quot;Green = &quot;;
            break;
        case Blue:
            std::cout &lt;&lt; &quot;Blue = &quot;;
            break;
        default:
            std::cout &lt;&lt; &quot;Not a colour\n&quot;;
            return;
    }

    std::cout &lt;&lt; static_cast&lt;short&gt;(c) &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    Colour c1 {Red};            ///&lt; Unscoped Initialisation
    Colour c2 {Colour::Green};  ///&lt; Scoped Initialisation
    auto c3 {Colour::Blue};     ///&lt; `auto` type deduction
    auto c4 {4};                ///&lt; Non `Colour`

    print_colour_name(c1);
    print_colour_name(c2);
    print_colour_name(c3);
    print_colour_name(static_cast&lt;Colour&gt;(c4));

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/c6E1vjzoK">Example</a></p>
<h2 id="enum-class"><a class="header" href="#enum-class">Enum Class</a></h2>
<p>Unscoped enums, which is all we have seen thus far can be implicitly converted into there underlying type. This can cause unwanted conversions. To accommodate for this C++ has <em>scoped enums</em> which are declared as <code>enum class</code> (or <code>struct</code>). They cannot be implicitly converted there underlying type, they have <code>int</code> as there underlying type by default and can only be accessed using the names scope resolution operator (<code>::</code>) with the name being the name of the enum class.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

/// Enum class `Colour` whose underlying type is `short`
enum class Colour : short
{ Red, Green = 57, Blue};

auto print_colour_name(Colour c)
    -&gt; void
{
    switch (c)
    {
        case Colour::Red:
            std::cout &lt;&lt; &quot;Red = &quot;;
            break;
        case Colour::Green:
            std::cout &lt;&lt; &quot;Green = &quot;;
            break;
        case Colour::Blue:
            std::cout &lt;&lt; &quot;Blue = &quot;;
            break;
        default:
            std::cout &lt;&lt; &quot;Not a colour\n&quot;;
            return;
    }

    std::cout &lt;&lt; static_cast&lt;short&gt;(c) &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    // Colour c1 {Red};         ///&lt; Unscoped Initialisation (error for `enum class`)
    Colour c2 {Colour::Green};  ///&lt; Scoped Initialisation
    auto c3 {Colour::Blue};     ///&lt; `auto` type deduction
    auto c4 {4};                ///&lt; Non `Colour`

    // print_colour_name(c1);
    print_colour_name(c2);
    print_colour_name(c3);
    print_colour_name(static_cast&lt;Colour&gt;(c4));

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/Kqs6rvvMr">Example</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unions"><a class="header" href="#unions">Unions</a></h1>
<p>Unions are a special kind of type known as an algebraic data type. This means the type of a union object can vary between a small list of possible types. This allows for a single type to be one of many possible types that can change throughout the lifetime of the program. The members of a union occupy the same memory space, thus the size of a union is the size of the largest possible member. Constructing a union object will always need to construct the first variant. Accessing the non-activate member is UB.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

union Sym
{
    int num;
    float float32;
    const char* str;
};

auto main() -&gt; int
{
    Sym sym {8};
    std::cout &lt;&lt; sym.num &lt;&lt; std::endl;

    sym.float32 = 5.6f;
    std::cout &lt;&lt; sym.float32 &lt;&lt; std::endl;

    sym.str = &quot;Hello&quot;;
    std::cout &lt;&lt; sym.str &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/zGeTs8ozn">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/union">Unions</a></p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>Unions are quite powerful but have a few limitations.</p>
<ul>
<li>There is no default mechanism for inspecting the current variant of a union.</li>
<li>They can have member functions including constructors and destructors but cannot have virtual functions (more on this in chapter 5).</li>
<li>They cannot have base classes nor can be used as a base class.</li>
<li>They cannot have non-static members of reference types.</li>
<li>If any variant types have a non-trivial special member function it is deleted for the union and must be declared explicitly for the union type.</li>
</ul>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;array&gt;
 
union S
{
    std::string str;
    std::array&lt;int, 5&gt; arr;
    ~S() {}                 ///&lt; Variant `str` has non-trivial destructor 
};
 
int main()
{
    S s = {&quot;Hello, world&quot;};

    std::cout &lt;&lt; &quot;s.str = &quot; &lt;&lt; s.str &lt;&lt; '\n';
    s.str.~basic_string();                      ///&lt; Explicity destroy string

    s.arr = std::array&lt;int, 5&gt;{1, 2, 3, 4, 5};  ///&lt; Explicity create array
    s.arr[1] = 5675;                            ///&lt; Assign 2nd element to 3

    for (auto&amp; v : s.arr)
        std::cout &lt;&lt; v &lt;&lt; ' ';
    std::cout &lt;&lt; std::endl;
    
}
</code></pre>
<p><a href="https://www.godbolt.org/z/rqPz5hK45">Example</a></p>
<h2 id="type-safe-algebraic-data-types"><a class="header" href="#type-safe-algebraic-data-types">Type Safe Algebraic Data Types</a></h2>
<p>While unions are powerful, they are very error prone and can lead to hard to diagnose bugs. Instead, in C++17 type-safe algebraic types that more intuitive to use and far safer.</p>
<h3 id="options"><a class="header" href="#options">Options</a></h3>
<p>One of the most common uses of algebraic data types is <code>std::optional</code> which can represent a type that may <em>optionally</em> contain some value or non at all. <code>std::optional</code> is often used as the return type if a function that might expectedly fail. <code>std::optional</code> can contain any type or has the type of <code>std::nullopt</code>.</p>
<pre><code class="language-cxx">#include &lt;cmath&gt;
#include &lt;limits&gt;
#include &lt;iostream&gt;
#include &lt;optional&gt;
#include &lt;string&gt;

auto divide(int x, int y)
    -&gt; std::optional&lt;float&gt;
{
    if (y == 0)
        return std::nullopt;
    
    return std::optional&lt;float&gt;{x / static_cast&lt;float&gt;(y)};
}

auto main() -&gt; int
{

    auto opt1 = divide(4, 5);
    std::cout &lt;&lt; opt1.value() &lt;&lt; std::endl;

    /// Given `opt2` and `opt3` have the value `std::nullopt`
    /// the value passed to `.value_or()` is returned
    auto opt2 = divide(2, 0);
    std::cout &lt;&lt; opt2.value_or(std::numeric_limits&lt;float&gt;::quiet_NaN()) &lt;&lt; std::endl;

    auto opt3 = divide(4656, 0);
    std::cout &lt;&lt; opt3.value_or(0.1f) &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/aGvnrYPzn">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional&lt;T&gt;</code></a></p>
<h3 id="variants"><a class="header" href="#variants">Variants</a></h3>
<p>The is also a more generic algebraic data type in C++ called <code>std::variant</code> which is implemented as a tagged union; that is, you are able to inspect which type is currently active, validate the state of the variant and perform a simply form of pattern matching. Empty variants can be simulated by using the <code>std::monospace</code> type variant.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;variant&gt;
#include &lt;vector&gt;

/// Used to perform pattern matching
template&lt;class... Ts&gt; struct match : Ts... { using Ts::operator()...; };

using Sym = std::variant&lt;int, float, std::string, long&gt;;

auto main() -&gt; int
{
    std::vector&lt;Sym&gt; syms = {8, &quot;Hello&quot;, 6.8f, 4, &quot;Bye&quot;, 857565L};
    for (auto&amp; var : syms)
    {
        std::visit(match{
            [](int i){ std::cout &lt;&lt; &quot;Sym: &lt;Integer&gt; = &quot; &lt;&lt; i &lt;&lt; std::endl; },
            [](float f){ std::cout &lt;&lt; &quot;Sym: &lt;Float&gt; = &quot; &lt;&lt; f &lt;&lt; std::endl; },
            [](std::string s){ std::cout &lt;&lt; &quot;Sym: &lt;String&gt; = &quot; &lt;&lt; s &lt;&lt; std::endl; },
            [](auto&amp;&amp; o){ std::cout &lt;&lt; &quot;Sym: &lt;Other&gt; = &quot; &lt;&lt; o &lt;&lt; std::endl; }
        }, var);
    }

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/fzMKbjWW3">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/utility/variant"><code>std::variant&lt;Ts..&gt;</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/utility/variant/visit"><code>std::visit()</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structures"><a class="header" href="#structures">Structures</a></h1>
<p>Structures (structs) are fundamental to developing with C++. They allow for creating custom types that can have member variables, and member functions (methods). They allow for packing any amalgamation of data into a single type. Structures are created using the <code>struct</code> keyword. To access the members and methods of a struct the member access operator <code>.</code> is used. For pointers to struct types, the pointer member access operator <code>-&gt;</code> is used.</p>
<blockquote>
<p>Note: The definition of a structure must have an <code>;</code> after the last brace.</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;memory&gt;

struct PairInt
{
    int first;
    int second;

    /// Adds members of two `PairInt`
    constexpr auto
    add(const PairInt&amp; o)
        const noexcept
        -&gt; PairInt
    { return PairInt{first + o.first, second + o.second}; }

    /// Overload `+~ cleaner `PairInt::add` call
    friend constexpr auto
    operator+ (const PairInt&amp; x, const PairInt&amp; y)
        noexcept
        -&gt; PairInt
    { return x.add(y); }

    /// Overload `&lt;&lt;` for printing
    friend auto
    operator&lt;&lt; (std::ostream&amp; os, const PairInt&amp; v)
        -&gt; std::ostream&amp;
    {
        os &lt;&lt; &quot;(.first: &quot; &lt;&lt; v.first &lt;&lt; &quot;, .second: &quot; &lt;&lt; v.second &lt;&lt; &quot;)&quot;;
        return os;
    }
};

auto main() -&gt; int
{
    auto a = PairInt{5, 7};
    auto b = PairInt{.first = 2, .second = 9};  ///&lt; Named aggregate initialisation
    auto p = std::addressof(b);                 ///&lt; Pointer to struct type

    std::cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; std::endl;      ///&lt; `PairInt` works with `std::cout`
    std::cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;a + b = &quot; &lt;&lt; a + b &lt;&lt; std::endl;      ///&lt; Call to overloaded `+`
    std::cout &lt;&lt; &quot;a + c = &quot; &lt;&lt; a + *p &lt;&lt; std::endl;     ///&lt; Pointer to structs works like regular pointers

    std::cout &lt;&lt; &quot;a.add(b) = &quot; &lt;&lt; a.add(b) &lt;&lt; std::endl;    ///&lt; Method access
    std::cout &lt;&lt; &quot;p-&gt;add(a) = &quot; &lt;&lt; p-&gt;add(a) &lt;&lt; std::endl;  ///&lt; Pointer member access 

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/6MbYMGGMz">Example</a></p>
<blockquote>
<p>Note: Ignore the <code>friend</code> keyword for now.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="task-1"><a class="header" href="#task-1">Task 1</a></h1>
<p>Having learnt a massive chunk of C++ now I want you to try and right some code for yourself. Your section is to create a triple struct, ie. like a 3D point but semantically more general. You must demonstrate and run all of the properties of the struct. The program should be called <code>triple.cxx</code> (or <code>triple.main.cxx</code> if using bpt)</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>Must have three members of the same type (either <code>int</code>, <code>float</code> or <code>double</code>)</li>
<li>A way to add two points</li>
<li>A way to subtract two points</li>
<li>A way to multiply a point by a scalar (of the same underlying type)</li>
<li>A way to divide a point by a scalar (of the same underlying type)</li>
<li>A way to be print a formatted output using <code>std::cout</code></li>
</ul>
<h3 id="bonus"><a class="header" href="#bonus">Bonus</a></h3>
<ul>
<li>A way to be created using input from <code>std::cin</code></li>
<li>Create a 'triple' structure for the other underlying types.</li>
</ul>
<h2 id="submitting"><a class="header" href="#submitting">Submitting</a></h2>
<p>You can use Godbolt or bpt to build and test your struct. Once you have created your implementation:</p>
<ul>
<li>Clone this repo using <code>git clone https://github.com/MonashDeepNeuron/HPP.git</code>.</li>
<li>Create a new branch using <code>git checkout -b triple/&lt;your-name&gt;</code>.</li>
<li>Create a folder in the <code>/submissions</code> directory with your name.</li>
<li>Create a folder with the name of this task.</li>
<li>Copy your mini project into this directory (bpt setup, cmake scripts etc.) with a <code>README.md</code> or comment in the code on how to run the program (verify it still works). There is a sample header file in <code>/templates</code> that you can use.</li>
<li>Go to <a href="https://github.com/MonashDeepNeuron/HPP/pulls">https://github.com/MonashDeepNeuron/HPP/pulls</a> and click 'New pull request'.</li>
<li>Change the branches in the drop down so that your branch is going into <code>main</code> and `Create new pull request.</li>
<li>Give the pull request a title and briefly describe what you were able to implement and any struggles you had.</li>
<li>On the right side-panel, under the 'Assignees' section, click the cog and assign me.</li>
<li>Click 'Create pull request' and I'll take it from there.</li>
</ul>
<blockquote>
<p>Note: If you created a GodBolt instance, put the link in a comment at the top of the file (under your copy comments). This is generated by clicking the <code>share</code> button in the top-right-most corner of the webpage and clicking the 'short link' option.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slides-3"><a class="header" href="#slides-3">Slides</a></h1>
<p><img src="chapter4/./imgs/hpp_chapter4-01.png" alt="Slides 01" />
<img src="chapter4/./imgs/hpp_chapter4-02.png" alt="Slides 02" />
<img src="chapter4/./imgs/hpp_chapter4-03.png" alt="Slides 03" />
<img src="chapter4/./imgs/hpp_chapter4-04.png" alt="Slides 04" />
<img src="chapter4/./imgs/hpp_chapter4-05.png" alt="Slides 05" />
<img src="chapter4/./imgs/hpp_chapter4-06.png" alt="Slides 06" />
<img src="chapter4/./imgs/hpp_chapter4-07.png" alt="Slides 07" />
<img src="chapter4/./imgs/hpp_chapter4-08.png" alt="Slides 08" />
<img src="chapter4/./imgs/hpp_chapter4-09.png" alt="Slides 09" />
<img src="chapter4/./imgs/hpp_chapter4-10.png" alt="Slides 10" />
<img src="chapter4/./imgs/hpp_chapter4-11.png" alt="Slides 11" />
<img src="chapter4/./imgs/hpp_chapter4-12.png" alt="Slides 12" />
<img src="chapter4/./imgs/hpp_chapter4-13.png" alt="Slides 13" />
<img src="chapter4/./imgs/hpp_chapter4-14.png" alt="Slides 14" />
<img src="chapter4/./imgs/hpp_chapter4-15.png" alt="Slides 15" />
<img src="chapter4/./imgs/hpp_chapter4-16.png" alt="Slides 16" />
<img src="chapter4/./imgs/hpp_chapter4-17.png" alt="Slides 17" />
<img src="chapter4/./imgs/hpp_chapter4-18.png" alt="Slides 18" />
<img src="chapter4/./imgs/hpp_chapter4-19.png" alt="Slides 19" />
<img src="chapter4/./imgs/hpp_chapter4-20.png" alt="Slides 20" />
<img src="chapter4/./imgs/hpp_chapter4-21.png" alt="Slides 21" />
<img src="chapter4/./imgs/hpp_chapter4-22.png" alt="Slides 22" />
<img src="chapter4/./imgs/hpp_chapter4-23.png" alt="Slides 23" />
<img src="chapter4/./imgs/hpp_chapter4-24.png" alt="Slides 24" />
<img src="chapter4/./imgs/hpp_chapter4-25.png" alt="Slides 25" />
<img src="chapter4/./imgs/hpp_chapter4-26.png" alt="Slides 26" />
<img src="chapter4/./imgs/hpp_chapter4-27.png" alt="Slides 27" />
<img src="chapter4/./imgs/hpp_chapter4-28.png" alt="Slides 28" />
<img src="chapter4/./imgs/hpp_chapter4-29.png" alt="Slides 29" />
<img src="chapter4/./imgs/hpp_chapter4-30.png" alt="Slides 30" />
<img src="chapter4/./imgs/hpp_chapter4-31.png" alt="Slides 31" />
<img src="chapter4/./imgs/hpp_chapter4-32.png" alt="Slides 32" />
<img src="chapter4/./imgs/hpp_chapter4-33.png" alt="Slides 33" />
<img src="chapter4/./imgs/hpp_chapter4-34.png" alt="Slides 34" />
<img src="chapter4/./imgs/hpp_chapter4-35.png" alt="Slides 35" />
<img src="chapter4/./imgs/hpp_chapter4-36.png" alt="Slides 36" />
<img src="chapter4/./imgs/hpp_chapter4-37.png" alt="Slides 37" />
<img src="chapter4/./imgs/hpp_chapter4-38.png" alt="Slides 38" />
<img src="chapter4/./imgs/hpp_chapter4-39.png" alt="Slides 39" />
<img src="chapter4/./imgs/hpp_chapter4-40.png" alt="Slides 40" />
<img src="chapter4/./imgs/hpp_chapter4-41.png" alt="Slides 41" />
<img src="chapter4/./imgs/hpp_chapter4-42.png" alt="Slides 42" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-programming"><a class="header" href="#generic-programming">Generic Programming</a></h1>
<p>Throughout this chapter you will discover C++ immensely customizable type system. How you can utilise structures and classes to create your own types from abstract base classes, data structures. You will also learn briefly about C++ Object Orientated facilities and how to utilise dynamic and static inheritance. You will also be introduced to generic programming through templates and metaprogramming. Finally you will learn about constraining your programs and enforcing requirements using C++ new concept faculties.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes"><a class="header" href="#classes">Classes</a></h1>
<h2 id="what-is-a-class"><a class="header" href="#what-is-a-class">What Is a Class?</a></h2>
<p>What is a class? Classes are the same as types. They allow for defining a set of valid operations on a particular configuration or amalgamation of data. In C++ there are two category of types, primitives and classes. Primitives are the basic types your were first introduced to in Chapter 2. Many other programming languages do not primitives because the language undergoes many more transformations before becoming machine code. As an example, <code>int</code> in Python is an object. It meets all the basic requirements of an object same as any other object in Python. This is not the case in C++. <code>int</code> in C++ is directly lowered (translated) into a assembly or machine type. You can a can access the bits that represent the <code>int</code>, even mutate them. They have a fixed width in memory (although varying from platform-to-platform) and cannot have their interfaces changes or adapted. Classes are different, they are much like object from Python (although, due to C++'s zero overhead principle, you only pay for what you ask for). Class are custom types that anyone can define and even modify through hierarchy structures and inheritance.</p>
<h2 id="defining-a-class"><a class="header" href="#defining-a-class">Defining a Class</a></h2>
<p>A class is defined identically to a structure. In fact, to C++ they are identical. You can use either keyword to create a class type. Typically however, <code>struct</code> is reserved for simple structures while <code>class</code> are use for more complex types by convention. There is one distinction between the two declarations, <code>class</code> will make all class members (methods and variables) private by default while <code>struct</code> will make them public by default.</p>
<blockquote>
<p>Note: From now on I'll refer to structures and classes as classes or types.</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;iostream&gt;

class Point
{
    int x;
    int y;
};

auto main() -&gt; int
{
    auto p = Point{ 2, 5 };

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;  ///&lt; Fails as `x` and `y` are private

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/MrorPKKxW">Example</a></p>
<h3 id="member-access-1"><a class="header" href="#member-access-1">Member Access</a></h3>
<p>Classes allow for you to specify the access rights of its members. There are three member access categories. Each allows for a different level of access permissions from both direct users of the class and the children (derived) of the class.</p>
<blockquote>
<p>Note: The term 'Member' means any method (function) or variable owned by a class, structure or type.</p>
</blockquote>
<h4 id="general-access"><a class="header" href="#general-access">General Access</a></h4>
<p>When defining a class, you can specify chapters of its definition to be either <code>private</code>, <code>protected</code> or <code>public</code>. This is done by putting an accessor label (with the keyword being one of the previously mentioned accessor categories with a <code>:</code> suffix) in a region of the classes body. All declared members following the label will adopt the accessor policy. You can reuse access specifiers as much as you want.</p>
<p>Here are the rules for the different accessor policies.</p>
<table><thead><tr><th align="center">Accessor Category</th><th align="center">Meaning</th></tr></thead><tbody>
<tr><td align="center"><code>private</code></td><td align="center">Member can only be used by member functions of the same class or friends (functions or classes).</td></tr>
<tr><td align="center"><code>protected</code></td><td align="center">Member can only be used by member functions of the same class, friends (functions or classes) or derived classes.</td></tr>
<tr><td align="center"><code>public</code></td><td align="center">Can be accessed by anyone.</td></tr>
</tbody></table>
<pre><code class="language-cxx">#include &lt;iostream&gt;

class Point
{
public:             ///&lt; Declare members `x` and `y` as public
    int x;
    int y;
};

auto main() -&gt; int
{
    Point p{ 2, 5 };  ///&lt; Now succeeds

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;  ///&lt; Now succeeds

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/1hWjrhee7">Example</a></p>
<h4 id="access-in-derived-classes"><a class="header" href="#access-in-derived-classes">Access in Derived Classes</a></h4>
<p>When deriving from another classes (more on inheritance <a href="chapter5/classes.html#task-16--dynamic-inheritance">here</a>), you can specify the access rights of the parent classes members through the base class.</p>
<table><thead><tr><th align="center">Base Classes Access Policy</th><th align="center"><code>private</code></th><th align="center"><code>protected</code></th><th><code>public</code></th></tr></thead><tbody>
<tr><td align="center"></td><td align="center">Always inaccessible with any derivation access</td><td align="center"><code>private</code> in derived class if you use <code>private</code> derivation</td><td><code>private</code> in derived class if you use <code>private</code> derivation</td></tr>
<tr><td align="center"></td><td align="center"></td><td align="center"><code>protected</code> in derived class if you use <code>protected</code> derivation</td><td><code>protected</code> in derived class if you use <code>protected</code> derivation</td></tr>
<tr><td align="center"></td><td align="center"></td><td align="center"><code>protected</code> in derived class if you use <code>public</code> derivation</td><td><code>public</code> in derived class if you use <code>public</code> derivation</td></tr>
</tbody></table>
<pre><code class="language-cxx">#include &lt;iostream&gt;

class Point
{
public:
    int x;
    int y;
};

class Point3D
    : protected Point       ///&lt; Points members are `protected`
{
public:
    int z;
};

auto main() -&gt; int
{
    Point p{ 2, 5 };
    Point3D p3d{};

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;p3d.z = &quot; &lt;&lt; p3d.z &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p3d.x &lt;&lt; &quot;, &quot; &lt;&lt; p3d.y &lt;&lt; &quot;, &quot; &lt;&lt; p3d.z &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;  ///&lt; Fails, `x` and `y` are inaccessible

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/Wr8av57cz">Example</a></p>
<blockquote>
<p>Note: Classes can access their own members regardless of the access policy even if it is a different instance.</p>
</blockquote>
<h2 id="constructors-and-destructors"><a class="header" href="#constructors-and-destructors">Constructors and Destructors</a></h2>
<p>So far we haven't seen much difference from classes than just using them as aggregate structures. One of the unique benefits of classes in C++ is the ability to explicitly define and control how structures are created and destroyed. This gives you powerful control over the lifetime of a type and how its resources are managed at the definition stage removing the need for manual management at runtime. This is done through constructors and destructors. These are special members (functions) with the same name as the class. A class can have any number of constructors (following the normal function overloading rules) but can only have one destructor.</p>
<blockquote>
<p>Note: Creation or construction of a type refers to the explicit instantiation of an object with a particular class type.</p>
</blockquote>
<h3 id="explicit-constructors"><a class="header" href="#explicit-constructors">Explicit Constructors</a></h3>
<p>The most useful kind of constructors for defining custom creation of a class are explicit constructors. These constructors take explicitly specified arguments, usually used to initialise member variables with a particular value. Explicit constructors are often marked with the <code>explicit</code> keyword in their function signature. Means the constructor must be explicitly called, ie. passed the correct types.</p>
<p>Throughout this chapter we are going to build up the <code>Point</code> class. Lets start by making it possible to define the point from two <code>int</code>. I've defined the explicit constructor for initialising the members <code>Point::x</code> and <code>Point::y</code> as well as temporary getters/setters.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

class Point
{
public:

    /// Explicit Constructor for initialising `x` and `y`
    explicit constexpr
    Point(int x, int y) noexcept
    : x{ x }, y{ y }
    { }

    constexpr auto
    X() noexcept -&gt; int&amp;
    { return x; }

    constexpr auto
    Y() noexcept -&gt; int&amp;
    { return y; }

private:
    int x;
    int y;

};  /// class Point

auto main() -&gt; int
{
    Point p{ 2, 5 };

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p.X() &lt;&lt; &quot;, &quot; &lt;&lt; p.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;


    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/748dx3vG1">Example</a></p>
<blockquote>
<p>Note: Even though it is taught often in; OOP centric or even OOP enabled languages, to define 'getters' and 'setters' for member variables. This is bad practice as it often leads to users of types and classes manually mutating the data themselves instead of defining access patterns and stateful transitions through methods or algorithms. If you must use 'getter' or 'setter' access patterns then you member variables should be publicly accessible.</p>
</blockquote>
<h4 id="member-initialisers-lists"><a class="header" href="#member-initialisers-lists">Member Initialisers Lists</a></h4>
<p>You may notice the comma separated 'list' under the constructors declaration. This is called an member initialiser list. It is used to initialise the members of a class from the arguments of the called constructor or from other members of the class. Member initialiser lists are specified between a constructors declaration and its body. Members are initialised in the following order regardless of the order specified by the member initialiser list.</p>
<ol>
<li>If the constructor is for the most-derived class, virtual bases are initialized in the order in which they appear in depth-first left-to-right traversal of the base class declarations (left-to-right refers to the appearance in base-specifier lists)</li>
<li>Then, direct bases are initialized in left-to-right order as they appear in this class's base-specifier list</li>
<li>Then, non-static data member are initialized in order of declaration in the class definition.</li>
<li>Finally, the body of the constructor is executed</li>
</ol>
<p><a href="https://en.cppreference.com/w/cpp/language/constructor">Constructors and member initializer lists</a></p>
<h3 id="default-constructor"><a class="header" href="#default-constructor">Default Constructor</a></h3>
<p>Sometimes, you don't know the state a type should by in when it is being initialised. In these cases it is useful to have a fallback state. To achieve this we use a default constructor. This will usually take no parameters.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

class Point
{
public:

    /// Default Constructor
    constexpr
    Point() noexcept
        : x{ 0 }, y{ 0 }
    { }

    /// Explicit Constructor for initialising `x` and `y`
    explicit constexpr
    Point(int x, int y) noexcept
        : x{ x }, y{ y }
    { }

    constexpr auto
    X() noexcept -&gt; int&amp;
    { return x; }

    constexpr auto
    Y() noexcept -&gt; int&amp;
    { return y; }

private:
    int x;
    int y;

};  /// class Point

auto main() -&gt; int
{
    Point p1{ 2, 5 };
    Point p2{};

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p1.X() &lt;&lt; &quot;, &quot; &lt;&lt; p1.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p2.X() &lt;&lt; &quot;, &quot; &lt;&lt; p2.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;


    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/Wrne3b1nd">Example</a></p>
<h3 id="copy-constructors"><a class="header" href="#copy-constructors">Copy Constructors</a></h3>
<p>Constructors allow for defining custom semantics for common meta-like operations. For example, if you define a constructor that takes a constant reference to another <code>Point</code>, the only thing to can do is copy the data from the other class. This constructor pattern is called Copy Semantics. We can also overload the <code>=</code> operator so we can perform copy assignments.
Let's define a copy constructor for <code>Point</code>.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

class Point
{
public:

    /// Default Constructor
    constexpr
    Point() noexcept
        : x{ 0 }, y{ 0 }
    { }

    /// Explicit Constructor for initialising `x` and `y`
    explicit constexpr
    Point(int x, int y) noexcept
        : x{ x }, y{ y }
    { }

    /// Copy Constructor
    constexpr Point(const Point&amp; p) noexcept
        : x{ p.x }, y{ p.y }
    { }

    constexpr auto
    X() noexcept -&gt; int&amp;
    { return x; }

    constexpr auto
    Y() noexcept -&gt; int&amp;
    { return y; }

private:
    int x;
    int y;

};  /// class Point

auto main() -&gt; int
{
    Point p1{ 2, 5 };
    Point p2{ p1 };   ///&lt; Copy Constructor Called

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p1.X() &lt;&lt; &quot;, &quot; &lt;&lt; p1.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p2.X() &lt;&lt; &quot;, &quot; &lt;&lt; p2.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;
    
    p2.X() = 8;
    p2.Y() = 9;

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p1.X() &lt;&lt; &quot;, &quot; &lt;&lt; p1.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p2.X() &lt;&lt; &quot;, &quot; &lt;&lt; p2.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/YYhf9baW3">Example</a></p>
<h3 id="move-constructors"><a class="header" href="#move-constructors">Move Constructors</a></h3>
<p>While our <code>Point</code> class has gotten pretty sophisticated there is one file base constructor we need in order to complete its baseline functionality. In C++, all data has an owner. We can get pointers and references to data so that other can borrow the data. We can even copy data so that a new owner can have the same values as another however, there is one missing piece. The transfer of ownership, what if we want to give ownership of some data to a new owner. We see this principle with rvalue references. When we initialise an <code>int</code> with a literal; say <code>1</code>, we are transferring ownership of the data associated with the literal <code>1</code> to the named variable. In C++ this is called a move. Moves occur when a constructor (or assignment) of a type is called on a rvalue reference which invokes the class's move constructor. Moves will rip the data of a type out of it and transfer the ownership of the data and resource to the new object, leaving the old owner in a default initialised state (usually). Moves can be induced using the <code>std::move()</code> function from the <code>&lt;utility&gt;</code> header.</p>
<blockquote>
<p>Note: Moves of literal types will often invoke a copy over a move because they are primitive types and this cheap to copy. Moves are mostly relevant to more complex types.</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;utility&gt;

class Point
{
public:

    /// Default Constructor
    constexpr
    Point() noexcept
        : x{ 0 }, y{ 0 }
    { }

    /// Explicit Constructor for initialising `x` and `y`
    explicit constexpr
    Point(int x, int y) noexcept
        : x{ x }, y{ y }
    { }

    /// Copy Constructor
    constexpr Point(const Point&amp; p) noexcept
        : x{ p.x }, y{ p.y }
    { }

    /// Move Constructor
    constexpr Point(Point&amp;&amp; p) noexcept
        : x{ std::move(p.x) }, y{ std::move(p.y) }
    { 
        p.x = int();
        p.y = int();
    }

    constexpr auto
    X() noexcept -&gt; int&amp;
    { return x; }

    constexpr auto
    Y() noexcept -&gt; int&amp;
    { return y; }

private:
    int x;
    int y;

};  /// class Point

auto main() -&gt; int
{
    Point p1{ 2, 5 };

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p1.X() &lt;&lt; &quot;, &quot; &lt;&lt; p1.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;
    
    Point p2{ std::move(p1) };   ///&lt; Move Constructor Called

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p1.X() &lt;&lt; &quot;, &quot; &lt;&lt; p1.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p2.X() &lt;&lt; &quot;, &quot; &lt;&lt; p2.Y() &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/TfGEWW7qM">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/utility/move"><code>std::move()</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/header/utility"><code>&lt;utility&gt;</code></a></li>
</ul>
<h3 id="destructors"><a class="header" href="#destructors">Destructors</a></h3>
<p>So far we have built a pretty sophisticated type of our own with many ways to construct it however, what happens when it gets destroyed. This will invoke the classes destructor. The destructor is declared the same as the default constructor however, it is prefixed with a tilde ('~') in the constructors name. Destructors are used to properly free resources from the type. Resources include things such as dynamic memory, device handles, web sockets etc. For our <code>Point</code> class our destructor is really a no-op as all of its members are trivial to destruct and will automatically occur. A trivial constructor will look like this.</p>
<pre><code class="language-cxx">/// ... Rest of `Point` class's constructors

constexpr ~Point() noexcept {}

/// ... Members variables
</code></pre>
<h3 id="raii"><a class="header" href="#raii">RAII</a></h3>
<p>So why have all these means of specifying creation and deletion of objects? One of the core faults of many programs in C is the requirement to explicitly create and destroy resources, even of structures. One of the first things introduced to C++ where constructors and destructors so that the creation of object of a type and its subsequent destruction were tied to the type itself anf could be implicitly handled by the compiler. It also allowed for classes to acquire all resources they needed at the time of construction. This principle is known as 'Resource Acquisition Is Initialisation' or RAII. This means that the lifetime of any resource owned by a class is tied to the lifetime of an instance of that class.</p>
<p>How this works is that a constructor acquires all the required resources at construction meaning that after construction the object must be initialised. Similarly, the destructor releases resources in reverse-acquisition-order to prevent resource leaks.
This also means that if a constructor should fail (by throwing an exception), any already acquired resources are released in reverse acquisition order and destructors must never throw.</p>
<p>Classes with member functions named <code>open()</code>/<code>close()</code>, <code>lock()</code>/<code>unlock()</code>, or <code>init()</code>/<code>copyFrom()</code>/<code>destroy()</code>
(or similar, carrying the same semantics meaning) are typical examples of non-RAII classes.</p>
<h3 id="letting-the-compiler-do-the-work-for-you"><a class="header" href="#letting-the-compiler-do-the-work-for-you">Letting the compiler do the work for you</a></h3>
<p>Because our <code>Point</code> class is superficial and almost trivial, it can be annoying to define all the constructors and when the resources being initialised are trivial. It would be nice to not have to specify every constructor. What if we could make the compiler generate the constructors for us? Well, we can. By just declaring the constructors signature with no member initialiser list or body, we can use the <code>= default</code> suffix specifier indicating for the compiler to generate the constructor for us. We will do this for the default constructor.</p>
<pre><code class="language-cxx">/// ... Point details 

constexpr Point() noexcept = default;

/// ... Point details
</code></pre>
<blockquote>
<p>Note: It should be noted that you should only do this if the operation of performed by a particular constructor is trivial and predictable and doesn't require specific set of operations to occur.</p>
</blockquote>
<p>You can also disallow the use of a particular constructor entirely by deleting it.</p>
<pre><code class="language-cxx">/// ... Point details

constexpr Point(const Point&amp; p) noexcept = delete;  ///&lt; Point objects cannot be copied.

/// ... Point details
</code></pre>
<h2 id="members--methods"><a class="header" href="#members--methods">Members &amp; Methods</a></h2>
<p>While constructors and destructors ensure resource and lifetime safety for classes they are only half the story. Member functions or methods allow us to define operations that we want to on or using the data help by a class. They allow for stateful modification of data while ensuring type safety. To define a methods for a class you simply define a function within the classes body. Normal rules for naming and overloading apply however methods are able to access all members (function and variable) of the immediate class and any <code>protected</code> and <code>public</code> members of parent classes. In our <code>Point</code> class we already have to members; <code>Point::X()</code> and <code>Point::Y()</code> which return <code>int&amp;</code> of the members <code>Point::x</code> and <code>Point::y</code> respectively.</p>
<pre><code class="language-cxx">/// ... Point details

constexpr auto
X() noexcept -&gt; int&amp;
{ return x; }

constexpr auto
Y() noexcept -&gt; int&amp;
{ return y; }

/// ... Point details
</code></pre>
<h3 id="const-and-reference-qualifiers"><a class="header" href="#const-and-reference-qualifiers">Const and Reference Qualifiers</a></h3>
<p>Members can restrict and customize their usage on particular instances of its class through the class objects value category and cv-qualifiers. By postfixing the symbols <code>const</code>, <code>&amp;</code> and <code>&amp;&amp;</code> to a member function we can restrict the usage of that member function to instances of the class object to being a constant object and/or having either value category of lvalue or rvalue respectively.</p>
<blockquote>
<p>Note: A combination of cv- and ref- qualifiers can be used ie <code>const&amp;</code> or <code>const&amp;&amp;</code> but not both</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;utility&gt;

auto print(auto n) -&gt; void
{ std::cout &lt;&lt; n &lt;&lt; std::endl; }

class A
{
public:

    auto f() &amp; -&gt; int&amp;
    { 
        print(&quot;lvalue&quot;);
        return n; 
    }

    auto f() const&amp; -&gt; int
    { 
        print(&quot;const lvalue&quot;);
        return n; 
    }

    auto f() &amp;&amp; -&gt; int
    { 
        print(&quot;rvalue&quot;);
        return std::move(n); 
    }

    auto f() const&amp;&amp; -&gt; int
    { 
        print(&quot;const rvalue&quot;);
        return std::move(n); 
    }

private:
    
    int n = 0;
};

auto main() -&gt; int
{
    A a;
    const A ca;

    a.f();
    std::move(a).f();
    A().f();

    ca.f();
    std::move(ca).f();

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/TGoh9Yrjc">Example</a></p>
<h3 id="this"><a class="header" href="#this">This</a></h3>
<p>It is useful for a class to be self aware and have some means of referring to itself, for example when working with another instance of the same class in a method it can be ambiguous when you are using members from your instance and from the other objects instance. Classes in C++ implicitly have a member called <code>this</code>. <code>this</code> is a pointer to the current instance of a class in memory. Using <code>this</code> allows for qualified lookup of names for the current object. Like any other pointer it can be dereferenced so that it can be used as a reference or have its members accessed using <code>this-&gt;</code>. <code>this</code> can only be used in methods and has the type of the class type the method was called with including cv-qualifications.</p>
<pre><code class="language-cxx">/// ... Point details

constexpr auto
X() noexcept -&gt; int&amp;
{ return this-&gt;x; }

constexpr auto
Y() noexcept -&gt; int&amp;
{ return this-&gt;y; }

/// ... Point details
</code></pre>
<p><a href="https://en.cppreference.com/w/cpp/language/this">The <code>this</code> pointer</a></p>
<h3 id="operator-overloading-1"><a class="header" href="#operator-overloading-1">Operator Overloading</a></h3>
<p>Much like how you can overload operators as free functions, classes can define there own overloads for operators. operator overloads for classes are defined just like regular methods for classes however, the first argument is implicitly <code>this</code> object.</p>
<pre><code class="language-cxx">/// ... Point details

constexpr auto
operator+ (const Point&amp; p) noexcept -&gt; Point
{ return Point{ x + p.x, y + p.y }; }

constexpr auto
operator- (const Point&amp; p) noexcept -&gt; Point
{ return Point{ x - p.x, y - p.y }; }

constexpr auto
operator== (const Point&amp; p)
    noexcept -&gt; bool
{ return (x == p.x) &amp;&amp; (y == p.y); }

constexpr auto
operator!= (const Point&amp; p)
noexcept -&gt; bool
{ return !(*this == p); }

/// ... Point details
</code></pre>
<p><a href="https://www.godbolt.org/z/TG9WW74bo">Example</a></p>
<h3 id="assignment-overloads"><a class="header" href="#assignment-overloads">Assignment Overloads</a></h3>
<p>One of the most useful operator overloads we can define for a class is an overload for <code>=</code>; two in fact, one for each of copy semantics and move semantics. This methods work identical to their constructor counterparts except they must have an explicit return type and value, cannot have a member initializer list and must only be defined for a single argument.</p>
<pre><code class="language-cxx">/// ... Point details

constexpr auto
operator= (const Point&amp; p) noexcept -&gt; Point&amp;
{
    if (p != *this)
    {
        x = p.x;
        y = p.y;
    }

    return *this;
}

constexpr auto
operator= (Point&amp;&amp; p) noexcept -&gt; Point&amp;
{
    if (p != *this)
    {
        x = std::move(p.x);
        y = std::move(p.y);
    }

    return *this;
}

/// ... Point details
</code></pre>
<blockquote>
<p>Note: The <code>if (p != *this)</code> check ensures self assignment does not occur.</p>
</blockquote>
<p><a href="https://www.godbolt.org/z/xvcf57xcT">Example</a></p>
<h3 id="friend-methods"><a class="header" href="#friend-methods">Friend Methods</a></h3>
<p>Sometimes it is useful to access the internal <code>private</code> and <code>protected</code> data of a class without having to make it exposed to everyone. This is were friends come in handy. The <code>friend</code> keyword can be attached to nested class forward specifications and functions. This makes free functions able to access and modify the internal data of a class. Friendship is most useful for creating relationships between hierarchal unrelated classes interoperate with each other such as in certain operator overloads.</p>
<blockquote>
<h4 id="notes-2"><a class="header" href="#notes-2">Notes:</a></h4>
<ul>
<li>Friendship is not transitive - A friend of your friend is not your friend</li>
<li>Friendship is not inherited - Your friends children are not your friends</li>
</ul>
</blockquote>
<p>Here I've defined an overload for <code>&lt;&lt;</code> as a <code>friend</code> function. This is because <code>std::ostream</code> is an unrelated type to <code>Point</code> but we want to be able to access the non-public members of a <code>Point</code> object. With this, we can delete the <code>Point::X()</code> and <code>Point::Y()</code> methods.</p>
<pre><code class="language-cxx">/// ... Point details

friend auto
operator&lt;&lt; (std::ostream&amp; os, const Point&amp; p)
    noexcept -&gt; std::ostream&amp;
{ 
    os &lt;&lt; &quot;( &quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot; )&quot;;
    return os;
}

/// ... Point details
</code></pre>
<p><a href="https://www.godbolt.org/z/MxacvscTY">Example</a></p>
<p><a href="chapter5//content/chapter5/examples/point-v1.hxx">Version 1 of <code>Point</code></a></p>
<h2 id="dynamic-inheritance"><a class="header" href="#dynamic-inheritance">Dynamic Inheritance</a></h2>
<p>You are able to inherit the members of another class into your own class. This allows for many OOP concepts to be applied such as inheritance and polymorphism. Base classes are specified after the derived classes name specification. All classes can be inherited from (unless declared as <code>final</code>).</p>
<blockquote>
<p>Note: OOP principles are not the focus of this series and is only covered lightly. C++ is by no means a Object Oriented language (despite similar naming). Rather C++ supports OOP principles in order to benefit from these principles however, many chapters of the language (Standard Library) will utilise these features and principles in a far more general sense.</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;iostream&gt;

struct A
{
    int n;
};

struct B : public A
{
    float f;
};

auto main() -&gt; int
{
    A a();
    std::cout &lt;&lt; a.n &lt;&lt; std::endl;
    a.n = 7;
    std::cout &lt;&lt; a.n &lt;&lt; std::endl;

    B b();
    std::cout &lt;&lt; b.n &lt;&lt; std::endl;
    std::cout &lt;&lt; b.f &lt;&lt; std::endl;
    b.n = 4;
    std::cout &lt;&lt; b.n &lt;&lt; std::endl;
    std::cout &lt;&lt; a.n &lt;&lt; std::endl;

    b.f = 8.53464f;
    std::cout &lt;&lt; b.f &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/xvMdeq3n5">Example</a></p>
<h3 id="virtual-methods"><a class="header" href="#virtual-methods">Virtual Methods</a></h3>
<p>A method can be marked as virtual with the <code>virtual</code> specifier. This means that classes that derive this method can override them by specifying them as overridden with the <code>override</code> keyword in the derived class.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

struct A
{
    virtual void foo();
};

void A::foo() { std::cout &lt;&lt; &quot;A::foo()&quot; &lt;&lt; std::endl; }

struct B : public A
{
    void foo() override;
};

void B::foo() { std::cout &lt;&lt; &quot;B::foo()&quot; &lt;&lt; std::endl; }

auto main() -&gt; int
{
    A a;
    a.foo();

    B b;
    b.foo();

    return 0;
}
</code></pre>
<ul>
<li>
<blockquote>
<p>Note: <code>virtual</code> and <code>override</code> methods cannot have deduced return types</p>
</blockquote>
</li>
<li>
<blockquote>
<p>Note: The definition of virtual functions must be defined separate from the declaration.</p>
</blockquote>
</li>
</ul>
<p><a href="https://www.godbolt.org/z/zrMs4EhKn">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/virtual"><code>virtual</code> function specifier</a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/override"><code>override</code> specifier</a></li>
</ul>
<h3 id="virtual-inheritance"><a class="header" href="#virtual-inheritance">Virtual Inheritance</a></h3>
<p>Classes can also inherit base classes virtually. For each base class that is specified as virtual, the most derived object will contain only one sub-object of that <code>virtual</code> base class, even if the class appears many times in the inheritance hierarchy (as long as it is inherited <code>virtual</code> every time)*.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

struct B 
{ int n; };

class X : public virtual B {};
class Y : virtual public B {};
class Z : public B {};
 
// every object of type AA has one X, one Y, one Z, and two B's:
// one that is the base of Z and one that is shared by X and Y
struct AA : X, Y, Z
{
    AA()
    {
        X::n = 1; // modifies the virtual B sub-object's member
        Y::n = 2; // modifies the same virtual B sub-object's member
        Z::n = 3; // modifies the non-virtual B sub-object's member
 
        std::cout &lt;&lt; X::n &lt;&lt; Y::n &lt;&lt; Z::n &lt;&lt; '\n';
    }
};

auto main() -&gt; int
{
    AA aa;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/qT5v7aEPx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/derived_class">Derived Classes</a></p>
<blockquote>
<p>*Note: This is an adaptation (paraphrase) from <a href="https://en.cppreference.com/w/cpp/language/derived_class#:%7E:text=initializer%20list.-,Virtual%20base%20classes,-For%20each%20distinct">cppreference</a></p>
</blockquote>
<h3 id="abstract-classes"><a class="header" href="#abstract-classes">Abstract Classes</a></h3>
<p>Abstract classes are classes which define or inherit at least one 'pure' <code>virtual</code> methods. Pure <code>virtual</code> methods are <code>virtual</code> methods whose declaration are suffixed by the <code>= 0;</code> pure-specifier expression. Abstract classes cannot be instantiated but can be pointer to or referred to.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;

struct Base
{
    virtual void g() = 0;
    virtual ~Base() {}
};

void Base::g() { std::cout &lt;&lt; &quot;Base::g()&quot; &lt;&lt; std::endl; }
 
struct A : Base
{
    virtual void g() override;
};

void A::g() 
{ 
    Base::g();
    std::cout &lt;&lt; &quot;A::g()&quot; &lt;&lt; std::endl; 
}

auto main() -&gt; int
{
    // Base b;  ///&lt; Fails `cannot declare variable 'b' to be of abstract type 'Base'`

    A a;
    a.g();

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/axj9Tbr4v">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/abstract_class">Abstract class</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="templates"><a class="header" href="#templates">Templates</a></h1>
<h2 id="why-templates"><a class="header" href="#why-templates">Why templates?</a></h2>
<p>Everything we have learnt about C++ relies on the fact the type of any object must be known at compile time. This can be quite constricting on the kinds of programs we are able to right. Just think back to Assignment 1 where you were sectioned with creating a class called <code>Triple</code> with a single underlying type (either <code>int</code>, <code>float</code> or <code>double</code>). Imagine you create <code>TripleInt</code> but now had to create a class with the same interface but for the other underlying types (<code>float</code> and <code>double</code> in this case) that you did not implement (well some of you may have). This can dramatically increase code duplication. One might think to solve this through class inheritance. Somehow define a common abstract interface that derived classes could inherit from and then override the methods in order to implement the interface for each underlying type. However, this requires more work still as anyone that wants to implement <code>Triple</code> would have to inherit from it and implement the same interface and logic for there own underlying type. Another caveat is this requires every <code>Triple</code> object to have a vtable to there underlying methods resulting in dynamic dispatch of method calling which, is something that has a lot of runtime overhead. The real solution is to have a single interface that can working for any desired type. This is where templates come in.</p>
<h2 id="what-are-templates"><a class="header" href="#what-are-templates">What are templates?</a></h2>
<p>Templates can be thought of as blueprints for function, variable or class. They allow for defining interfaces in terms of template parameters which can be types or compile-time variables. Templates can then be instantiated for a given set of valid template parameters which results in the function, variable or class being fully defined meaning they can now be instantiated themselves. Templates are created by using a <code>template&lt;&gt;</code> declaration above the definition of a function, variable or class with the template parameters being specified within the angle brackets (<code>&lt;&gt;</code>).</p>
<p><a href="https://en.cppreference.com/w/cpp/language/templates">Templates</a></p>
<h2 id="template-parameters"><a class="header" href="#template-parameters">Template Parameters</a></h2>
<p>There are three categories of template parameters; type, non-type and template-template. We wont cover template-template parameters as they are used for advanced specialisation. Type template parameters are template parameters that accept a type as an argument. These are used to create generic functions, variables and classes that can be defined in terms of many different types. These are the most common use of templates. Type arguments are declared as <code>template&lt;typename T&gt;</code> with T being the name of the type argument and will be an alias to the type we later instantiate the template with. Non-type arguments are used to pass values at compile time to a function, variable or class. The type of a non-type template argument must be explicitly declared eg. <code>template&lt;int N&gt;</code>, Non-type template arguments are constant and thus cannot be mutated. Here is an example of a template declaration that takes type and non-type template arguments.</p>
<pre><code class="language-cxx">template&lt;typename T, std::size_t N&gt;
/// ... template entity details
</code></pre>
<p>This is the template signature of <code>std::array</code>.</p>
<p><a href="https://en.cppreference.com/w/cpp/language/template_parameters">Template Arguments</a></p>
<h2 id="template-functions"><a class="header" href="#template-functions">Template Functions</a></h2>
<p>To begin, we will look at defining template functions. Template functions are defined identically to regular functions except that before the functions signature we use a template declaration. As we can see below, regardless of the type of the array or the its size we can call <code>print&lt;&gt;()</code>. Also, thanks to C++17 we don't have to call it with specific template arguments as the can be deduced from the array itself.</p>
<pre><code class="language-cxx">#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

template&lt;typename T, std::size_t N&gt;
auto print(const std::array&lt;T, N&gt;&amp; arr) -&gt; void
{
    std::cout &lt;&lt; &quot;[ &quot;;

    for (auto n { N }; const auto&amp; e : arr)
        if (--n &gt; 0)
            std::cout &lt;&lt; e &lt;&lt; &quot;, &quot;;
        else
            std::cout &lt;&lt; e;

    std::cout &lt;&lt; &quot; ]&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto a1 = std::to_array&lt;int&gt;({ 1, 2, 3, 4, 5 });
    auto a2 = std::to_array&lt;double&gt;({ 1.576, 0.0002, 3756348.34646, 5e-14, 465.7657, 358.0, 237437.456756 });
    auto a3 = std::to_array&lt;std::string&gt;({ &quot;John&quot;, &quot;Anna&quot;, &quot;Grace&quot;, &quot;Bob&quot; });

    print&lt;int, 5&gt;(a1);  ///&lt; Explicit template argument instantiation
    print(a2);          ///&lt; template argument deduction (same below)
    print(a3);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/WxsGsfna4">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/function_template">Function template</a></p>
<h2 id="template-classes"><a class="header" href="#template-classes">Template Classes</a></h2>
<p>Template classes allow us to define generic types. Almost all of C++ standard library types are template classes, even <code>std::cout</code> which is a static instance of the class <code>std::basic_ostream&lt;char&gt;</code>. Template classes allow us to create a blueprint of a class and then instantiate the class definition which a particular type. We can see this with out <code>Point</code> class from the previous section section. Now we define <code>Point</code> in terms of a template type <code>T</code> which we will specify later. This allows us to create <code>Point</code> objects of <code>float</code> and <code>double</code> as well while still only defining a single interface.</p>
<blockquote>
<p>Note: For copy and move constructors, the template type parameters can be elided as copy and move semantics must preserve the type. Converting constructors (a type of explicit constructor) are used to convert between template types.</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;utility&gt;

template&lt;typename T&gt;
class Point
{
public:
    /// Default Constructor (Compiler Created)
    constexpr Point() = default;

    explicit constexpr
    Point(T x, T y) noexcept
        : x{ x }, y{ y }
    { }

    constexpr Point(const Point&amp; p) noexcept
    : x{ p.x }, y{ p.y }
    { }

    constexpr Point(Point&amp;&amp; p) noexcept
        : x{ std::move(p.x) }
        , y{ std::move(p.y) }
    { p = Point(); }

    constexpr auto
    operator= (const Point&amp; p) noexcept -&gt; Point&amp;
    {
        if (p != *this)
        {
            x = p.x;
            y = p.y;
        }

        return *this;
    }

    constexpr auto
    operator= (Point&amp;&amp; p) noexcept -&gt; Point&amp;
    {
        if (p != *this)
        {
            x = std::move(p.x);
            y = std::move(p.y);
        }

        return *this;
    }

    ~Point() noexcept = default;

    constexpr auto
    operator+ (const Point&amp; p) noexcept -&gt; Point
    { return Point{ x + p.x, y + p.y }; }

    constexpr auto
    operator- (const Point&amp; p) noexcept -&gt; Point
    { return Point{ x - p.x, y - p.y }; }

    constexpr auto
    operator== (const Point&amp; p)
        noexcept -&gt; bool
    { return (x == p.x) &amp;&amp; (y == p.y); }

    constexpr auto
    operator!= (const Point&amp; p)
    noexcept -&gt; bool
    { return !(*this == p); }

    friend auto
    operator&lt;&lt; (std::ostream&amp; os, const Point&amp; p)
        noexcept -&gt; std::ostream&amp;
    { 
        os &lt;&lt; &quot;( &quot;
        &lt;&lt; p.x
        &lt;&lt; &quot;, &quot;
        &lt;&lt; p.y
        &lt;&lt; &quot; )&quot;;

        return os;
    }

private:
    T x;
    T y;
};


auto main() -&gt; int
{
    auto p1 = Point&lt;int&gt;{ 2, 5 };
    auto p2 = Point{ 6, 7 };
    auto p3 = p1 + p2;
    auto p4 = Point&lt;double&gt;{ 5.6 , -0.007 };
    auto p5 = Point{ 4.576 , 24.012 };
    auto p6 = p4 - p5;

    std::cout &lt;&lt; p1 &lt;&lt; std::endl;
    std::cout &lt;&lt; p2 &lt;&lt; std::endl;
    std::cout &lt;&lt; p3 &lt;&lt; std::endl;
    std::cout &lt;&lt; p4 &lt;&lt; std::endl;
    std::cout &lt;&lt; p5 &lt;&lt; std::endl;
    std::cout &lt;&lt; p6 &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<blockquote>
<p>Note: We could define <code>Point::x</code> and <code>Point::y</code> to be different types but this is unnecessary for now.</p>
</blockquote>
<p><a href="https://www.godbolt.org/z/nhbsbnE9b">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/class_template">Class Template</a></p>
<h2 id="class-template-methods"><a class="header" href="#class-template-methods">Class Template Methods</a></h2>
<p>Just like how free functions can be templated, we can also specify methods of classes to be templated. This allows use to customize classes methods not just in terms of its template types and parameters but also in terms of templates of objects that we may need to pass to the method of a class. This useful for creating overloaded methods that are not just customized by type but also the template signature pattern they have.</p>
<p>You may have noticed that I did not add or subtract two <code>Point</code> of different type in the previous example. This is because <code>+</code> and <code>-</code> are only defined for <code>Point</code> of the same template. We can fix this with a templated method. There are a few other details we have to add in order for this to work. First we add the template specification for the other <code>Point&lt;U&gt;</code> argument (we can do the same for <code>==</code> and <code>!=</code>). We then us <code>std::common_type&lt;T...&gt;</code> to help deduce the arithmetic (an other) promotions between types. This is for promotions of say <code>int</code> to <code>double</code>. Finally, because the class <code>Point&lt;U&gt;</code> is a different instantiation of <code>Point</code> to <code>this</code> (ie. <code>Point&lt;T&gt;</code>), we have to specify all <code>Point&lt;U&gt;</code> of any <code>U</code> type as a friend class to <code>Point&lt;T&gt;</code>.</p>
<pre><code class="language-cxx">/// ... Point details

template&lt;typename U&gt;
constexpr auto
operator+ (const Point&lt;U&gt;&amp; p) 
    noexcept -&gt; Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;
{ return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x + p.x, y + p.y }; }

template&lt;typename U&gt;
constexpr auto
operator- (const Point&lt;U&gt;&amp; p) 
    noexcept -&gt; Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;
{ return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x - p.x, y - p.y }; }

template&lt;typename U&gt;
constexpr auto
operator== (const Point&lt;U&gt;&amp; p)
    noexcept -&gt; bool
{ return (x == p.x) &amp;&amp; (y == p.y); }

template&lt;typename U&gt;
constexpr auto
operator!= (const Point&lt;U&gt;&amp; p)
noexcept -&gt; bool
{ return !(*this == p); }

/// ... Point details

private:

    T x;
    T y;

    template&lt;typename U&gt;
    friend class Point;
</code></pre>
<blockquote>
<p>Note: The template argument names must be different then the outer template classes template argument names as this name (symbol) is still very much in scope.</p>
</blockquote>
<p><a href="https://www.godbolt.org/z/4WKKrMsqn">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/member_template">Member templates</a></li>
<li><a href="https://en.cppreference.com/w/cpp/types/common_type"><code>std::common_type</code></a></li>
<li><a href="chapter5//content/chapter5/examples/point-v2.hxx">Version 2 of <code>Point&lt;T&gt;</code></a></li>
</ul>
<h3 id="section-26-template-variables"><a class="header" href="#section-26-template-variables">Section 2.6: Template Variables</a></h3>
<p>Is is also possible to define variables as templates. This allows for variables to take on different forms depending on the underlying type. Template variables are typically <code>static</code> or <code>constexpr</code> free variables or <code>static</code> members of a class. A common use of template variables is mathematical constants that have different underlying types. We can see this in use with <code>e&lt;T&gt;</code> and <code>std::numeric_limits&lt;T&gt;</code> members.</p>
<pre><code class="language-cxx">#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;

template&lt;typename T&gt;
constexpr T e = T(2.7182818284590452353602874713527);

auto main() -&gt; int
{
    std::cout &lt;&lt; std::setprecision(std::numeric_limits&lt;long double&gt;::max_digits10);
    std::cout &lt;&lt; &quot;True e            = 2.7182818284590452353602874713527&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;e&lt;long double&gt;    = &quot; &lt;&lt; e&lt;long double&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;e&lt;double&gt;         = &quot; &lt;&lt; e&lt;double&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;e&lt;float&gt;          = &quot; &lt;&lt; e&lt;float&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;e&lt;int&gt;            = &quot; &lt;&lt; e&lt;int&gt; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;e&lt;char&gt;           = &quot; &lt;&lt; e&lt;char&gt; &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<blockquote>
<p>Note: Consequently, this is a good showcase of how quickly <code>float</code> and <code>double</code> loose precision.</p>
</blockquote>
<p><a href="https://www.godbolt.org/z/4eqKcTT4s">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/language/variable_template">Variable Templates</a></li>
<li><a href="https://en.cppreference.com/w/cpp/types/numeric_limits"><code>std::numeric_limits</code></a></li>
</ul>
<h2 id="template-metaprogramming-basics"><a class="header" href="#template-metaprogramming-basics">Template Metaprogramming Basics</a></h2>
<p>We've seen a bit of metaprogramming in C++ already. Metaprogramming is the ability to influence the structure of your code at compile time using the language itself. Templates are a simple form of metaprogramming and allow us to change the behaviour of our code based on the types and values we instantiate our templates with. Using templates, the C++ standard library has many metaprogramming objects that allow us to customize our code even more. Most of the standard  libraries metaprogramming objects are in the form of type analysis from the <code>&lt;type_traits&gt;</code> header. These allow us to inspect the properties of any type (template or known) and customize based on the results. There is much more to metaprogramming that is beyond the scope of this course.</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/meta">Metaprogramming Library</a></li>
<li><a href="https://en.cppreference.com/w/cpp/numeric/ratio">Compile-time rational arithmetic</a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a></li>
<li><a href="https://en.cppreference.com/w/cpp/header/type_traits"><code>&lt;type_traits&gt;</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/utility/integer_sequence"><code>std::integer_sequence</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-programming"><a class="header" href="#generics-programming">Generics Programming</a></h1>
<p>Generic programming is a style of programming that involves defining algorithms and data structures in terms of generic types. This allows the behaviour of the program to be adapted according to the types, which can be resolved at compile or pre-process time as opposed to through runtime resolution. It also allows for programs to work in a more adaptive way so that, regardless of the type that used at instantiation time, the program will adapt and work accordingly.</p>
<h2 id="parameter-packs"><a class="header" href="#parameter-packs">Parameter Packs</a></h2>
<p>Chapter of C++ generic programming facilities that go hand-in-hand with templates is template parameter packs. These are heterogenous objects that can contain an arbitrary number of elements that gets instantiated at compile time. Parameter packs allows for C++ to generalize the idea passing an around an arbitrary number of different typed arguments. This can be utilised by template functions and classes alike. Parameter packs can also have a single type which indicates an arbitrary number of values with the same type. Parameter packs are denoted by an ellipsis <code>Ts...</code> where <code>Ts</code> is either a parameter pack template type parameter from the template declaration of the form <code>template&lt;typename... Ts&gt;</code>, or the single type of a value parameter pack with the function signature of the form <code>f(int... ints)</code>. We can combine these two notations to create functions of variadic type arguments <code>f(Ts... ts)</code> where <code>Ts</code> is a template type parameter pack and <code>ts</code> is a template value parameter pack.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
 
auto tprintf(const char* format) -&gt; void  ///&lt; Base function
{ std::cout &lt;&lt; format; }
 
template&lt;typename T, typename... Args&gt;
auto tprintf(const char* format, T value, Args&amp;&amp;... args) -&gt; void  ///&lt; recursive variadic function
{
    for (; *format != '\0'; format++)
    {
        if (*format == '%')
        {
            std::cout &lt;&lt; value;
            tprintf(format + 1, std::forward&lt;Args&gt;(args)...);  ///&lt; recursive call, `std::forward` is called on the expanded pack
            return;
        }
        std::cout &lt;&lt; *format;
    }
}
 
auto main() -&gt; int
{
    tprintf(&quot;% world% % - %\n&quot;, &quot;Hello&quot;, '!', 123, -0.3575);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/sMxWcd1fM">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/parameter_pack">Parameter Packs</a></p>
<h3 id="parameter-pack-size"><a class="header" href="#parameter-pack-size">Parameter pack size</a></h3>
<p>The size of a pack can be obtained by using the <code>sizeof...</code> operator. This will return a <code>std::size_t</code> with the number of either types or values in the parameter pack.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
 
template&lt;typename... Args&gt;
auto print_size(Args&amp;&amp;... args) -&gt; void
{ std::cout &lt;&lt; sizeof...(args) &lt;&lt; std::endl; }
 
auto main() -&gt; int
{
    print_size(2, 0.6, 0.5313f, &quot;Hello&quot;);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/nhnj3Ehne">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/sizeof..."><code>sizeof...</code></a></p>
<h3 id="fold-expressions"><a class="header" href="#fold-expressions">Fold Expressions</a></h3>
<p>Fold expressions allow for unary and binary operations to be performed on packs of elements. This allows us to 'loop' through a pack and perform compile type computation such as sums, printing and more. Fold expressions can operate just on the pack ot can have an initialiser that is separate from the pack.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
 
template&lt;typename... Args&gt;
auto sum(Args&amp;&amp;... args) -&gt; std::common_type&lt;Args...&gt;::type
{ return (... + args); }

template&lt;typename T, typename... Args&gt;
auto product(T init, Args&amp;&amp;... args) -&gt; std::common_type&lt;T, Args...&gt;::type
{ return (init * ... * args); }
 
auto main() -&gt; int
{
    std::cout &lt;&lt; sum(2, 0.6, 0.5313f) &lt;&lt; std::endl;
    std::cout &lt;&lt; product(0, 6, 1.356, 90.5313f) &lt;&lt; std::endl;
    std::cout &lt;&lt; product(6, 1.356, 90.5313f) &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/zh97vevo3">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/fold">Fold expressions</a></p>
<h2 id="tuples"><a class="header" href="#tuples">Tuples</a></h2>
<p>Because of the introduction of parameter packs in C++11, C++ was finally able to have a tuple data structure called <code>std::tuple</code>. Tuples are a formalisation of parameter packs, tieing a heterogeneous pack of types to a heterogeneously types pack of values. Tuples are incredibly powerful in programming as they formalise the idea of being able to cluster together elements of any type where the types might not be immediately be known at definition. This is; normally, incredibly difficult to do in a typed language like C++ with the solution before being to create aggregate classes to store the required data together. Tuples make this far easier and can be used anywhere. ANother benefit is any tuple has a common interface allowing anyone to manipulate them as they need. <code>std::tuple</code> structure is immutable however, its elements can be modified in place making them extremely versatile. <code>std::tuple</code> comes with a host of powerful helper functions and classes that allow for compile time inspection of a tuples size, element type and value access, creation of <code>std::tuple</code> and destructuring.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;utility&gt;

template&lt;typename Tup, std::size_t... I&gt;
auto print(const Tup&amp; t, std::index_sequence&lt;I...&gt;) -&gt; void
{
    std::cout &lt;&lt; &quot;( &quot;;

    (..., (std::cout &lt;&lt; (I == 0 ? &quot;&quot; : &quot;, &quot;) &lt;&lt; std::get&lt;I&gt;(t)) );

    std::cout &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;
}


template&lt;typename... Ts, std::size_t... I&gt;
auto print(const std::tuple&lt;Ts...&gt;&amp; t) -&gt; void
{ print(t, std::make_index_sequence&lt;sizeof...(Ts)&gt;()); }


auto main() -&gt; int
{
    auto t1 = std::tuple&lt;int, double&gt;{ 2, 0.6 };        ///&lt; Types explicitly declared
    auto t2 = std::tuple{ 15.2f, &quot;Hello&quot; };             ///&lt; With type deduction
    auto t3 = std::make_tuple(&quot;Bye&quot;, 15, 78, 343.546);  ///&lt; With type deducing maker

    print(t1);
    print(t2);
    print(t3);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/v5sP6TjYs">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/utility/tuple"><code>std::tuple</code></a></p>
<h3 id="pairs"><a class="header" href="#pairs">Pairs</a></h3>
<p>It is often common place to just need to return a two values of possibly different types and not have to go through the hassle of uses <code>std::tuple</code> generic (yet admittedly cumbersome) access methods. This is where <code>std::pair</code> comes in. <code>std::pair</code> is a specific use case of a <code>std::tuple</code>. Accessing the elements of a pair can be done directly using class dot access of the members name.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;utility&gt;

template&lt;typename F, typename S&gt;
auto print(const std::pair&lt;F, S&gt;&amp; p) -&gt; void
{
    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; p.first &lt;&lt; &quot;, &quot; &lt;&lt; p.second &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto p1 = std::pair&lt;int, double&gt;{ 2, 0.6 };     ///&lt; Types explicitly declared
    auto p2 = std::pair{ 15.2f, &quot;Hello&quot; };          ///&lt; With type deduction
    auto p3 = std::make_pair(78, 343.546);          ///&lt; With type deducing maker

    print(p1);
    print(p2);
    print(p3);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/ax688eds3">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/utility/pair"><code>std::pair</code></a></p>
<h3 id="destructuring"><a class="header" href="#destructuring">Destructuring</a></h3>
<p>Since C++17, <code>std::pair</code> and <code>std::tuple</code> can be accessed using structured bindings. This can make it easier to manipulate the data of a pair, tuple, arrays, slices and even aggregate classes. Structured bindings are declared by an <code>auto</code> specifier (which can have reference, storage and cv qualifiers) followed by square brackets containing comma separated variable names that will bind to the sequence of values ie. <code>/*cv-qual (optional) */auto/*&amp; or &amp;&amp; (optional)*/ [/* names */] = /* tuple-like */</code>.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;tuple&gt;

auto main() -&gt; int
{
   
    auto t = std::make_tuple(78, 343.546, &quot;Hello&quot;);
    auto&amp; [i1, f1, s1] = t;

    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; i1 &lt;&lt; &quot;, &quot; &lt;&lt; f1 &lt;&lt; &quot;, &quot; &lt;&lt; s1 &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;

    i1 = 576876;

    const auto&amp; [i2, f2, s2] = t;
    std::cout &lt;&lt; &quot;( &quot; &lt;&lt; i2 &lt;&lt; &quot;, &quot; &lt;&lt; f2 &lt;&lt; &quot;, &quot; &lt;&lt; s2 &lt;&lt; &quot; )&quot; &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/5v8zb998o">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/structured_binding">Structured bindings</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<h2 id="limitations-to-templates"><a class="header" href="#limitations-to-templates">Limitations to templates</a></h2>
<p>Templates are extremely powerful allow us to create reusable and extendible code however there is a caveat to this. Take for example our <code>Point</code> class from Sections 1-2. <code>Point</code> just takes a single type <code>T</code>. This can be absolutely any type. This can become a problem though later for the user. Say we have a <code>Point&lt;std::string&gt;</code>. This will cause an error for the user of our <code>Point</code> class if they try to take two <code>Point&lt;std::string&gt;</code> because <code>-</code> is not supported by <code>std::string</code>. This can be a major problem as the error produced can be ambiguous to the user and require looking at the source code in depth to diagnose.</p>
<pre><code class="language-cxx">/// ... Point implementation

using namespace std::literals;

auto main() -&gt; int
{
   auto p1 = Point{ &quot;Hello&quot;s, &quot;Hi&quot;s };
   auto p2 = Point{ &quot;Goobye&quot;s, &quot;Bye&quot;s };

   auto p3 = p1 - p2;

   std::cout &lt;&lt; p3 &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p>The error output (by GCC). As we can see it is verbose and delves into many of the attempts to make it work, and this is for a simple class.</p>
<pre><code class="language-sh">&lt;source&gt;: In instantiation of 'constexpr Point&lt;typename std::common_type&lt;T, U&gt;::type&gt; Point&lt;T&gt;::operator-(const Point&lt;U&gt;&amp;) [with U = std::__cxx11::basic_string&lt;char&gt;; T = std::__cxx11::basic_string&lt;char&gt;; typename std::common_type&lt;T, U&gt;::type = std::__cxx11::basic_string&lt;char&gt;]':
&lt;source&gt;:96:19:   required from here
&lt;source&gt;:61:62: error: no match for 'operator-' (operand types are 'std::__cxx11::basic_string&lt;char&gt;' and 'const std::__cxx11::basic_string&lt;char&gt;')
   61 |     { return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x - p.x, y - p.y }; }
      |                                                            ~~^~~~~
In file included from /opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/string:47,
                 from /opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/locale_classes.h:40,
                 from /opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/ios_base.h:41,
                 from /opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/ios:42,
                 from /opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/ostream:38,
                 from /opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/iostream:39,
                 from &lt;source&gt;:1:
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_iterator.h:621:5: note: candidate: 'template&lt;class _IteratorL, class _IteratorR&gt; constexpr decltype ((__y.base() - __x.base())) std::operator-(const reverse_iterator&lt;_IteratorL&gt;&amp;, const reverse_iterator&lt;_IteratorR&gt;&amp;)'
  621 |     operator-(const reverse_iterator&lt;_IteratorL&gt;&amp; __x,
      |     ^~~~~~~~
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_iterator.h:621:5: note:   template argument deduction/substitution failed:
&lt;source&gt;:61:62: note:   'std::__cxx11::basic_string&lt;char&gt;' is not derived from 'const std::reverse_iterator&lt;_IteratorL&gt;'
   61 |     { return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x - p.x, y - p.y }; }
      |                                                            ~~^~~~~
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_iterator.h:1778:5: note: candidate: 'template&lt;class _IteratorL, class _IteratorR&gt; constexpr decltype ((__x.base() - __y.base())) std::operator-(const move_iterator&lt;_IteratorL&gt;&amp;, const move_iterator&lt;_IteratorR&gt;&amp;)'
 1778 |     operator-(const move_iterator&lt;_IteratorL&gt;&amp; __x,
      |     ^~~~~~~~
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_iterator.h:1778:5: note:   template argument deduction/substitution failed:
&lt;source&gt;:61:62: note:   'std::__cxx11::basic_string&lt;char&gt;' is not derived from 'const std::move_iterator&lt;_IteratorL&gt;'
   61 |     { return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x - p.x, y - p.y }; }
      |                                                            ~~^~~~~
&lt;source&gt;:61:71: error: no match for 'operator-' (operand types are 'std::__cxx11::basic_string&lt;char&gt;' and 'const std::__cxx11::basic_string&lt;char&gt;')
   61 |     { return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x - p.x, y - p.y }; }
      |                                                                     ~~^~~~~
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_iterator.h:621:5: note: candidate: 'template&lt;class _IteratorL, class _IteratorR&gt; constexpr decltype ((__y.base() - __x.base())) std::operator-(const reverse_iterator&lt;_IteratorL&gt;&amp;, const reverse_iterator&lt;_IteratorR&gt;&amp;)'
  621 |     operator-(const reverse_iterator&lt;_IteratorL&gt;&amp; __x,
      |     ^~~~~~~~
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_iterator.h:621:5: note:   template argument deduction/substitution failed:
&lt;source&gt;:61:71: note:   'std::__cxx11::basic_string&lt;char&gt;' is not derived from 'const std::reverse_iterator&lt;_IteratorL&gt;'
   61 |     { return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x - p.x, y - p.y }; }
      |                                                                     ~~^~~~~
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_iterator.h:1778:5: note: candidate: 'template&lt;class _IteratorL, class _IteratorR&gt; constexpr decltype ((__x.base() - __y.base())) std::operator-(const move_iterator&lt;_IteratorL&gt;&amp;, const move_iterator&lt;_IteratorR&gt;&amp;)'
 1778 |     operator-(const move_iterator&lt;_IteratorL&gt;&amp; __x,
      |     ^~~~~~~~
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_iterator.h:1778:5: note:   template argument deduction/substitution failed:
&lt;source&gt;:61:71: note:   'std::__cxx11::basic_string&lt;char&gt;' is not derived from 'const std::move_iterator&lt;_IteratorL&gt;'
   61 |     { return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x - p.x, y - p.y }; }
      |                                                                     ~~^~~~~
&lt;source&gt;:61:77: error: no matching function for call to 'Point&lt;std::__cxx11::basic_string&lt;char&gt; &gt;::Point(&lt;brace-enclosed initializer list&gt;)'
   61 |     { return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x - p.x, y - p.y }; }
      |                                                                             ^
&lt;source&gt;:20:15: note: candidate: 'constexpr Point&lt;T&gt;::Point(Point&lt;T&gt;&amp;&amp;) [with T = std::__cxx11::basic_string&lt;char&gt;]'
   20 |     constexpr Point(Point&amp;&amp; p) noexcept
      |               ^~~~~
&lt;source&gt;:20:15: note:   candidate expects 1 argument, 2 provided
&lt;source&gt;:16:15: note: candidate: 'constexpr Point&lt;T&gt;::Point(const Point&lt;T&gt;&amp;) [with T = std::__cxx11::basic_string&lt;char&gt;]'
   16 |     constexpr Point(const Point&amp; p) noexcept
      |               ^~~~~
&lt;source&gt;:16:15: note:   candidate expects 1 argument, 2 provided
&lt;source&gt;:12:5: note: candidate: 'constexpr Point&lt;T&gt;::Point(T, T) [with T = std::__cxx11::basic_string&lt;char&gt;]'
   12 |     Point(T x, T y) noexcept
      |     ^~~~~
&lt;source&gt;:12:5: note:   conversion of argument 1 would be ill-formed:
&lt;source&gt;:9:15: note: candidate: 'constexpr Point&lt;T&gt;::Point() [with T = std::__cxx11::basic_string&lt;char&gt;]'
    9 |     constexpr Point() = default;
      |               ^~~~~
&lt;source&gt;:9:15: note:   candidate expects 0 arguments, 2 provided
ASM generation compiler returned: 1
&lt;source&gt;: In instantiation of 'constexpr Point&lt;typename std::common_type&lt;T, U&gt;::type&gt; Point&lt;T&gt;::operator-(const Point&lt;U&gt;&amp;) [with U = std::__cxx11::basic_string&lt;char&gt;; T = std::__cxx11::basic_string&lt;char&gt;; typename std::common_type&lt;T, U&gt;::type = std::__cxx11::basic_string&lt;char&gt;]':
&lt;source&gt;:96:19:   required from here
&lt;source&gt;:61:62: error: no match for 'operator-' (operand types are 'std::__cxx11::basic_string&lt;char&gt;' and 'const std::__cxx11::basic_string&lt;char&gt;')
   61 |     { return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x - p.x, y - p.y }; }
      |                                                            ~~^~~~~
In file included from /opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/string:47,
                 from /opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/locale_classes.h:40,
                 from /opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/ios_base.h:41,
                 from /opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/ios:42,
                 from /opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/ostream:38,
                 from /opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/iostream:39,
                 from &lt;source&gt;:1:
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_iterator.h:621:5: note: candidate: 'template&lt;class _IteratorL, class _IteratorR&gt; constexpr decltype ((__y.base() - __x.base())) std::operator-(const reverse_iterator&lt;_IteratorL&gt;&amp;, const reverse_iterator&lt;_IteratorR&gt;&amp;)'
  621 |     operator-(const reverse_iterator&lt;_IteratorL&gt;&amp; __x,
      |     ^~~~~~~~
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_iterator.h:621:5: note:   template argument deduction/substitution failed:
&lt;source&gt;:61:62: note:   'std::__cxx11::basic_string&lt;char&gt;' is not derived from 'const std::reverse_iterator&lt;_IteratorL&gt;'
   61 |     { return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x - p.x, y - p.y }; }
      |                                                            ~~^~~~~
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_iterator.h:1778:5: note: candidate: 'template&lt;class _IteratorL, class _IteratorR&gt; constexpr decltype ((__x.base() - __y.base())) std::operator-(const move_iterator&lt;_IteratorL&gt;&amp;, const move_iterator&lt;_IteratorR&gt;&amp;)'
 1778 |     operator-(const move_iterator&lt;_IteratorL&gt;&amp; __x,
      |     ^~~~~~~~
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_iterator.h:1778:5: note:   template argument deduction/substitution failed:
&lt;source&gt;:61:62: note:   'std::__cxx11::basic_string&lt;char&gt;' is not derived from 'const std::move_iterator&lt;_IteratorL&gt;'
   61 |     { return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x - p.x, y - p.y }; }
      |                                                            ~~^~~~~
&lt;source&gt;:61:71: error: no match for 'operator-' (operand types are 'std::__cxx11::basic_string&lt;char&gt;' and 'const std::__cxx11::basic_string&lt;char&gt;')
   61 |     { return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x - p.x, y - p.y }; }
      |                                                                     ~~^~~~~
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_iterator.h:621:5: note: candidate: 'template&lt;class _IteratorL, class _IteratorR&gt; constexpr decltype ((__y.base() - __x.base())) std::operator-(const reverse_iterator&lt;_IteratorL&gt;&amp;, const reverse_iterator&lt;_IteratorR&gt;&amp;)'
  621 |     operator-(const reverse_iterator&lt;_IteratorL&gt;&amp; __x,
      |     ^~~~~~~~
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_iterator.h:621:5: note:   template argument deduction/substitution failed:
&lt;source&gt;:61:71: note:   'std::__cxx11::basic_string&lt;char&gt;' is not derived from 'const std::reverse_iterator&lt;_IteratorL&gt;'
   61 |     { return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x - p.x, y - p.y }; }
      |                                                                     ~~^~~~~
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_iterator.h:1778:5: note: candidate: 'template&lt;class _IteratorL, class _IteratorR&gt; constexpr decltype ((__x.base() - __y.base())) std::operator-(const move_iterator&lt;_IteratorL&gt;&amp;, const move_iterator&lt;_IteratorR&gt;&amp;)'
 1778 |     operator-(const move_iterator&lt;_IteratorL&gt;&amp; __x,
      |     ^~~~~~~~
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_iterator.h:1778:5: note:   template argument deduction/substitution failed:
&lt;source&gt;:61:71: note:   'std::__cxx11::basic_string&lt;char&gt;' is not derived from 'const std::move_iterator&lt;_IteratorL&gt;'
   61 |     { return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x - p.x, y - p.y }; }
      |                                                                     ~~^~~~~
&lt;source&gt;:61:77: error: no matching function for call to 'Point&lt;std::__cxx11::basic_string&lt;char&gt; &gt;::Point(&lt;brace-enclosed initializer list&gt;)'
   61 |     { return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x - p.x, y - p.y }; }
      |                                                                             ^
&lt;source&gt;:20:15: note: candidate: 'constexpr Point&lt;T&gt;::Point(Point&lt;T&gt;&amp;&amp;) [with T = std::__cxx11::basic_string&lt;char&gt;]'
   20 |     constexpr Point(Point&amp;&amp; p) noexcept
      |               ^~~~~
&lt;source&gt;:20:15: note:   candidate expects 1 argument, 2 provided
&lt;source&gt;:16:15: note: candidate: 'constexpr Point&lt;T&gt;::Point(const Point&lt;T&gt;&amp;) [with T = std::__cxx11::basic_string&lt;char&gt;]'
   16 |     constexpr Point(const Point&amp; p) noexcept
      |               ^~~~~
&lt;source&gt;:16:15: note:   candidate expects 1 argument, 2 provided
&lt;source&gt;:12:5: note: candidate: 'constexpr Point&lt;T&gt;::Point(T, T) [with T = std::__cxx11::basic_string&lt;char&gt;]'
   12 |     Point(T x, T y) noexcept
      |     ^~~~~
&lt;source&gt;:12:5: note:   conversion of argument 1 would be ill-formed:
&lt;source&gt;:9:15: note: candidate: 'constexpr Point&lt;T&gt;::Point() [with T = std::__cxx11::basic_string&lt;char&gt;]'
    9 |     constexpr Point() = default;
      |               ^~~~~
&lt;source&gt;:9:15: note:   candidate expects 0 arguments, 2 provided
Execution build compiler returned: 1
</code></pre>
<p><a href="https://www.godbolt.org/z/P9b3EMGdY">Example</a></p>
<p>To address this C++20 introduced concepts. A mechanism for imposing constraints on types.</p>
<h2 id="what-is-a-concept"><a class="header" href="#what-is-a-concept">What is a Concept?</a></h2>
<p>A concepts is a set of conditions and requirements imposed on a type that is checked at compile time and evaluates as a Boolean. Before C++20, template metaprogramming and SFINAE where used to statically impose constraints on types but they had limitations and were highly verbose. Concepts allow us to define syntactic constraints on a template type and then impose those constraints on other types. Concepts are introduced using a template declaration followed by a concept declaration (similar to a class declaration but replace the keyword <code>class</code> with <code>concept</code>). Concepts can be composed of other concepts using <code>||</code> and <code>&amp;&amp;</code> (holding similar semantics to there Boolean equivalents). It is difficult to create meaningful concepts as one, they are very new to both C++ but also programming in general, instead try and use the concepts defined by the standard library; from the <code>&lt;concepts&gt;</code> header, first and impose them on a case by case basis using the techniques we are going to learn below.</p>
<pre><code class="language-cxx">#include &lt;concepts&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;utility&gt;

/// Concept defining a type that can be hashed using `std::hash`
template&lt;typename H&gt;
concept Hashable = requires (H a)
{
    { std::hash&lt;H&gt;{}(a) } -&gt; std::convertible_to&lt;std::size_t&gt;;
};

struct NotHashable {};

using namespace std::literals;

auto main() -&gt; int
{
   std::cout &lt;&lt; std::boolalpha;
   std::cout &lt;&lt; &quot;Is Hashable&lt;int&gt;:          &quot; &lt;&lt; Hashable&lt;int&gt; &lt;&lt; &quot;  : std::hash&lt;int&gt;{}(69)               = &quot; &lt;&lt; std::hash&lt;int&gt;{}(69) &lt;&lt; std::endl;
   std::cout &lt;&lt; &quot;Is Hashable&lt;float&gt;:        &quot; &lt;&lt; Hashable&lt;float&gt; &lt;&lt; &quot;  : std::hash&lt;float&gt;{}(4.5756f)        = &quot; &lt;&lt; std::hash&lt;float&gt;{}(4.5756f) &lt;&lt; std::endl;
   std::cout &lt;&lt; &quot;Is Hashable&lt;double&gt;:       &quot; &lt;&lt; Hashable&lt;double&gt; &lt;&lt; &quot;  : std::hash&lt;double&gt;{}(-0.0036565764) = &quot; &lt;&lt; std::hash&lt;double&gt;{}(-0.0036565764) &lt;&lt; std::endl;
   std::cout &lt;&lt; &quot;Is Hashable&lt;std::string&gt;:  &quot; &lt;&lt; Hashable&lt;std::string&gt; &lt;&lt; &quot;  : std::hash&lt;std::string&gt;{}()         = &quot; &lt;&lt; std::hash&lt;std::string&gt;{}(&quot;&quot;s) &lt;&lt; std::endl;
   std::cout &lt;&lt; &quot;Is Hashable&lt;NotHashable&gt;:  &quot; &lt;&lt; Hashable&lt;NotHashable&gt; &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/Px75v8ssf">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/concepts"><code>&lt;concepts&gt;</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/constraints">Constraints and concepts</a></li>
</ul>
<h2 id="constrained-templates"><a class="header" href="#constrained-templates">Constrained templates</a></h2>
<p>Concepts are easiest to use when constraining templates type parameters. Instead of the using the keyword <code>typename</code> when can instead use a concept. This will impose the rules on the template type at the point of instantiation. We can see this best with our <code>Point</code> class. Being that a 'point' is a numerical value in a field; say coordinates on a cartesian plane we might want to restrict the type parameter <code>T</code> of <code>Point</code> to a number type. C++'s concepts library already has a concept for this called <code>std::integral</code>. Lets impose this new template type parameter constraint on <code>T</code>.</p>
<pre><code class="language-cxx">template&lt;std::integral T&gt;
class Point
{
    /// ... implementation
};

using namespace std::literals;

auto main() -&gt; int
{
   auto p1 = Point{ &quot;Hello&quot;s, &quot;Hi&quot;s };

    return 0;
}
</code></pre>
<p>While C++ error messages aren't the most readable as the compiler tries many different things, amongst the errors is one stating 'template constraint failed ...'. This indicates to use that <code>std::string</code> is not an appropriate type for <code>Point</code> without needed to try and subtract two <code>Point&lt;std::string&gt;</code> or any other operation on it. The instantiation failed at construction.</p>
<pre><code class="language-sh"># ... other error info

&lt;source&gt;: In substitution of 'template&lt;class T&gt; Point(T, T)-&gt; Point&lt;T&gt; [with T = std::__cxx11::basic_string&lt;char&gt;]':
&lt;source&gt;:94:37:   required from here
&lt;source&gt;:13:5: error: template constraint failure for 'template&lt;class T&gt;  requires  integral&lt;T&gt; class Point'
&lt;source&gt;:13:5: note: constraints not satisfied
In file included from &lt;source&gt;:1:
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/concepts: In substitution of 'template&lt;class T&gt;  requires  integral&lt;T&gt; class Point [with T = std::__cxx11::basic_string&lt;char&gt;]':
&lt;source&gt;:13:5:   required by substitution of 'template&lt;class T&gt; Point(T, T)-&gt; Point&lt;T&gt; [with T = std::__cxx11::basic_string&lt;char&gt;]'
&lt;source&gt;:94:37:   required from here
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/concepts:100:13:   required for the satisfaction of 'integral&lt;T&gt;' [with T = std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;]
/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/concepts:100:24: note: the expression 'is_integral_v&lt;_Tp&gt; [with _Tp = std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;]' evaluated to 'false'
  100 |     concept integral = is_integral_v&lt;_Tp&gt;;

# ... Other error info
</code></pre>
<p><a href="https://www.godbolt.org/z/1f1x8MTer">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/concepts/integral"><code>std::integral</code></a></p>
<h2 id="requires-expressions"><a class="header" href="#requires-expressions">Requires expressions</a></h2>
<p>The is a slight problem with our reformed <code>Point</code> class. It no longer can accept floating point types as they are not considered integrals in C++. Instead we need to constraint <code>Point</code> to a type <code>T</code> by creating a conjunction (<code>&amp;&amp;</code>) or disjunction (<code>||</code>) of multiple concepts. To do this we use a requires clause. Requires clause are introduced just after (often syntactically below) a template declaration and consist of a list of requirements in the form of a Boolean concept expression. We can create a disjunction of the <code>std::integral</code> and <code>std::floating_point</code> allowing floating point types and integral types to be valid <code>T</code> for <code>Point</code>.</p>
<pre><code class="language-cxx">template&lt;typename T&gt;
    requires std::integral&lt;T&gt; || std::floating_point&lt;T&gt;
class Point
{
    /// ... implementation
};

auto main() -&gt; int
{
   auto p1 = Point{ 0.567, 45.657 };
   auto p2 = Point{ 1, 9 };

   std::cout &lt;&lt; p1 + p2 &lt;&lt; std::endl;
   std::cout &lt;&lt; p1 - p2 &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<blockquote>
<p>Note: We could specify a more desirable constraint using the <code>std::is_arithmetic_v</code> type trait as a concept combines the two ideas better semantically but fine tuning <code>Point</code> can be an exercise for you.</p>
</blockquote>
<p><a href="https://www.godbolt.org/z/55dhT6W6j">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/concepts/floating_point"><code>std::floating_point</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/language/constraints#:%7E:text=on%20constraint%20normalization.-,Requires%20clauses,-The%20keyword"><code>requires</code> clause</a></li>
</ul>
<h3 id="requires-expression"><a class="header" href="#requires-expression">Requires expression</a></h3>
<p>Sometimes more complicated requirements need to be specified in order to fine the allowed behaviour of the program. Require expressions allow for mock values of template types to bne created and specify patterns that a value of the type parameter must provide. In the case of our <code>Point</code> class, we may want to also allow other types that support <code>+</code> and <code>-</code> binary operator overloads. Because this check depends on the type parameter of another <code>Point</code> we can't declare it at the requires clause at the template declaration of <code>Point</code>. Instead we need to create a requires clause at the operator overloads template declaration. We then declare our requires expression, enforcing the semantic and syntactic rules on the type. We can declare as many of these rules in a requires expression as we like. For <code>Point</code> we will ensure that for a value of type <code>T</code> called <code>a</code> and for a value of type <code>U</code> of name <code>b</code>, <code>a + b</code> and <code>a - b</code> is valid.</p>
<pre><code class="language-cxx">/// ... Point details

template&lt;typename U&gt;
    requires requires (T a, U b)
    {
        a + b;
    }
constexpr auto
operator+ (const Point&lt;U&gt;&amp; p) 
    noexcept -&gt; Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;
{ return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x + p.x, y + p.y }; }

template&lt;typename U&gt;
    requires requires (T a, U b)
    {
        a - b;
    }
constexpr auto
operator- (const Point&lt;U&gt;&amp; p) 
    noexcept -&gt; Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;
{ return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x - p.x, y - p.y }; }

/// ... Point details
</code></pre>
<blockquote>
<p>Note: The double <code>requires requires</code> notation is called an ad-hoc constraint. The first <code>requires</code> introduces a requires clause which can have concepts, conjunctions, disjunctions or requires expressions. The second <code>require</code> introduces a requires expression which takes a similar syntactic form to functions.</p>
</blockquote>
<p><a href="https://www.godbolt.org/z/763Y6fjjc">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/requires"><code>requires</code> expression</a></p>
<h3 id="compound-requirements"><a class="header" href="#compound-requirements">Compound requirements</a></h3>
<p>We can also apply constraints on the expressions within a requires expression, ensuring the types or properties these expressions will have. These are called compound expressions, which we create by wrapping our individual rules from a requires expression in braces and use a <code>-&gt;</code> followed by a constraint on the return type of the expression.</p>
<pre><code class="language-cxx">/// ... Point details

template&lt;typename U&gt;
    requires requires (T a, U b)
    {
        { a + b } -&gt; std::same_as&lt;typename std::common_type&lt;T, U&gt;::type&gt;;
    }
constexpr auto
operator+ (const Point&lt;U&gt;&amp; p) 
    noexcept -&gt; Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;
{ return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x + p.x, y + p.y }; }

template&lt;typename U&gt;
    requires requires (T a, U b)
    {
        { a - b } -&gt; std::same_as&lt;typename std::common_type&lt;T, U&gt;::type&gt;;
    }
constexpr auto
operator- (const Point&lt;U&gt;&amp; p) 
    noexcept -&gt; Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;
{ return Point&lt;typename std::common_type&lt;T, U&gt;::type&gt;{ x - p.x, y - p.y }; }

/// ... Point details
</code></pre>
<p><a href="https://www.godbolt.org/z/nqxoE7466">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/language/requires#:%7E:text=%3B%20%0A%7D%3B-,Compound%20Requirements,-A%20compound%20requirement">Compound requirements</a></p>
<p><a href="chapter5//content/chapter5/tasks/concepts.html">Version 3 of <code>Point</code></a></p>
<h2 id="constrained-variables"><a class="header" href="#constrained-variables">Constrained variables</a></h2>
<p>We can also use concepts to constrain variables declared with the <code>auto</code> specifier. Gives a more robust option for constraining function and method parameters without the need for template declarations or requires clauses.</p>
<pre><code class="language-cxx">#include &lt;concepts&gt;
#include &lt;iostream&gt;

auto println(const std::integral auto&amp; v) -&gt; void
{ std::cout &lt;&lt; v &lt;&lt; std::endl; }

auto main() -&gt; int
{
    println(9);
    // println(46.567);  ///&lt; fails

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/vcGW1qPY9">Example</a></p>
<blockquote>
<p>Note: We've applied concepts at the user definition level for classes. These concepts [ideas] can be applied to template functions as well. They are also the basic for defining your own concepts.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="task-2--templated-triple"><a class="header" href="#task-2--templated-triple">Task 2 : Templated Triple</a></h1>
<p>Having learnt about classes, templates and concepts I want you to reimplement your <code>Triple</code> class so that it behaves more like a standard type and has a more sophisticated implementation and interface. Similar to Assignment 1, you will submit using a pull request on GitHub to this repo.</p>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<ul>
<li>Must be templated for a single type <code>T</code></li>
<li>A way to add two points of different <code>T</code></li>
<li>A way to subtract two points of different <code>T</code></li>
<li>A way to multiply a point by a scalar of different <code>T</code></li>
<li>A way to divide a point by a scalar of different <code>T</code></li>
<li>A way to be print a formatted output using <code>std::cout</code></li>
<li>Using concepts ensure that <code>T</code> satisfies only:
<ul>
<li><code>std::integral</code></li>
</ul>
</li>
<li>or
<ul>
<li><code>std::floating_point</code></li>
</ul>
</li>
<li>or
<ul>
<li><code>T</code> and <code>U</code> support
<ul>
<li><code>T + U</code></li>
<li><code>T - U</code></li>
<li><code>U * T</code></li>
<li><code>T / U</code></li>
</ul>
</li>
<li>and doesn't support
<ul>
<li><code>is_pointer</code></li>
<li><code>is_reference</code></li>
<li><code>is_enum</code> etc.</li>
</ul>
</li>
</ul>
</li>
<li>and
<ul>
<li><code>T</code> supports <code>&lt;&lt;</code> to an <code>std::ostream</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>Note: Let me know if the concept requirements are confusing</p>
</blockquote>
<h3 id="bonus-1"><a class="header" href="#bonus-1">Bonus</a></h3>
<ul>
<li>A way to be created using input from <code>std::cin</code></li>
<li>Allow three different type parameter; say <code>T</code>, <code>U</code> and <code>V</code> for the member variables while still maintaining the base requirements [hard]</li>
</ul>
<h3 id="submitting-1"><a class="header" href="#submitting-1">Submitting</a></h3>
<p>You can use Godbolt or bpt to build and test your struct. Once you have created your implementation:</p>
<ul>
<li>Clone this repo using <code>git clone https://github.com/MonashDeepNeuron/HPP.git</code>.</li>
<li>Create a new branch using <code>git checkout -b triple/&lt;your-name&gt;</code>.</li>
<li>Create a folder in the <code>/submissions</code> directory with your name.</li>
<li>Create a folder with the name of this task.</li>
<li>Copy your mini project into this directory (bpt setup, cmake scripts etc.) with a <code>README.md</code> or comment in the code on how to run the program (verify it still works). There is a sample header file in <code>/templates</code> that you can use.</li>
<li>Go to <a href="https://github.com/MonashDeepNeuron/HPP/pulls">https://github.com/MonashDeepNeuron/HPP/pulls</a> and click 'New pull request'.</li>
<li>Change the branches in the drop down so that your branch is going into <code>main</code> and `Create new pull request.</li>
<li>Give the pull request a title and briefly describe what you were able to implement and any struggles you had.</li>
<li>On the right side-panel, under the 'Assignees' section, click the cog and assign me.</li>
<li>Click 'Create pull request' and I'll take it from there.</li>
</ul>
<blockquote>
<p>Note: If you created a GodBolt instance, put the link in a comment at the top of the file (under your copy comments). This is generated by clicking the <code>share</code> button in the top-right-most corner of the webpage and clicking the 'short link' option.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slides-4"><a class="header" href="#slides-4">Slides</a></h1>
<p><img src="chapter5/./imgs/hpp_chapter5-01.png" alt="Slides 01" />
<img src="chapter5/./imgs/hpp_chapter5-02.png" alt="Slides 02" />
<img src="chapter5/./imgs/hpp_chapter5-03.png" alt="Slides 03" />
<img src="chapter5/./imgs/hpp_chapter5-04.png" alt="Slides 04" />
<img src="chapter5/./imgs/hpp_chapter5-05.png" alt="Slides 05" />
<img src="chapter5/./imgs/hpp_chapter5-06.png" alt="Slides 06" />
<img src="chapter5/./imgs/hpp_chapter5-07.png" alt="Slides 07" />
<img src="chapter5/./imgs/hpp_chapter5-08.png" alt="Slides 08" />
<img src="chapter5/./imgs/hpp_chapter5-09.png" alt="Slides 09" />
<img src="chapter5/./imgs/hpp_chapter5-10.png" alt="Slides 10" />
<img src="chapter5/./imgs/hpp_chapter5-11.png" alt="Slides 11" />
<img src="chapter5/./imgs/hpp_chapter5-12.png" alt="Slides 12" />
<img src="chapter5/./imgs/hpp_chapter5-13.png" alt="Slides 13" />
<img src="chapter5/./imgs/hpp_chapter5-14.png" alt="Slides 14" />
<img src="chapter5/./imgs/hpp_chapter5-15.png" alt="Slides 15" />
<img src="chapter5/./imgs/hpp_chapter5-16.png" alt="Slides 16" />
<img src="chapter5/./imgs/hpp_chapter5-17.png" alt="Slides 17" />
<img src="chapter5/./imgs/hpp_chapter5-18.png" alt="Slides 18" />
<img src="chapter5/./imgs/hpp_chapter5-19.png" alt="Slides 19" />
<img src="chapter5/./imgs/hpp_chapter5-20.png" alt="Slides 20" />
<img src="chapter5/./imgs/hpp_chapter5-21.png" alt="Slides 21" />
<img src="chapter5/./imgs/hpp_chapter5-22.png" alt="Slides 22" />
<img src="chapter5/./imgs/hpp_chapter5-23.png" alt="Slides 23" />
<img src="chapter5/./imgs/hpp_chapter5-24.png" alt="Slides 24" />
<img src="chapter5/./imgs/hpp_chapter5-25.png" alt="Slides 25" />
<img src="chapter5/./imgs/hpp_chapter5-26.png" alt="Slides 26" />
<img src="chapter5/./imgs/hpp_chapter5-27.png" alt="Slides 27" />
<img src="chapter5/./imgs/hpp_chapter5-28.png" alt="Slides 28" />
<img src="chapter5/./imgs/hpp_chapter5-29.png" alt="Slides 29" />
<img src="chapter5/./imgs/hpp_chapter5-30.png" alt="Slides 30" />
<img src="chapter5/./imgs/hpp_chapter5-31.png" alt="Slides 31" />
<img src="chapter5/./imgs/hpp_chapter5-32.png" alt="Slides 32" />
<img src="chapter5/./imgs/hpp_chapter5-33.png" alt="Slides 33" />
<img src="chapter5/./imgs/hpp_chapter5-34.png" alt="Slides 34" />
<img src="chapter5/./imgs/hpp_chapter5-35.png" alt="Slides 35" />
<img src="chapter5/./imgs/hpp_chapter5-36.png" alt="Slides 36" />
<img src="chapter5/./imgs/hpp_chapter5-37.png" alt="Slides 37" />
<img src="chapter5/./imgs/hpp_chapter5-38.png" alt="Slides 38" />
<img src="chapter5/./imgs/hpp_chapter5-39.png" alt="Slides 39" />
<img src="chapter5/./imgs/hpp_chapter5-40.png" alt="Slides 40" />
<img src="chapter5/./imgs/hpp_chapter5-41.png" alt="Slides 41" />
<img src="chapter5/./imgs/hpp_chapter5-42.png" alt="Slides 42" />
<img src="chapter5/./imgs/hpp_chapter5-43.png" alt="Slides 43" />
<img src="chapter5/./imgs/hpp_chapter5-44.png" alt="Slides 44" />
<img src="chapter5/./imgs/hpp_chapter5-45.png" alt="Slides 45" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algorithms--data-structures"><a class="header" href="#algorithms--data-structures">Algorithms &amp; Data Structures</a></h1>
<p>So far you have learnt a lot about the C++ language from user-defined types with classes, to generic programming with templates and concepts as well as (almost) all of the languages primitive types, control flow and looping mechanisms. With all of this you can pretty much get a computer to do anything. However, this is only the foundation; mind you all taught at once, what comes next is the fun chapter. We cover some the of facilities, techniques and practices focused on actually manipulating data and performing actual computation. Many of these facilities are available in the C++ standard library; after all this isn't C, we don't have to build everything from scratch. This will include everything from building up your algorithm intuition to exploring different data structures and how they work under the hood. We will also cover topics such as evaluation techniques, function composition and lifting.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<h2 id="what-is-an-iterator"><a class="header" href="#what-is-an-iterator">What is an iterator?</a></h2>
<p>An iterator is an abstraction for representing an item, element, value etc. in a collection or container of values that also has some notion how to get to a obtain or yield a new item from the container. In C++ iterators a lot like pointers in the sense that they hold some value, usually the location of it and has a means of either yielding the value for reading or allows for writing to that value.</p>
<h2 id="iterator-categories"><a class="header" href="#iterator-categories">Iterator Categories</a></h2>
<p>There are 6 main iterator categories considered in C++. Each subsequent iterator category builds upon the previous categories requirements with increasingly more requirements.</p>
<table>
<thead>
  <tr>
    <th rowspan="2">Iterator Category</th>
    <th colspan="7">Valid Operations</th>
  </tr>
  <tr>
    <th>write</th>
    <th>read</th>
    <th>increment</th>
    <th>multiple passes</th>
    <th>decrement</th>
    <th>random access</th>
    <th>contiguous storage</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>Output</td>
    <td>✅</td>
    <td></td>
    <td>✅</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>Input</td>
    <td>might support writing</td>
    <td>✅</td>
    <td>✅</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>Forward<br>(Satisfies Input)</td>
    <td>✅</td>
    <td>✅</td>
    <td>✅</td>
    <td>✅</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>Bidirectional<br>(Satisfies Forward)</td>
    <td>✅</td>
    <td>✅</td>
    <td>✅</td>
    <td>✅</td>
    <td>✅</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>Random Access<br>(Satisfies Bidirectional)</td>
    <td>✅</td>
    <td>✅</td>
    <td>✅</td>
    <td>✅</td>
    <td>✅</td>
    <td>✅</td>
    <td></td>
  </tr>
  <tr>
    <td>Contiguous<br>(Satisfies Random Access)</td>
    <td>✅</td>
    <td>✅</td>
    <td>✅</td>
    <td>✅</td>
    <td>✅</td>
    <td>✅</td>
    <td>✅</td>
  </tr>
</tbody>
</table>
<blockquote>
<p>Note: A pointer actually satisfies the Contiguous Iterator Category</p>
</blockquote>
<p>Before C++20, there were empty structs used as tags to help categorise an iterator into its respective category. Since C++ there have been concepts introduces to perform this check more elegantly along with other iterator-related concepts to all for anything modelling an iterator to satisfy the constraints.</p>
<h2 id="obtaining-iterators"><a class="header" href="#obtaining-iterators">Obtaining Iterators</a></h2>
<p>Almost all collections or containers have iterators to their first and last element. To obtain these iterator from any container kinds we call the <code>std::begin()</code> and <code>std::end</code> functions from the <code>&lt;iterator&gt;</code> header respectively. There are also constant and reverse and constant reverse versions of the functions.</p>
<pre><code class="language-cxx">#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;

auto main() -&gt; int
{
    auto a = std::to_array&lt;int&gt;({1, 3, 4, 565, 868, 5, 46});
    
    std::cout &lt;&lt; std::begin(a) &lt;&lt; std::endl;
    std::cout &lt;&lt; *std::begin(a) &lt;&lt; std::endl;
    std::cout &lt;&lt; std::end(a) &lt;&lt; std::endl;
    std::cout &lt;&lt; *(std::end(a) - 1) &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/MG7q3d63a">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/header/iterator"><code>&lt;iterator&gt;</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/begin"><code>std::begin()</code> &amp; <code>std::cbegin()</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/end"><code>std::end()</code> &amp; std::cend()`</a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/rbegin"><code>std::rbegin()</code> &amp; std::crbegin()`</a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/rend"><code>std::rend()</code> &amp; std::crend()`</a></li>
</ul>
<h2 id="iterator-functionalities"><a class="header" href="#iterator-functionalities">Iterator Functionalities</a></h2>
<p>There are a few ways to interact with an iterator directly. One is to use the overloaded operators for the iterator object. Most iterators implement and overload the same operator set that is used by pointers. The other way is to use functions to interact with iterators, allowing for a more generic interface if a iterator doesn't support the common operator overload set and the implementer preferred to overload the functions. The only way to yield or write to the item held by an iterator is to use the dereference operator <code>*</code>.</p>
<h3 id="common-operator-interface"><a class="header" href="#common-operator-interface">Common Operator Interface</a></h3>
<table><thead><tr><th align="center">Operation</th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody>
<tr><td align="center">dereference</td><td align="center"><code>*i</code></td><td align="center"><code>*i = v</code></td><td align="center"><code>v = *i</code></td></tr>
<tr><td align="center">increment</td><td align="center"><code>i++</code></td><td align="center"><code>++i</code></td><td align="center"></td></tr>
<tr><td align="center">decrement</td><td align="center"><code>i--</code></td><td align="center"><code>--i</code></td><td align="center"></td></tr>
<tr><td align="center">difference</td><td align="center"><code>i - j</code></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center">advance</td><td align="center"><code>i + n</code></td><td align="center"><code>i - n</code></td><td align="center"></td></tr>
<tr><td align="center">index</td><td align="center"><code>i[n]</code></td><td align="center"></td><td align="center"></td></tr>
</tbody></table>
<blockquote>
<p>Note: Where <code>i</code> is an iterator object</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;

auto main() -&gt; int
{
    auto a  = std::to_array&lt;int&gt;({1, 3, 4, 565, 868, 5, 46});
    auto it = std::begin(a);

    std::cout &lt;&lt; *it &lt;&lt; std::endl;
    std::cout &lt;&lt; *(it++) &lt;&lt; std::endl;
    std::cout &lt;&lt; *(++it) &lt;&lt; std::endl;
    std::cout &lt;&lt; *(it--) &lt;&lt; std::endl;
    std::cout &lt;&lt; *(--it) &lt;&lt; std::endl;
    std::cout &lt;&lt; *(it + 4) &lt;&lt; std::endl;
    std::cout &lt;&lt; *(std::end(a) - 4) &lt;&lt; std::endl;
    std::cout &lt;&lt; it[6] &lt;&lt; std::endl;

    auto v { *it };
    *it = 757657;
    std::cout &lt;&lt; v &lt;&lt; std::endl;
    std::cout &lt;&lt; *it &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/jeGjnrWvn">Example</a></p>
<h3 id="iterator-functions"><a class="header" href="#iterator-functions">Iterator Functions</a></h3>
<p>There are four functions involved in manipulating an object of iterator kind. These are used to move an iterator between elements.</p>
<ul>
<li><code>std::next</code> - Obtains the next iterator from the passed iterator. Can be passed an integral <code>n</code> to obtain the <em>nth</em> next iterator. If <code>n</code> is negative, the iterator must satisfy <em>Bidirectional Iterator</em>.</li>
<li><code>std::prev</code>- Obtains the previous iterator from the pass iterator. Can be passed an integral to obtain the <em>nth</em> previous iterator. The iterator must satisfy the requirements of a <em>Bidirectional Iterator</em>.</li>
<li><code>std::distance</code> - Obtains the number of increments required by the first iterator to reach the second iterator.</li>
<li><code>std::advance</code> - Advances the passed iterator by <em>n</em> increments. If <em>n</em> is negative, the iterator must satisfy <em>Bidirectional Iterator</em>.</li>
</ul>
<pre><code class="language-cxx">#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;

auto main() -&gt; int
{
    auto a  = std::to_array&lt;int&gt;({1, 3, 4, 565, 868, 5, 46});
    auto it = std::begin(a);

    std::cout &lt;&lt; *it &lt;&lt; std::endl;
    std::cout &lt;&lt; *std::next(it) &lt;&lt; std::endl;
    std::cout &lt;&lt; *std::prev(it) &lt;&lt; std::endl;
    std::cout &lt;&lt; *std::next(it, 4) &lt;&lt; std::endl;

    auto end = std::end(a);

    std::cout &lt;&lt; *std::next(end, -4) &lt;&lt; std::endl;

    std::cout &lt;&lt; std::distance(it, end - 3) &lt;&lt; std::endl;

    std::advance(it, 3);
    std::cout &lt;&lt; *it &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/P17PEnsaE">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/iterator/next"><code>std::next()</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/prev"><code>std::prev()</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/distance"><code>std::distance()</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/advance"><code>std::advance()</code></a></li>
</ul>
<h2 id="sentinels"><a class="header" href="#sentinels">Sentinels</a></h2>
<p>Iterators are able to move through a container indefinitely however this can lead to iterators being dereferenced for a value that doesn't belong to the container. To fix this, we need some notion of the end of a container. Sentinels are a kind that behaves like a marker representing the end of a container. There are many different things you can use as a sentinel from specific values that appear in a container (<code>\0</code> is used as a sentinel for char slices in C), to iterators. Before C++20, the 'end' iterator was the most common sentinel kind used. The iterator holds the item that is one-past-the-end of a container. When another iterator reaches it the container has been exhausted. Since C++20, the notion of the end of a container has been formalised to be sentinels over 'end' iterators. This allows for containers to be infinite with an unreachable sentinel type or have regular bounds.</p>
<pre><code class="language-cxx">#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;

auto main() -&gt; int
{
    auto a = std::to_array&lt;int&gt;({1, 3, 4, 565, 868, 5, 46});
    
    /// Uses the iterator obtained by `std::end` from `a` as sentinel
    for (auto it = std::begin(a); it != std::end(a); ++it)
        std::cout &lt;&lt; *it &lt;&lt; (std::distance(it, std::end(a)) - 1 ? &quot;, &quot; : &quot;&quot;);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/9dzsjn1eM">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/iterator/default_sentinel_t"><code>std::default_sentinel_t</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/unreachable_sentinel_t"><code>std::unreachable_sentinel_t</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/move_sentinel"><code>std::move_sentinel&lt;S&gt;</code></a></li>
</ul>
<h2 id="iterator-adaptors"><a class="header" href="#iterator-adaptors">Iterator Adaptors</a></h2>
<p>There are a few iterator adaptors in the C++ standard library allowing for regular iterators, often supplied by container kind types have certain operational semantics. This include a reverse, inserter, counted and move iterators. This allows for efficient operations between containers and containers to be implemented through iterators. Many of these iterators come with a factory function (often prefixed with <code>make_</code>) that can make the desired iterator and perform the necessary argument type deductions.</p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/iterator/reverse_iterator"><code>std::reverse_iterator</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/move_iterator"><code>std::move_iterator</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/common_iterator"><code>std::common_iterator</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/counted_iterator"><code>std::counted_iterator</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/back_insert_iterator"><code>std::back_insert_iterator</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/front_insert_iterator"><code>std::front_insert_iterator</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/insert_iterator"><code>std::insert_iterator</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/istream_iterator"><code>std::istream_iterator</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/ostream_iterator"><code>std::ostream_iterator</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/istreambuf_iterator"><code>std::istreambuf_iterator</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/iterator/ostreambuf_iterator"><code>std::ostreambuf_iterator</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h1>
<h2 id="what-is-a-data-structure"><a class="header" href="#what-is-a-data-structure">What is a Data Structure</a></h2>
<p>Data structures are a fundamental concept in computer science. Data structures are types or classes used to organise and manage data. Data structures differ primarily by their internal means of organising the data they manage to be as optimal as possible and often support various different operations. Using the correct data structure can be a difficult question to answer, particularly in C++ where many operation on these most basic data structures are expected to have as little size and time overhead.</p>
<p>This section mostly goes into a high level look at the data structures or containers available in C++, how they work and to give an idea of when one might use them. All containers have methods for obtaining iterators to their first and last element and all work with a <em>range-for</em> loop.</p>
<h2 id="sequence-containers"><a class="header" href="#sequence-containers">Sequence Containers</a></h2>
<p>Sequence containers are <em>Array-Like</em> containers in the sense that they model their data as a 1D array of values. Along with slices and <code>std::array</code>, C++ offers four other sequence based containers.</p>
<h3 id="vector"><a class="header" href="#vector">Vector</a></h3>
<p><code>std::vector</code> is the most fundamental container in C++. It models a contiguous dynamic array. It has constant (\( O(1) \)) index-based random access to elements. Vectors offer random access insertion and erasure of elements as well as efficient pushing and popping of elements at the end of the vector. Indexing is <strong>0-based</strong> which is the same for all index based containers. Insertion and erasure is less efficient anywhere in the vector that is not the back (\( O(n) \) where \( n \) is the number elements past the insertion or erasure) as all elements past the insertion or erasure have to be moved back one cell. Insertion and erasure also (has a chance of [invalidating]) invalidates any iterators or references of the shifted elements. Vectors can reserve more memory then it currently uses in order to make any operations involving potential allocations more efficient by pre-allocating the resources. Erasures also do not remove the memory owned by the vector but save it for later use.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;vector&gt;

template&lt;typename T&gt;
auto println(const std::vector&lt;T&gt;&amp; v) -&gt; void
{
    std::cout &lt;&lt; &quot;[ &quot;;
    for (auto i { v.size() }; const auto&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; (--i ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; ]&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 1, 2, 3, 4, 5 };

    println(v);
    v.push_back(6);
    println(v);
    v.pop_back();
    v.pop_back();
    println(v);
    v.insert(v.begin() + 3, 77);
    println(v);
    v.erase(v.end() - 4);
    println(v);

    std::cout &lt;&lt; &quot;v[4] = &quot; &lt;&lt; v[4] &lt;&lt; std::endl;        ///&lt; Unsafe version
    std::cout &lt;&lt; &quot;v.at(2) = &quot; &lt;&lt; v.at(2) &lt;&lt; std::endl;  ///&lt; Range checked

    std::cout &lt;&lt; &quot;Before v.shrink_to_fit()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; v.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Capacity: &quot; &lt;&lt; v.capacity() &lt;&lt; std::endl;
    println(v);

    v.shrink_to_fit();

    std::cout &lt;&lt; &quot;After v.shrink_to_fit()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; v.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Capacity: &quot; &lt;&lt; v.capacity() &lt;&lt; std::endl;
    println(v);

    v.clear();
    std::cout &lt;&lt; &quot;After v.clear()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; v.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Capacity: &quot; &lt;&lt; v.capacity() &lt;&lt; std::endl;
    println(v);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/sYhf5rG6r">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/vector"><code>std::vector</code></a></p>
<h3 id="deque"><a class="header" href="#deque">Deque</a></h3>
<p><code>std::deque</code> is a double ended queue that offers efficient (\( O(1) \)) insertion and erasure at both the front and back of a deque while also never invalidating iterators and references to the rest of the elements. Deques elements are not stored contiguously resulting in a larger memory footprint due to 'book-keeping' data for smaller deques when compared to vectors. Deques also have two indirections to get elements compared to vectors single indirection. Deques also cannot reserve extra memory for later use.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;deque&gt;

template&lt;typename T&gt;
auto println(const std::deque&lt;T&gt;&amp; dq) -&gt; void
{
    std::cout &lt;&lt; &quot;[&gt; &quot;;
    for (auto i { dq.size() }; const auto&amp; e : dq)
        std::cout &lt;&lt; e &lt;&lt; (--i ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; &lt;]&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto dq = std::deque&lt;int&gt;{ 1, 2, 3, 4, 5 };

    println(dq);
    dq.push_back(6);
    println(dq);
    dq.pop_back();
    dq.pop_back();
    println(dq);
    dq.push_front(33);
    dq.push_front(914);
    dq.push_front(-44);
    dq.push_front(0);
    println(dq);
    dq.pop_front();
    dq.pop_front();
    println(dq);

    dq.insert(dq.begin() + 3, 77);
    println(dq);
    dq.erase(dq.end() - 4);
    println(dq);

    std::cout &lt;&lt; &quot;dq[4] = &quot; &lt;&lt; dq[4] &lt;&lt; std::endl;        ///&lt; Unsafe version
    std::cout &lt;&lt; &quot;dq.at(2) = &quot; &lt;&lt; dq.at(2) &lt;&lt; std::endl;  ///&lt; Range checked

    std::cout &lt;&lt; &quot;Before dq.shrink_to_fit()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; dq.size() &lt;&lt; std::endl;
    println(dq);

    dq.shrink_to_fit();

    std::cout &lt;&lt; &quot;After dq.shrink_to_fit()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; dq.size() &lt;&lt; std::endl;
    println(dq);

    dq.clear();
    std::cout &lt;&lt; &quot;After dq.clear()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; dq.size() &lt;&lt; std::endl;
    println(dq);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/Tnx49fajv">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/deque"><code>std::deque</code></a></p>
<h3 id="forward-list"><a class="header" href="#forward-list">Forward List</a></h3>
<p><code>std::forward_list</code> is an implementation of a singly-linked-list offering fast access, insertion and erasure to the beginning of the list. Forward lists also allows for easy merging of two sorted lists as well as operations for reversing and sorting the list. Insertion and erasure has <code>_after</code> semantics meaning that these operations occur to the element after the passed iterator.
Forward lists are not indexable.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;forward_list&gt;

template&lt;typename T&gt;
auto println(const std::forward_list&lt;T&gt;&amp; f_lst) -&gt; void
{
    std::cout &lt;&lt; &quot;[ &quot;;
    for (auto i { std::distance(f_lst.cbegin(), f_lst.cend()) }; const auto&amp; e : f_lst)
        std::cout &lt;&lt; e &lt;&lt; (--i ? &quot; -&gt; &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; ]&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto f_lst = std::forward_list&lt;int&gt;{ 1, 2, 3, 4, 5 };

    println(f_lst);
    f_lst.push_front(33);
    f_lst.push_front(914);
    f_lst.push_front(-44);
    f_lst.push_front(0);
    println(f_lst);
    f_lst.pop_front();
    f_lst.pop_front();
    println(f_lst);

    f_lst.insert_after(f_lst.begin(), 77);
    println(f_lst);
    f_lst.erase_after(f_lst.begin());
    println(f_lst);
    f_lst.clear();
    println(f_lst);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/Y5c4z67Pz">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/forward_list"><code>std::forward_list</code></a></p>
<h3 id="list"><a class="header" href="#list">List</a></h3>
<p>Along with a singly-linked-list C++ offers a doubly-linked-list called <code>std::list</code>. This offers constant (\( O(1) \)) insertion and erasure anywhere within the container with the biggest benefits occurring at the beginning and end of the list. Lists allow for bidirectional iteration through the container. Iterators and references are not invalidated during insertion and erasure except for the element that got erased.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;list&gt;

template&lt;typename T&gt;
auto println(const std::list&lt;T&gt;&amp; lst) -&gt; void
{
    std::cout &lt;&lt; &quot;[ &quot;;
    for (auto i { lst.size() }; const auto&amp; e : lst)
        std::cout &lt;&lt; e &lt;&lt; (--i ? &quot; &lt;-&gt; &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; ]&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto lst = std::list&lt;int&gt;{ 1, 2, 3, 4, 5 };

    println(lst);
    lst.push_back(6);
    println(lst);
    lst.pop_back();
    lst.pop_back();
    println(lst);
    lst.push_front(33);
    lst.push_front(914);
    lst.push_front(-44);
    lst.push_front(0);
    println(lst);
    lst.pop_front();
    lst.pop_front();
    println(lst);

    lst.insert(lst.begin(), 77);
    println(lst);
    lst.erase(++lst.begin());
    println(lst);

    lst.clear();
    std::cout &lt;&lt; &quot;After lst.clear()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; lst.size() &lt;&lt; std::endl;
    println(lst);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/YfoWacKcK">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/list"><code>std::list</code></a></p>
<h3 id="a-harsh-truth"><a class="header" href="#a-harsh-truth">A harsh truth</a></h3>
<p>While many of these sequences offer a variety of different ways to organise data and offer different performance guarantees to fit different needs when it comes to searching, insertion and erasure, the harsh reality is often this doesn't matter outside of semantics. 99.9% of the time (I'm exaggerating a bit) the best data structure; particularly for sequences based organisation of data, are vectors. Even for searching, sorting, insertion and erasure. This is because computers are so much faster then they were two decades ago and CPU's have much larger (L2) caches. What does this have to do with it? Well, computer memory is sequential in nature meaning that all data that is stored contiguously. Copying, allocating and transfer of sequential memory is almost always faster as the CPU will often vectorize the operation, assuming that it can move sequential from memory to the cache even if it doesn't explicitly know this. Compare this to other data structures, particularly linked-lists which 'optimise' insertion and erasure by having nodes of data spread out throughout memory, removing the restriction on the data needing to be contiguous. What this actually does is prevent the CPU from predicting what memory it might use maximizing the opportunity for a cache miss to occur which is much slower than copying more data. Copies are cheap, especially for <code>std::vector</code> as it contains only three pointers. One to the start of the data, one to the end of the used memory and one to the end of the owned memory. All of this pointers are reachable from each other. To get to the data, it costs one pointer indirection to the data and one jump of size <code>n</code> to the desired value. This jump happens in constant time as the CPU will already know exactly how many bytes over this is (exactly $n \cdot sizeof(element)$) and can add this directly to the pointer to the start of the data. If the CPU can figure out that memory near the current memory being fetched will ned to be fetched as well it will take as much as it can from the region, optimising the IO the CPU does which is one of the largest bottlenecks of performance. Compare this to many pointer indirections that have to go into getting a single node from a linked list. Not to mention the CPU has no way of determining where the next memory it needs might be, increasing the fetching time the CPU execute. Not to mention that is has to make room in its cache and eject memory every time it reads.</p>
<p>What does this all mean? Don't think too much about which data structure is best based on the \( BigO \) complexities. Start with using vectors and arrays and adapt your programs to use specific data structures as you need. After all; for C++, the \( BigO \) complexity are minimum requirements for the standard library that must be met by a particular implementation and not their real world average performance. That is not to say that linked lists or deques do not have there uses. Linked lists are used in the Linux kernel to connect and organise related data. It looks very different to lists in C++ but has a pretty intuitive implementation and use. It is implemented as a intrusive linked list. How this works is that a data structure will have a member that is node containing a pointer to the previous and next node. The benefit to this is that the list is not tied to any type as the nodes don't hold any data themselves, instead the data holds information on how to get to the nxe or previous node. This list structure is used everywhere in the Linux kernel and is very efficient.</p>
<h2 id="associative-containers"><a class="header" href="#associative-containers">Associative Containers</a></h2>
<p>Associative containers are used for sorted data. They allow for very fast searching as well as efficient insertion, erasure and access. Associative containers work by ordering keys and (sometimes) mapping values to these keys.</p>
<h3 id="set"><a class="header" href="#set">Set</a></h3>
<p><code>std::set</code> is an ordered collections of unique keys usually sorted in ascending order. Search, insertion and erasure occur in logarithmic time (\( O(\log{n}) \)). Sets also offer merging operations for combining two sets into a single set with all elements merged and sorted. Sets can be accessed using extraction methods that moves the <em>node-type</em> that owns the key value out of the set and gives it to the caller.</p>
<blockquote>
<p>Note: <em>node-type</em> is an exposition only type that is implemented as chapter of the set. It is not to be used as an independent type.</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;set&gt;

template&lt;typename T&gt;
auto println(const std::set&lt;T&gt;&amp; st) -&gt; void
{
    std::cout &lt;&lt; &quot;{ &quot;;
    for (auto i { st.size() }; const auto&amp; e : st)
        std::cout &lt;&lt; e &lt;&lt; (--i ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; }&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto st = std::set&lt;int&gt;{ 1, 2, 3, 4, 5 };

    st.insert(77);
    println(st);
    st.erase(++st.begin());
    println(st);

    std::cout &lt;&lt; &quot;st.extract(++st.begin()).value() = &quot; &lt;&lt; st.extract(++st.begin()).value() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;st.extract(5).value() = &quot; &lt;&lt; st.extract(5).value() &lt;&lt; std::endl;
    println(st);

    st.merge(std::set&lt;int&gt;{ -1, 5, 4, 2, 0, 8, 6 });
    std::cout &lt;&lt; &quot;After st.merge(...): &quot; &lt;&lt; std::endl;
    println(st);

    st.clear();
    std::cout &lt;&lt; &quot;After st.clear()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; st.size() &lt;&lt; std::endl;
    println(st);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/P8E99q43c">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/set"><code>std::set</code></a></p>
<h3 id="map"><a class="header" href="#map">Map</a></h3>
<p><code>std::map</code> is the most general associative container available in C++. Maps are made up of ordered key value pairs with strictly unique key values. Searching, key-indexing, insertion and erasure of elements is logarithmic (\( O(\log{n}) \)) in time. Values are obtained using the associated key using indexing syntax. It also offers similar extraction and merging functionalities as sets. Maps in C++ are typically implemented as <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-Black Trees</a>.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

template&lt;typename K, typename V&gt;
auto println(const std::map&lt;K, V&gt;&amp; m) -&gt; void
{
    std::cout &lt;&lt; &quot;[ &quot;;
    for (auto i { m.size() }; const auto&amp; [k, v] : m)
        std::cout &lt;&lt; k &lt;&lt; &quot;: &quot; &lt;&lt; v &lt;&lt; (--i ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; ]&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto m = std::map&lt;std::string, int&gt;{ {&quot;z&quot;, 1}, {&quot;f&quot;, 2}, {&quot;a&quot;, 3}, {&quot;g&quot;, 4}, {&quot;x&quot;, 5} };

    println(m);
    m[&quot;a&quot;] = 5;         ///&lt; Can read, write and insert
    println(m);
    m[&quot;q&quot;] = 7;
    println(m);
    m.at(&quot;g&quot;) = 265;    ///&lt; Can only be used for read or write, not insert
    println(m);
    m.insert({&quot;w&quot;, 77});
    println(m);
    m.insert_or_assign(&quot;w&quot;, 354658);
    println(m);

    m.erase(&quot;a&quot;);
    println(m);
    m.erase(++m.begin());
    println(m);

    m.clear();
    std::cout &lt;&lt; &quot;After m.clear()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; m.size() &lt;&lt; std::endl;
    println(m);

    return 0;
}
</code></pre>
<blockquote>
<p>Note: In the <em>range-for</em> if <code>println()</code>, you may notice a weird syntax for the element. Because iterators to <code>std::map</code> yield a <code>std::pair</code> we can destructure it straight into individual variables using structured bindings.</p>
</blockquote>
<p><a href="https://www.godbolt.org/z/Wb5xPhraq">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/map"><code>std::map</code></a></p>
<h3 id="multiset--multimap"><a class="header" href="#multiset--multimap">Multiset &amp; Multimap</a></h3>
<p>Along with the regular set and map classes, C++ offers <code>std::multiset</code> and <code>std::multimap</code> which hold ordered keys (and values) but allow for duplicate keys. They offer pretty much the exact same interface as the key-exclusive counterparts except that the order of duplicate keys is the same order as their insertion. This order between duplicates remains constant unless the node holding a particular key (and value) is extracted and it's ownership given to the caller. Searching, insertion and erasure take logarithmic time (\( O(\log{n}) \)).</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

template&lt;typename K, typename V&gt;
auto println(const std::multimap&lt;K, V&gt;&amp; m) -&gt; void
{
    std::cout &lt;&lt; &quot;{ &quot;;
    for (auto i { m.size() }; const auto&amp; [k, v] : m)
        std::cout &lt;&lt; k &lt;&lt; &quot;: &quot; &lt;&lt; v &lt;&lt; (--i ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; }&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto mm = std::multimap&lt;std::string, int&gt;{ {&quot;z&quot;, 12}, {&quot;f&quot;, 2}, {&quot;a&quot;, 3}, {&quot;g&quot;, 4}, {&quot;x&quot;, 5} };

    println(mm);
    mm.insert({&quot;z&quot;, 77});
    println(mm);

    mm.erase(&quot;a&quot;);
    println(mm);
    mm.erase(++mm.begin());
    println(mm);

    mm.clear();
    std::cout &lt;&lt; &quot;After mm.clear()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; mm.size() &lt;&lt; std::endl;
    println(mm);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/ro5MaxeEG">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/multiset"><code>std::multiset</code></a>
<a href="https://en.cppreference.com/w/cpp/container/multimap"><code>std::multimap</code></a></p>
<h2 id="unordered-associative-containers"><a class="header" href="#unordered-associative-containers">Unordered Associative Containers</a></h2>
<p>Unordered associative containers are data structures that do not sort their key values but instead use a hashing function to create bucket based access to elements. Hashing functions are designed to avoid hash collisions however, many hashed data structures account for hash collisions. Hashing is the process of computing a discrete hash value for a key indicating the index in an internalised array or <em>bucket</em>. Which bucket a key (and value) is placed in relies solely on the result of hashing that key, with keys creating duplicate hash results being placed in the same bucket (typically).</p>
<h3 id="unordered-set"><a class="header" href="#unordered-set">Unordered Set</a></h3>
<p><code>std::unordered_set</code> is the first of our unordered associative containers. Unlike sets, hashed sets do not need to order their keys. Searching, insertion and erasure in a hashed set occurs in constant time (\( O(1) \)). Elements of a hashed set cannot be changes as this would invalidate the hash table. Instead erasure and insertion must be used instead.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;unordered_set&gt;
#include &lt;string&gt;

template&lt;typename K&gt;
auto println(const std::unordered_set&lt;K&gt;&amp; ust) -&gt; void
{
    std::cout &lt;&lt; &quot;{ &quot;;
    for (auto i { ust.size() }; const auto&amp; k : ust)
        std::cout &lt;&lt; k &lt;&lt; (--i ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; }&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto ust = std::unordered_set&lt;std::string&gt;{ &quot;z&quot;, &quot;f&quot;, &quot;a&quot;, &quot;g&quot;, &quot;x&quot; };

    println(ust);
    ust.insert(&quot;k&quot;);
    println(ust);

    ust.erase(&quot;a&quot;);
    println(ust);
    ust.erase(++ust.begin());
    println(ust);

    std::cout &lt;&lt; &quot;Loading Factor: &quot; &lt;&lt; ust.load_factor() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Max Loading Factor: &quot; &lt;&lt; ust.max_load_factor() &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; ust.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;# Buckets: &quot; &lt;&lt; ust.bucket_count() &lt;&lt; std::endl;
    ust.insert(&quot;m&quot;);
    println(ust);
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; ust.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;# Buckets: &quot; &lt;&lt; ust.bucket_count() &lt;&lt; std::endl;

    auto bckt = ust.bucket(&quot;f&quot;);  ///&lt; returns index of bucket
    std::cout &lt;&lt; &quot;Bucket Size: &quot; &lt;&lt; ust.bucket_size(bckt) &lt;&lt; std::endl;

    ust.clear();
    std::cout &lt;&lt; &quot;After ust.clear()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; ust.size() &lt;&lt; std::endl;
    println(ust);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/G97n97r3G">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/unordered_set"><code>std::unordered_set</code></a></p>
<h3 id="unordered-map"><a class="header" href="#unordered-map">Unordered Map</a></h3>
<p><code>std::unordered_map</code> is a hashed version of a regular map but like its hash set counterpart, instead of ordering keys it uses a hashing functions to create an index into buckets. Search, insertion and erasure all happen in constant time (\( O(1) \)). Unlike hashed sets, values can be accessed and inserted using key-based indexing.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;

template&lt;typename K, typename V&gt;
auto println(const std::unordered_map&lt;K, V&gt;&amp; umap) -&gt; void
{
    std::cout &lt;&lt; &quot;{ &quot;;
    for (auto i { umap.size() }; const auto&amp; [k, v] : umap)
        std::cout &lt;&lt; k &lt;&lt; &quot;: &quot; &lt;&lt; v &lt;&lt; (--i ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; }&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto umap = std::unordered_map&lt;std::string, int&gt;{ {&quot;z&quot;, 12}, {&quot;f&quot;, 2}, {&quot;a&quot;, 3}, {&quot;g&quot;, 4}, {&quot;x&quot;, 5} };

    println(umap);
    umap[&quot;h&quot;] = 576;
    println(umap);
    umap.at(&quot;f&quot;) = 368548;
    println(umap);

    println(umap);
    umap.insert({&quot;k&quot;, 56});
    println(umap);

    umap.erase(&quot;a&quot;);
    println(umap);
    umap.erase(++umap.begin());
    println(umap);

    std::cout &lt;&lt; &quot;Loading Factor: &quot; &lt;&lt; umap.load_factor() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Max Loading Factor: &quot; &lt;&lt; umap.max_load_factor() &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; umap.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;# Buckets: &quot; &lt;&lt; umap.bucket_count() &lt;&lt; std::endl;
    umap.insert({&quot;m&quot;, 78});
    println(umap);
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; umap.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;# Buckets: &quot; &lt;&lt; umap.bucket_count() &lt;&lt; std::endl;

    auto bckt = umap.bucket(&quot;f&quot;);  ///&lt; returns index of bucket
    std::cout &lt;&lt; &quot;Bucket Size: &quot; &lt;&lt; umap.bucket_size(bckt) &lt;&lt; std::endl;

    umap.clear();
    std::cout &lt;&lt; &quot;After umap.clear()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; umap.size() &lt;&lt; std::endl;
    println(umap);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/qj5bq9fze">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/unordered_map"><code>std::unordered_map</code></a></p>
<h3 id="unordered-multiset--multimap"><a class="header" href="#unordered-multiset--multimap">Unordered Multiset &amp; Multimap</a></h3>
<p>Much like how there are sets and maps that can store duplicate keys, there are hashed versions of these data structures called <code>std::unordered_multiset</code> and <code>std::unordered_multimap</code> respectively. Search, insertion and erasure occur in constant time (\( O(n) \)). Hashed multimaps cannot be accessed using key-based indexing as it cannot be determined which key to return if duplicates exist.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;

template&lt;typename K, typename V&gt;
auto println(const std::unordered_multimap&lt;K, V&gt;&amp; ummap) -&gt; void
{
    std::cout &lt;&lt; &quot;{ &quot;;
    for (auto i { ummap.size() }; const auto&amp; [k, v] : ummap)
        std::cout &lt;&lt; k &lt;&lt; &quot;: &quot; &lt;&lt; v &lt;&lt; (--i ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; }&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto ummap = std::unordered_multimap&lt;std::string, int&gt;{ {&quot;z&quot;, 1}, {&quot;f&quot;, 2}, {&quot;a&quot;, 3}, {&quot;g&quot;, 4}, {&quot;x&quot;, 5} };

    println(ummap);
    ummap.insert({&quot;w&quot;, 77});
    println(ummap);
    ummap.insert({&quot;w&quot;, 879});
    println(ummap);
    ummap.insert({&quot;w&quot;, -23});
    println(ummap);
    ummap.insert({&quot;w&quot;, 209538});
    println(ummap);

    std::cout &lt;&lt; &quot;Loading Factor: &quot; &lt;&lt; ummap.load_factor() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Max Loading Factor: &quot; &lt;&lt; ummap.max_load_factor() &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; ummap.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;# Buckets: &quot; &lt;&lt; ummap.bucket_count() &lt;&lt; std::endl;
    ummap.insert({&quot;m&quot;, 78});
    println(ummap);
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; ummap.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;# Buckets: &quot; &lt;&lt; ummap.bucket_count() &lt;&lt; std::endl;

    auto bckt = ummap.bucket(&quot;w&quot;);  ///&lt; returns index of bucket
    std::cout &lt;&lt; &quot;Bucket Size: &quot; &lt;&lt; ummap.bucket_size(bckt) &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;w: { &quot;;
    auto i { ummap.bucket_size(bckt) };
    for (auto it = ummap.begin(bckt); it != ummap.end(bckt); ++it)
        std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot;: &quot; &lt;&lt; it-&gt;second &lt;&lt; (--i ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; }&quot; &lt;&lt; std::endl;

    ummap.erase(&quot;a&quot;);
    println(ummap);
    ummap.erase(++ummap.begin());
    println(ummap);

    ummap.clear();
    std::cout &lt;&lt; &quot;After ummap.clear()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; ummap.size() &lt;&lt; std::endl;
    println(ummap);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/heKfcz6K1">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/unordered_multiset"><code>std::unordered_multiset</code></a>
<a href="https://en.cppreference.com/w/cpp/container/unordered_multimap"><code>std::unordered_multimap</code></a></p>
<h2 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h2>
<h3 id="bitset"><a class="header" href="#bitset">Bitset</a></h3>
<p><code>std::bitset</code> allows for efficient storage of individually addressable bits. The size of a bitset is fixed at compile time allowing for bitsets to be evaluated in <code>constexpr</code> context. The standard bit manipulation operators are available for bitwise manipulation between bitsets. Bitset also allow for single bit access as well as testing of single or all bits in the bitset. Bitsets also have conversion methods for obtaining the string, and integral representations of the bits. Bitsets can be constructed from string representations of bits or or from binary literal integrals. The bit to the right is the least significant bit ie. the first bit.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;bitset&gt;
#include &lt;string&gt;

template&lt;std::size_t N&gt;
auto println(const std::bitset&lt;N&gt;&amp; b) -&gt; void
{ std::cout &lt;&lt; &quot;0b&quot; &lt;&lt; b &lt;&lt; std::endl; }

auto main() -&gt; int
{
    auto b = std::bitset&lt;6&gt;(0b011010uLL);

    println(b);
    b[2] = true;
    println(b);
    b.set(4) = false;

    b.flip(0);
    println(b);
    b.flip();
    println(b);
    b.reset();
    println(b);

    std::cout &lt;&lt; std::boolalpha;
    std::cout &lt;&lt; (b.test(5) == false) &lt;&lt; std::endl;
    std::cout &lt;&lt; b.any() &lt;&lt; std::endl;
    std::cout &lt;&lt; b.all() &lt;&lt; std::endl;
    std::cout &lt;&lt; b.none() &lt;&lt; std::endl;
    std::cout &lt;&lt; std::noboolalpha;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/1qnYTWxMb">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/utility/bitset"><code>std::bitset</code></a></p>
<h3 id="any"><a class="header" href="#any">Any</a></h3>
<p><code>std::any</code> is a unique data structure that can hold any <em>Copy-Constructable</em> type. It can also be changed to any new type simply through assignment. You can introspect the type contained as well as destroy the contained object. The only way to access the contained value is through an <code>std::any_cast&lt;&gt;</code> which will yield the value which is cast to the template type of the any cast. Any also comes with a factory function for creating a any object.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;any&gt;

template&lt;typename T&gt;
auto println(const std::any&amp; a) -&gt; void
{ std::cout &lt;&lt; std::any_cast&lt;T&gt;(a) &lt;&lt; std::endl; }

auto main() -&gt; int
{
    auto a = std::make_any&lt;int&gt;(6);

    println&lt;int&gt;(a);
    a.emplace&lt;double&gt;(6.797898);
    println&lt;double&gt;(a);    

    std::cout &lt;&lt; a.type().name() &lt;&lt; std::endl; 

    std::cout &lt;&lt; std::boolalpha;
    std::cout &lt;&lt; a.has_value() &lt;&lt; std::endl;
    a.reset();
    std::cout &lt;&lt; a.has_value() &lt;&lt; std::endl;
    std::cout &lt;&lt; std::noboolalpha;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/n57nYonqs">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/utility/any"><code>std::any</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algorithms"><a class="header" href="#algorithms">Algorithms</a></h1>
<h2 id="what-is-an-algorithm"><a class="header" href="#what-is-an-algorithm">What is an algorithm?</a></h2>
<p>What is an algorithm? The simplest definition is that is is a function. The longer definition is that an algorithm is a set of instructions that occur in a finite number of steps. Algorithms are used to manipulate data, perform computation or even perform introspection on data. Powerful algorithms when paired with efficient data structures are what make programs. So far we have seen how to create our own data structures in C++ through classes and concepts. We have also seen the data structures already offered by C++, we will now look at how you can use any algorithm available in C++ with all of these data structures and perform computation (almost) entirely independent of how it is organised.</p>
<h3 id="algorithm-intuition"><a class="header" href="#algorithm-intuition">Algorithm Intuition</a></h3>
<p>This section is not really about how to implement any particular algorithm. Instead it is aimed at building what is called algorithm intuition. This focuses not on how I do make an algorithm that performs the steps X, Y and Z to some data, taking into account A, B and C but rather on knowing about existing algorithms, what they do and how you can piece and compose different algorithms together to create a more general solution. This idea of composition is a super power to programming as it enables creating solutions from smaller reusable components.</p>
<h2 id="the-standard-template-library"><a class="header" href="#the-standard-template-library">The Standard Template Library</a></h2>
<p>The C++ algorithms library as it stands today was created by the brilliant mind of <a href="https://en.wikipedia.org/wiki/Alexander_Stepanov">Alexander Stepanov</a>. Alex Stepanov was a pioneer in practical generic programming and created what is known as the Standard Template Library (STL). The STL was the predecessor to everything in the C++ Standard Library that uses templates which is almost everything. The biggest edition to the C++ standard from the STL was the container and algorithm libraries. All algorithms in C++ use iterator pairs (with identical types), one to the beginning of a sequence and one to the end. This means that any container just has to provide an iterator to its first and last elements and any algorithm can work with it. A pair of iterators is called a range in C++. All algorithms take at least a pair of iterators with some taking more.</p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm"><code>&lt;algorithm&gt;</code></a></p>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<p>The most general algorithm is <code>std::for_each</code>. This algorithm can take a single ranges and an unary function that will be applied to each element. <code>std::for_each</code> is often used to replace for-loops in certain context, mostly when a function has a side effect.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 1, 2, 3, 4, 5 };

    std::for_each(v.begin(), v.end(), [](const auto&amp; e){ std::cout &lt;&lt; e &lt;&lt; ' '; });

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/W1croE686">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/for_each"><code>std::for_each</code></a></p>
<h2 id="sorting"><a class="header" href="#sorting">Sorting</a></h2>
<p>Sorting is a very common operation in programming. It allows us to more efficiently search for particular elements and guarantee certain properties and relationships between elements. In C++ there are a few different kinds of sorting algorithms including partitioning and introspection of data.</p>
<h3 id="sort"><a class="header" href="#sort">Sort</a></h3>
<p><code>std::sort</code> is C++ sorting algorithm. Along with the input range, it can also take in a predicate (a binary function returning a Boolean) which is used for the comparison. This defaults to <code>&lt;</code> making <code>std::sort</code> sort in ascending order. <code>std::sort</code> sorts in-place and is often implemented as an Introsort algorithm.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 2, 576, -3, 678, 3, -2543, 6 };

    println(v);
    std::sort(v.begin(), v.end());
    println(v);

    std::sort(v.begin(), v.end(), std::greater&lt;&gt;{});
    println(v);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/d9K618hhn">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/sort"><code>std::sort</code></a></p>
<h3 id="partition"><a class="header" href="#partition">Partition</a></h3>
<p>Partitioning is the process of sorting elements based on a predicate such that any element for which the predicate is <code>true</code> precedes any element for which the predicate is <code>false</code>. This can be used to separate evens and odds or positive and negatives or even implement quicksort. The individual partitions are not necessarily sorted.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ -1, 2, -3, -4, 5 };

    println(v);
    std::partition(v.begin(), v.end(), [](const auto&amp; e){ return e % 2 == 0; });
    println(v);

    std::partition(v.begin(), v.end(), [](const auto&amp; e){ return e &gt; 0; });
    println(v);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/48jfqqdcd">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/partition"><code>std::partition</code></a></p>
<h3 id="nth-element"><a class="header" href="#nth-element">Nth Element</a></h3>
<p><code>std::nth_element</code> sorts a range such that the element pointed to by nth is the element that would occur in that position if the range was sorted. <code>std::nth_element</code> is a partial sorting algorithm.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ -24, 573, -3, 677, 3, -2543, 6 };

    println(v);
    auto m = v.begin() + (v.size() / 2);
    std::nth_element(v.begin(), m, v.end());
    std::cout &lt;&lt; v[v.size() / 2] &lt;&lt; std::endl;
    println(v);

    std::nth_element(v.begin(), v.end() - 2, v.end(), std::greater&lt;&gt;{});
    std::cout &lt;&lt; *(v.end() - 2) &lt;&lt; std::endl;
    println(v);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/GM1rrW68P">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/nth_element"><code>std::nth_element</code></a></p>
<h2 id="searching"><a class="header" href="#searching">Searching</a></h2>
<p>More often than not, you do not know anything about which values actually exists in your range. This is why searching algorithms are important chapter of computer programming. They allow us to find elements what we need or handle the case when they do not exist.</p>
<h3 id="find"><a class="header" href="#find">Find</a></h3>
<p><code>std::find</code> is used to find a particular value in range. returning the iterator to its location. It is not very efficient but is the most general searcher.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 1, 2, 3, 4, 5 };

    println(v);
    auto result1 = std::find(v.begin(), v.end(), 3);
    auto result2 = std::find(v.begin(), v.end(), 68);
    
    (result1 == v.end() ? std::cout &lt;&lt; 3 &lt;&lt; &quot; not found&quot; &lt;&lt; std::endl
                        : std::cout &lt;&lt; 3 &lt;&lt; &quot; found at &quot; &lt;&lt; std::distance(v.begin(), result1) &lt;&lt; std::endl);

    (result2 == v.end() ? std::cout &lt;&lt; 68 &lt;&lt; &quot; not found&quot; &lt;&lt; std::endl
                        : std::cout &lt;&lt; 68 &lt;&lt; &quot; found at &quot; &lt;&lt; std::distance(v.begin(), result2) &lt;&lt; std::endl);
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/KhqvGao43">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/find"><code>std::find</code></a></p>
<h3 id="search"><a class="header" href="#search">Search</a></h3>
<p><code>std::search</code> is used fo find the first occurrence of a subsequence in a range. <code>std::search</code> can also be passed a different searcher to change how it searches for the subsequence.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 1, 2, 3, 4, 5 };
    auto s = std::vector&lt;int&gt;{ 2, 3, 4 };

    println(v);
    println(s);
    auto result = std::search(v.begin(), v.end(), s.begin(), s.end());
    
    (result == v.end() ? std::cout &lt;&lt; &quot;sequence { 2, 3, 4 } not found&quot; &lt;&lt; std::endl
                       : std::cout &lt;&lt; &quot;sequence { 2, 3, 4 } found at offset &quot; &lt;&lt; std::distance(v.begin(), result) &lt;&lt; std::endl);

    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/51cqjG8Pb">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/search"><code>std::</code></a></p>
<h3 id="adjacent-find"><a class="header" href="#adjacent-find">Adjacent Find</a></h3>
<p><code>std::adjacent_find</code> returns the location of the first pair of adjacent elements in a ranges that satisfy a predicate. The default predicate is <code>==</code>.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 1, 2, 3, 3, 4, 5 };

    println(v);
    auto result = std::adjacent_find(v.begin(), v.end());
    
    (result == v.end() ? std::cout &lt;&lt; &quot;no equal adjacent elemnts&quot; &lt;&lt; std::endl
                       : std::cout &lt;&lt; &quot;first equal adjacent elements occured at offset: &quot; 
                                   &lt;&lt; std::distance(v.begin(), result) 
                                   &lt;&lt; &quot; with *result = &quot;
                                   &lt;&lt; *result
                                   &lt;&lt; std::endl);

    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/WMxqEezfn">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/adjacent_find"><code>std::adjacent_find</code></a></p>
<h3 id="binary-search"><a class="header" href="#binary-search">Binary Search</a></h3>
<p>Everyone knows the binary search algorithm however, <code>std::binary_search</code> is a little different. Instead of returning the location of the desired element it returns <code>true</code> if the desired value exists in the range and <code>false</code> otherwise. <code>std::binary_search</code> iin C++ is more commonly spelt <strong><em>in</em></strong>. <code>std::binary_search</code> one works on a partially ordered ranged with respect to the desired value. Partitioning with respect to the desired value is the minimum sorting requirement.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 1, 2, 3, 4, 5 };

    println(v);
    
    std::cout &lt;&lt; std::boolalpha
              &lt;&lt; &quot;Found 2? -- &quot; 
              &lt;&lt; std::binary_search(v.begin(), v.end(), 2)
              &lt;&lt; std::endl
              &lt;&lt; &quot;Found 6? -- &quot;
              &lt;&lt; std::binary_search(v.begin(), v.end(), 6)
              &lt;&lt; std::noboolalpha
              &lt;&lt; std::endl;

    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/xq7cerxYf">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/binary_search"><code>std::binary_search</code></a></p>
<h3 id="equal-range-lower-bound--upper-bound"><a class="header" href="#equal-range-lower-bound--upper-bound">Equal Range, Lower Bound &amp; Upper Bound</a></h3>
<p>These algorithms work on partitioned ranges with respect to some value (similar to <code>std::binary_search</code>). <code>std::equal_range</code> returns a pair of iterators representing the sub-range of elements that are equal to the desired value. <code>std::lower_bound</code> and <code>std::upper_bound</code> will return an iterator representing the first value do not satisfy a predicate (default <code>&lt;</code>) with the right argument always being the desired value for <code>std::lower_bound</code> and the left argument always being the desired value for <code>std::upper_bound</code>.</p>
<blockquote>
<p>Note: These algorithms are also member functions of all associative containers and some of the unordered associative containers.</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 1, 2, 3, 4, 4, 4, 5 };

    println(v);

    auto [eq1, eq2] = std::equal_range(v.begin(), v.end(), 4);
    auto lwbnd4 = std::lower_bound(v.begin(), v.end(), 4);
    auto upbnd4 = std::upper_bound(v.begin(), v.end(), 4);
    
    std::cout &lt;&lt; &quot;Range containing 4:&quot; &lt;&lt; std::endl;
    println(std::vector&lt;int&gt;(eq1, eq2));
    std::cout &lt;&lt; &quot;Lower bound of 4: &quot; &lt;&lt; *lwbnd4 &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Upper bound of 4: &quot; &lt;&lt; *upbnd4 &lt;&lt; std::endl;

    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/eTK3jaKb7">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/equal_range"><code>std::equal_range</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound"><code>std::lower_bound</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound"><code>std::upper_bound</code></a></li>
</ul>
<h2 id="modifiers"><a class="header" href="#modifiers">Modifiers</a></h2>
<p>Modifiers are the bread and butter of the algorithms library. They are used to modify the values of sequences sometimes in-place and other times using an output iterator that becomes the writer of the algorithm. The writer iterator can be the same iterator as the one representing the start of the input ranges as long as it supports write operations (assignment to). These algorithms will often return <code>void</code> for in-place modifications or return the end iterator of the output range.</p>
<h3 id="copy--move"><a class="header" href="#copy--move">Copy &amp; Move</a></h3>
<p>The copy and move algorithms are pretty self explanatory, they well copy of move the elements from one range to another. These algorithms eliminate 90% of the use of a manual for-loop and allow for copying and moving from completely different ranges, as long as the underlying copy of move is support ie. they types are copyable or movable.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v1 = std::vector&lt;std::string&gt;{ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; };
    auto v2 = std::vector&lt;std::string&gt;{};       ///&lt; Empty vector
    auto v3 = std::vector&lt;std::string&gt;(5, &quot;&quot;);  ///&lt; Preallocated memory

    println(v1);
    println(v2);
    println(v3);

    /// Use back inserted to push copies to the back 
    /// of the vector as v2 has no allocated memory
    std::copy(v1.begin(), v1.end(), std::back_inserter(v2));

    /// Can us v3 iterator directly as it has
    /// preallocated memory
    std::move(v1.begin(), v1.end(), v3.begin());
    std::cout &lt;&lt; std::endl;

    println(v1);
    println(v2);
    println(v3);
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/jrhM39hz4">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/copy"><code>std::copy</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/move"><code>std::move</code></a></li>
</ul>
<h3 id="swap-range"><a class="header" href="#swap-range">Swap Range</a></h3>
<p><code>std::swap_range</code> is a range based form of <code>std::swap</code>. It will swap the values of two ranges until the end of the first rnage is reached.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v1 = std::vector&lt;std::string&gt;{ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; };
    auto v2 = std::vector&lt;std::string&gt;{ &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot; };

    println(v1);
    println(v2);

    std::swap_ranges(v1.begin(), v1.end(), v2.begin());
    std::cout &lt;&lt; std::endl;

    println(v1);
    println(v2);
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/3eqcdfG4f">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/swap_ranges"><code>std::swap_ranges</code></a></p>
<h3 id="remove--replace"><a class="header" href="#remove--replace">Remove &amp; Replace</a></h3>
<p><code>std::remove</code> and <code>std::replace</code> are also fairly simple algorithms. They will remove or replace all instances of a particular value or replacing it with a new value respectively. <code>std::remove</code> doesn't actually free memory, usually it just moves any other value forward in the range. To free the removed memory, a call to <code>std::remove</code> is followed by a call to the containers erase method or <code>std::erase</code> (for sequence containers), taking the iterator returned by <code>std::remove</code> and the containers end iterator forming the <em>remove-erase idiom</em>.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 2, 3, 5, 1, 2, 2, 3, 4, 2, 5, 3 };

    println(v);
    auto r = std::remove(v.begin(), v.end(), 3);
    std::cout &lt;&lt; std::endl;
    println(v);
    v.erase(r, v.end());
    std::cout &lt;&lt; std::endl;
    println(v);
    std::replace(v.begin(), v.end(), 2, -2);
    std::cout &lt;&lt; std::endl;
    println(v);
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/Er64q3T3b">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/remove"><code>std::remove</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/replace"><code>std::replace</code></a></li>
</ul>
<h3 id="reverse"><a class="header" href="#reverse">Reverse</a></h3>
<p><code>std::reverse</code> is an in-place modifier that reverses the elements of the container by swapping iterators.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 1, 2, 3, 4, 5 };

    println(v);
    std::reverse(v.begin(), v.end());
    println(v);
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/cjT6vEd7M">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/reverse"><code>std::reverse</code></a></p>
<h3 id="transform"><a class="header" href="#transform">Transform</a></h3>
<p><code>std::transform</code> one of the most important algorithms in any programming language. <code>std::transform</code> will apply an unary function on every element in a range, writing it to a new output range. It also is overloaded to take an additional input iterator allowing for binary transformations. <code>std::transform</code> is most commonly spelt as <strong><em>map</em></strong> in Computer Science however, this name was taken be <code>std::map</code>.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v1 = std::vector&lt;int&gt;{ 0, 1, 2, 3, 4 };
    auto v2 = std::vector&lt;int&gt;{ 9, 8, 7, 6, 5 };

    println(v1);
    std::transform(v1.begin(), v1.end(), v1.begin(), [](const auto&amp; x){ return x * x; });
    println(v1);
    std::cout &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;  &quot;;
    println(v1);
    std::cout &lt;&lt; &quot;+ &quot;;
    println(v2);
    std::transform(v1.begin(), v1.end(),
                   v2.begin(), v1.begin(),
                   [](const auto&amp; x, const auto&amp; y){ return x + y; });
    std::cout &lt;&lt; &quot;= &quot;;
    println(v1);

    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/9n9WjerzG">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/transform"><code>std::transform</code></a></p>
<h3 id="rotate"><a class="header" href="#rotate">Rotate</a></h3>
<p><code>std::rotate</code> takes three iterators first, pivot and end respectively. As normal, first and end form the range the algorithm operates on while pivot is swapped such that it becomes the new starting element of the range and the element preceding the pivot becomes the new end of the range.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 0, 1, 2, 3, 4, 5, 6 };

    println(v);
    std::rotate(v.begin(), v.begin() + 3, v.end());
    println(v);

    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/YTnEn1o7d">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/rotate"><code>std::rotate</code></a></p>
<h3 id="sample"><a class="header" href="#sample">Sample</a></h3>
<p><code>std::sample</code> will sample \( n \) random elements a range without replacement such that each sampled element has an equal probability of appearing. <code>std::sample</code> takes in a random number generator from the <code>&lt;random&gt;</code> header in order to generate the random access.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    auto s = std::vector&lt;int&gt;(4);

    println(v);
    std::sample(v.begin(), v.end(),
                s.begin(), s.size(),
                std::mt19937{ std::random_device{}() });
    println(s);
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/rr6PPbb8a">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/sample"><code>std::sample</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/header/random"><code>&lt;random&gt;</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine"><code>std::mersenne_twister_engine</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/numeric/random">Pseudo-random number generation</a></li>
</ul>
<h3 id="shuffle"><a class="header" href="#shuffle">Shuffle</a></h3>
<p><code>std::shuffle</code> will randomly reorganize a range. Like <code>std::sample</code>, <code>std::shuffle</code> takes in a random number generator in order to randomly generate the index sequence.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

    println(v);
    std::shuffle(v.begin(), v.end(), std::mt19937{ std::random_device{}() });
    println(v);
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/cjY6W7cPe">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/"><code>std::shuffle</code></a></p>
<h2 id="numeric"><a class="header" href="#numeric">Numeric</a></h2>
<p>Numerical algorithms are powerful algorithms for performing numerical computation on ranges. Many of the numerical algorithms in C++ are specialised forms of a reduction. Reductions will take a range of values and reduce the the number of elements in the resulting range. Reductions often come in the form of a folding algorithm which take and initial value, a range and a binary function. They break a range of elements into a <em>Head</em> and <em>Tail</em> component, with the <em>Head</em> being the first element and <em>Tail</em> being the rest. There are two version folds called left and right folds. A left fold will apply the initial value along with the result of left folding the <em>Tail</em>; with <em>Head</em> being the new initial value, to the binary function. Right folds will invert this process applying <em>Head</em> and the result of right folding the <em>Tail</em> of the range; passing the initial value to the bottom of the fold, to the binary function. Folds spelt as reductions are often left folds with the initial value being the <em>Head</em> of the range.</p>
<p><a href="https://docs.google.com/spreadsheets/d/16isUb2rsuzSmkJLO_FtjGCzsQJOAeRKWARBUGn_mrHI/edit#gid=631619717">Fold</a></p>
<h3 id="minimums--maximums"><a class="header" href="#minimums--maximums">Minimums &amp; Maximums</a></h3>
<p>Minimum and maximum reductions are used to find the smallest and largest number in a range. In C++ these are spelt as <code>std::min_element</code>, <code>std::max_element</code>. These algorithms return an iterator to the element most satisfying the predicate which is defaulted to <code>&lt;</code> but can be customised. There is also <code>std::minmax_element</code> which returns a pair of iterators indicating the minimum and maximum element in a range.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 1, 3, 5, 0, 2, 6 };

    println(v);
    auto min1 = std::min_element(v.begin(), v.end());
    auto max1 = std::max_element(v.begin(), v.end());
    auto [min2, max2] = std::minmax_element(v.begin(), v.end());
    
    std::cout &lt;&lt; &quot;Min: &quot; &lt;&lt; *min1 &lt;&lt; &quot; @ &quot; &lt;&lt; std::distance(v.begin(), min1) &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Max: &quot; &lt;&lt; *max1 &lt;&lt; &quot; @ &quot; &lt;&lt; std::distance(v.begin(), max1) &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Min, Max: [&quot; 
              &lt;&lt; *min2 &lt;&lt; &quot;, &quot; &lt;&lt; *max2 
              &lt;&lt; &quot;] @ [&quot; 
              &lt;&lt; std::distance(v.begin(), min2)
              &lt;&lt; &quot;, &quot;
              &lt;&lt; std::distance(v.begin(), max2)
              &lt;&lt; &quot;]&quot;
              &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/G8Y9dchEv">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/min_element"><code>std::min_element</code></a>
<a href="https://en.cppreference.com/w/cpp/algorithm/max_element"><code>std::max_element</code></a>
<a href="https://en.cppreference.com/w/cpp/algorithm/minmax_element"><code>std::minmax_element</code></a></p>
<h3 id="count"><a class="header" href="#count">Count</a></h3>
<p><code>std::count</code> will count that number of occurrences of a particular value. The default predicate is <code>==</code> but it can be customised.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 2, 1, 3, 5, 2, 2, 3, 0, 2, 6, 2 };
    auto e = int{ 2 };

    println(v);
    std::cout &lt;&lt; &quot;Number of &quot; &lt;&lt; e &lt;&lt; &quot;'s = &quot; &lt;&lt; std::count(v.begin(), v.end(), e) &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/5xejqWf6s">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/count"><code>std::count</code></a></p>
<h3 id="clamp"><a class="header" href="#clamp">Clamp</a></h3>
<p><code>std::clamp</code> is a scalar algorithm (doesn't work for ranges) that will clamp a value between a set range. If the value is smaller then the lower bound it is clamped to the lower bound and if it is larger than the upper bound it clamps to the upper bound, returning the value otherwise. <code>std::clamp</code> is not a reduction.</p>
<blockquote>
<p>Note: If the return value is bound to a reference and the value is a temporary to the call to <code>std::clamp</code> the reference is dangling.</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto low = int{ 2 };
    auto high = int{ 3 };


    auto v = std::vector&lt;int&gt;{ 0, 1, 2, 3, 4, 5, 6 };

    println(v);
    std::transform(v.begin(), v.end(), v.begin(),
                   [&amp;](const auto&amp; x){ return std::clamp(x, low, high); });
    println(v);
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/q5sWsrK1x">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/clamp"><code>std::clamp</code></a></p>
<h3 id="accumulate"><a class="header" href="#accumulate">Accumulate</a></h3>
<p><code>std::accumulate</code> is the most general numeric algorithm and can be used to implement almost all of the algorithms in the C++ standard. Accumulate takes a range of values, an initial value and a binary function defaulting to <code>+</code>. Accumulate is most commonly spelt as left-fold or foldl. <code>std::accumulate</code> is one of the only algorithms that returns a value. One point to note about <code>std::accumulate</code> is that the initial values type is unrelated to the type of the range of elements. This can cause unintended side effects due to implicit conversions. <code>std::accumulate</code> is not found in <code>&lt;algorithm&gt;</code> but rather <code>&lt;numeric&gt;</code>.</p>
<blockquote>
<p>One algorithm <code>std::accumulate</code> should not try and model is function application or maps (ie. <code>std::transform</code>).</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    println(v);

    auto sum     = std::accumulate(v.begin(), v.end(), 0);
    auto product = std::accumulate(v.begin(), v.end(), 1, std::multiplies&lt;&gt;{});
    std::cout &lt;&lt; &quot;Sum of v = &quot; &lt;&lt; sum &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Product of v = &quot; &lt;&lt; product &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/v3jEMP4c1">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/accumulate"><code>std::accumulate</code></a></p>
<h3 id="inner-product"><a class="header" href="#inner-product">Inner Product</a></h3>
<p><code>std::inner_product</code> is a very powerful algorithm. It performs a binary transformation of two ranges and then performs a reduction on the resulting range. The most common form of this algorithm is known as the dot-product which applies the binary <code>*</code> on the two sets of coordinates and then a binary reduction on the resulting range using <code>+</code>. This is the default operation set for C++ <code>std::inner_product</code> but it can be customised to using any binary transformation and reduction. Like <code>std::accumulate</code> is takes an initial value which is applied to the and returns the result of the reduction. <code>std::inner_product</code> also lives in the <code>&lt;numeric&gt;</code> header.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 1, 3, 5, 7, 9 };
    auto u = std::vector&lt;int&gt;{ 0, 2, 4, 6, 8 };

    auto r = std::inner_product(v.begin(), v.end(), u.begin(), 0);

    std::cout &lt;&lt; &quot;v: &quot;;
    println(v);
    std::cout &lt;&lt; &quot;     x  x  x  x  x   + =&gt; &quot; &lt;&lt; r &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;u: &quot;;
    println(u);
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/schxqWbo3">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/inner_product"><code>std::inner_product</code></a></p>
<h3 id="partial-sum"><a class="header" href="#partial-sum">Partial Sum</a></h3>
<p><code>std::partial_sum</code> is another reduction algorithm but with a twist. Instead of reducing the range to a scalar, it partially reduces the range, saving the intermediate accumulation values. <code>std::partial_sum</code> does not take an initial but does take an iterator to the beginning of the output range. Returns the element pointing to one-past-the-end element of the output range. This algorithm is most commonly spelt as left scan or <code>scanl</code> (in particular <code>scanl1</code> due to it not taking an initial accumulator value).<code>std::partial_sum</code> is in the <code>&lt;numeric&gt;</code> header. The default binary function is <code>+</code>.</p>
<pre><code class="language-cxx">#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    auto u = std::vector&lt;int&gt;(v.size(), 0);
    auto w = std::vector&lt;int&gt;(v.size() - 1, 0);

    std::partial_sum(v.begin(), v.end(), u.begin());
    std::partial_sum(v.begin() + 1, v.end(), w.begin(), std::multiplies&lt;&gt;{});

    println(v);
    println(u);
    println(w);
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/YnWdvq1nv">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/partial_sum"><code>std::partial_sum</code></a></p>
<h3 id="adjacent-difference"><a class="header" href="#adjacent-difference">Adjacent Difference</a></h3>
<p><code>std::adjacent_difference</code> applies the the binary function <code>-</code> (by default) to every pair of neighboring elements writing them to a new range. This range begins at one after the passed output iterator.</p>
<pre><code class="language-cxx">#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 4, 6, 9, 13, 18, 19, 19, 15, 10 };
    auto u = std::vector&lt;int&gt;(v.size(), 0);
    auto w = std::vector&lt;int&gt;(v.size(), 0);
    w[0] = 1;

    std::adjacent_difference(v.begin(), v.end(), u.begin());
    std::adjacent_difference(w.begin(), std::prev(w.end()), std::next(w.begin()), std::plus&lt;&gt;{});

    println(v);
    println(u);
    std::cout &lt;&lt; std::endl &lt;&lt; &quot;Fibonacci: &quot;;
    println(w);
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/rbvK3P1ah">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/adjacent_difference"><code>std::adjacent_difference</code></a></p>
<h2 id="comparisons"><a class="header" href="#comparisons">Comparisons</a></h2>
<p>The following algorithms are used to perform comparisons and conditional checks both between ranges and within a range. They all return a Boolean indicating the result of the comparison.</p>
<h3 id="equal"><a class="header" href="#equal">Equal</a></h3>
<p><code>std::equal</code> performs applies a predicate to two ranges. The default predicate is <code>==</code> but any can be used.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v1 = std::vector&lt;int&gt;{ 0, 1, 2, 3, 4, 5 };
    auto v2 = std::vector&lt;int&gt;{ 1, 2, 3, 4, 5, 6 };

    println(v1);
    println(v2);

    std::cout &lt;&lt; std::boolalpha 
              &lt;&lt; std::equal(v1.begin(), v1.end(), v2.begin(), std::less&lt;&gt;{})
              &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/fs1T64vq5">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/equal"><code>std::equal</code></a></p>
<h3 id="lexicographical-compare"><a class="header" href="#lexicographical-compare">Lexicographical Compare</a></h3>
<p><code>std::lexicographical_compare</code> checks if the first range is lexicographically less then the second range. The predicate <em>less</em> can be changed.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

auto main() -&gt; int
{
    auto s1 = std::string{ &quot;Hello&quot; };
    auto s2 = std::string{ &quot;Hi&quot; };

    std::cout &lt;&lt; std::quoted(s1) &lt;&lt; std::endl;
    std::cout &lt;&lt; std::quoted(s2) &lt;&lt; std::endl;

    std::cout &lt;&lt; std::boolalpha 
              &lt;&lt; std::lexicographical_compare(s1.begin(), s1.end(),
                                              s2.begin(), s2.end())
              &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/YqovzcTYM">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare"><code>std::lexicographical_compare</code></a></p>
<h3 id="all-any--none-of"><a class="header" href="#all-any--none-of">All, Any &amp; None Of</a></h3>
<p>The three algorithms <code>std::all_of</code>, <code>std::any_of</code> and <code>std::none_of</code> will apply an unary predicate on a range returning <code>true</code> if all of, any of or none of the elements satisfy the predicate and <code>false</code> otherwise.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 0, 1, 2, 3, 4, 5 };

    println(v);

    std::cout &lt;&lt; std::boolalpha 
              &lt;&lt; &quot;All Odd? -- &quot;
              &lt;&lt; std::all_of(v.begin(), v.end(), [](const auto&amp; e){ return !(e % 2 == 0); })
              &lt;&lt; std::endl
              &lt;&lt; &quot;Any Even? -- &quot;
              &lt;&lt; std::any_of(v.begin(), v.end(), [](const auto&amp; e){ return e % 2 == 0; })
              &lt;&lt; std::endl
              &lt;&lt; &quot;None are 7? -- &quot;
              &lt;&lt; std::none_of(v.begin(), v.end(), [](const auto&amp; e){ return e == 7; })
              &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/hddx535Wj">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/all_any_none_of"><code>std::all_of</code>, <code>std::any_of</code> &amp; <code>std::none_of</code></a></p>
<h3 id="mismatch"><a class="header" href="#mismatch">Mismatch</a></h3>
<p>Finds the first mismatch between two ranges returning an <code>std::pair</code> of the iterators to the mismatch in the ranges. The binary predicate (default <code>==</code>) can be changed so that mismatch triggers on the first evaluation of <code>false</code> from the predicate.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v1 = std::vector&lt;int&gt;{ 1, 2, 3, 4, 5 };
    auto v2 = v1;
    v2[3] = 465;

    println(v1);
    println(v2);
    std::cout &lt;&lt; std::endl;

    const auto [v1ms, v2ms] = std::mismatch(v1.begin(), v1.end(), v2.begin());
    
    std::cout &lt;&lt; &quot;v1: &quot; &lt;&lt; *v1ms &lt;&lt; &quot;, v2: &quot; &lt;&lt; *v2ms &lt;&lt; std::endl;    

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/jj69vr5qe">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/mismatch"><code>std::mismatch</code></a></p>
<h2 id="generators"><a class="header" href="#generators">Generators</a></h2>
<p>Generators allow for ranges to be filled with values after their initial construction. They are useful for manufacturing values without the need of literals.</p>
<h3 id="fill"><a class="header" href="#fill">Fill</a></h3>
<p><code>std::fill</code> is the most simple generator. It fills an entire range with a single value, modifying the range in-place.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 0, 1, 2, 3, 4, 5 };

    println(v);
    std::fill(v.begin(), v.end(), 8);
    println(v);
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/57ssP7P36">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/fill"><code>std::fill</code></a></p>
<h3 id="iota"><a class="header" href="#iota">Iota</a></h3>
<p><code>std::iota</code> is a powerful factory based generator. It is supplied and initial value and will increment (using <code>++</code>) that initial value as it iterates through the range and assigns the current iterator with the incremented value. Iota is a common factory used in many different programming languages. Its original name is iota but it is often spelt <strong><em>range</em></strong>. <code>std::iota</code> is chapter of the <code>&lt;numeric&gt;</code> header. Like <code>std::fill</code>, <code>std::iota</code> modifies a sequence in-place.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 0, 1, 2, 3, 4, 5 };

    println(v);
    std::iota(v.begin(), v.end(), -2);
    println(v);
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/oz1179Gn6">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/iota"><code>std::iota</code></a></p>
<h3 id="generate"><a class="header" href="#generate">Generate</a></h3>
<p><code>std::generate</code> is the most primitive generator algorithm. Instead of taking an initial value, it takes a function that gets called repeatedly on each iteration. This algorithm modifies the range in-place.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v    = std::vector&lt;int&gt;(10);
    auto rd   = std::random_device{};
    auto gn   = std::mt19937{ rd() };
    auto dist = std::uniform_int_distribution&lt;&gt;{ 0, 10 };

    println(v);
    std::generate(v.begin(), v.end(), [&amp;]() { return dist(gn); });
    println(v);
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/s3GrYnv1a">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/generate"><code>std::generate</code></a></p>
<h2 id="algorithm-extensions"><a class="header" href="#algorithm-extensions">Algorithm Extensions</a></h2>
<p>Many algorithms have customised counterparts. These customisations include variants that take a predicate, or a size <code>n</code> instead of and end iterator. This are suffixed with markers such as <code>_if</code> or <code>_n</code> in the algorithm functions name. Look at cppreference for a comprehensive list of these variants.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ranges"><a class="header" href="#ranges">Ranges</a></h1>
<h2 id="what-is-a-range"><a class="header" href="#what-is-a-range">What is a range?</a></h2>
<p>What is a range? So far we have considered a range as a pair of iterators pointing to the beginning and end of a collection of elements. C++ formalised this idea by defining a range as an iterator and sentinel pair. This allowed for C++ to introduced the Ranges Library. One problem with the main C++ standard algorithms library is that is was made in the 1990's. As such the algorithms were designed with implicit constraints but had no way to enforce them. Because of backwards compatibility the standard library algorithms could not be updated to use concepts, instead C++ introduces new overloads for the standard library algorithms in the nested <code>std::ranges</code> namespace. Along with the original iterator (now iterator and sentinel design) interface, these algorithms accept a range object as an input sequence (output ranges are still modelled using an output iterator). This allowed for algorithm calls to be much simpler while also enforcing constraints on ranges. Almost all of the original algorithms have a <code>std::ranges</code> counterpart. If you can use the range version, even with the iterator interfaces as they impose stricter but safer requirements on the iterators to ensure that algorithms behave correctly. Range algorithms also support projections, allowing for in-place temporary transformations of data. This is defaulted to <code>std::identity</code>. All containers in the C++ standard library are considered valid ranges.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };

    println(v);
    std::ranges::transform(v, v.begin(), [](const auto&amp; x){ return x * x; });
    println(v);
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/6bdKa63j4">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/ranges">Constrained Algorithms</a></li>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/ranges/transform"><code>std::ranges::transform</code></a></li>
</ul>
<h2 id="range-concepts--categories"><a class="header" href="#range-concepts--categories">Range Concepts &amp; Categories</a></h2>
<p>Like iterators, there are different categories describing the requirements of a range type. These categories have concept definitions so you can constrain your own algorithms. Here is a table of different sequence containers and how they match up against the different range concepts.</p>
<table><thead><tr><th align="center">Concept</th><th align="center"><code>std::forward_list</code></th><th align="center"><code>std::list</code></th><th align="center"><code>std::deque</code></th><th align="center"><code>std::array</code></th><th align="center"><code>std::vector</code></th></tr></thead><tbody>
<tr><td align="center"><code>std::ranges::input_range</code></td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr>
<tr><td align="center"><code>std::ranges::forward_range</code></td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr>
<tr><td align="center"><code>std::ranges::bidirectional_range</code></td><td align="center"></td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr>
<tr><td align="center"><code>std::ranges::random_access_range</code></td><td align="center"></td><td align="center"></td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td></tr>
<tr><td align="center"><code>std::ranges::contiguous_range</code></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✅</td><td align="center">✅</td></tr>
</tbody></table>
<blockquote>
<p>Note: <code>std::output_range</code> is not shown here. This is because an <code>std::output_range</code> is similar to <code>std::input_range</code> except it models writing to as opposed to reading.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="views"><a class="header" href="#views">Views</a></h1>
<h2 id="what-is-a-view"><a class="header" href="#what-is-a-view">What is a View?</a></h2>
<p>A view is a simple abstraction on a range. Views can be thought of as a reference or pointer to a range that is cheap to copy, move, assign and destroy. Views allow for a ranges to be used in a lazy evaluation contexts. Views are found in the <code>std::ranges</code> namespace from the <code>&lt;range&gt;</code> header, often with a '_view' suffix or can be found in the <code>std::views</code> namespace of the same header without the suffix. Views can be passed to range based algorithms or even used as the range evaluated in a range-for.</p>
<p>Ranges can be created from an iterator and sentinel pair or a range using <code>std::subrange</code>.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;
#include &lt;vector&gt;

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 1, 2, 3, 4, 5 };

    /// Note: This is unnecessary and is only a showcase 
    for (const auto&amp; e : std::ranges::subrange(v.begin(), v.end()))
        std::cout &lt;&lt; e &lt;&lt; &quot; &quot;;

    std::cout &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/sE5Eq5a3z">Example</a></p>
<h2 id="lazy-evaluation"><a class="header" href="#lazy-evaluation">Lazy Evaluation</a></h2>
<p>What is lazy evaluation? Lazy evaluation is the process of delaying evaluation of functions and expressions until the result of the evaluation is actually needed. This reduces the amount of memory, compute cycles and evaluations the function undergoes and allows for easier composition of functions.</p>
<h2 id="factories"><a class="header" href="#factories">Factories</a></h2>
<p>Some views are used convert ranges and scalars into views. These views are called factories as they generate a view from its arguments.</p>
<ul>
<li><code>std::views::empty</code> - A view containing no element. It still takes an unused template type parameter.</li>
<li><code>std::views::single</code> - A owning view containing a single element.</li>
<li><code>std::views::iota</code> - A range factory, generating a elements from a repeatedly incremented initial value. This view can be bound to a final value or unbounded, generating an infinite view. Bounded iota views are exclusive ie. the bound is excluded from the resulting range.</li>
<li><code>std::views::istream</code> - A range factory, generating elements by repeated calls to <code>&gt;&gt;</code> on a input stream eg. <code>std::cin</code>.</li>
</ul>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;

auto main() -&gt; int
{
    /// Prints &quot;0 1 2 3 4 5 6 7 8 9 10&quot;
    std::ranges::copy(std::views::iota(0, 11), std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/brff8rY5T">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/ranges/empty_view"><code>std::views::empty</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/ranges/single_view"><code>std::views::single</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/ranges/iota_view"><code>std::views::iota</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/ranges/basic_istream_view"><code>std::views::istream</code></a></li>
</ul>
<h2 id="range-adaptors-composition--the-pipe-operators"><a class="header" href="#range-adaptors-composition--the-pipe-operators">Range Adaptors, Composition &amp; The Pipe Operators</a></h2>
<p>So far views aren't all that interesting. The true power of views comes from their ability to be composed. Composition allows for views to be combined to build more complex views over data while still adhering to lazy evaluation. Instead of evaluating each function one at a time a single function, which is the composition of all the view functions gets evaluated once for every access to the element. Views are composed using the pipe operator (<code>|</code>) and are read from left-to-right as opposed to inside-out. This makes function composition far more expressible and extensible. Range (including containers) or view object are 'piped' to the range adaptor with the resulting view; when evaluated, applying the range adaptor on the every element.</p>
<h2 id="standard-view-range-adaptors"><a class="header" href="#standard-view-range-adaptors">Standard View Range Adaptors</a></h2>
<ul>
<li><code>std::views::transform</code> - a range adapter whose resulting view maps an unary function to the input range.</li>
<li><code>std::views::filter</code> - a range adaptor that whose resulting view excludes any element that do not satisfy an unary predicate.</li>
<li><code>std::views::reverse</code>  - a range adaptor returning a view of the input range as if its order was reversed.</li>
<li><code>std::views::take</code> - a range adaptor whose resulting view take only \( n \) elements from the input range. Performs bound checks to ensure that it doesn't take more elements then the view can see.</li>
<li><code>std::views::take_while</code> - a range adaptor whose resulting view contains every element until an unary predicate returns <code>false</code>.</li>
<li><code>std::views::drop</code> - a range adapter whose resulting view skips the first \( n \) elements from a input range.</li>
<li><code>std::views::drop_while</code> -  a range adaptor whose resulting view starts at the first element for which the unary predicate evaluates <code>false</code>.</li>
<li><code>std::views::join</code> - a range adaptor whose resulting view will flatten nested range or view object a single view.</li>
<li><code>std::views::split</code> - a range adaptor whose resulting view contains subranges split by a given deliminator. Is not entirely lazy and will eagerly move forward through the view at each iteration during evaluation.</li>
<li><code>std::views::lazy_split</code> - a range adaptor whose resulting view contains subranges split by a given deliminator Is entirely lazy evaluated but is unable to model the subranges as a <a href="https://en.cppreference.com/w/cpp/ranges/common_range">common range</a>(a range with the same type for the iterator and sentinel) and cannot be used in algorithms expecting a bidirectional range (or higher).</li>
<li><code>std::views::common</code> - a range adaptor whose resulting view adapts the input range to have the same type for its iterator and sentinels.</li>
<li><code>std::views::element</code> - a range adaptor that accepts an input range with <em>Tuple-Like</em> elements and whose resulting view contains the \( Nth \) entry from every <em>Tuple-Like</em> element of the input range.</li>
<li><code>std::views::keys</code> - a range adaptor who is a specialisations of <code>std::views::elements</code> taking the \( 0th \) entry of a view of <em>Tuple-Like</em> elements. This can be used to obtain a view of just the keys of an associative container.</li>
<li><code>std::views::values</code> - a range adaptor who is a specialisations of <code>std::views::elements</code> taking the \( 1st \) entry of a view of <em>Tuple-Like</em> elements. This can be used to obtain a view of just the values of an associative container.</li>
</ul>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;ranges&gt;

auto square = [](const auto&amp; x){ return x * x; };
auto even = [](const auto&amp; x){ return x % 2 == 0; };

auto main() -&gt; int
{
    auto nums = std::views::iota(0) 
              | std::views::transform(square)
              | std::views::filter(even)
              | std::views::take(10);

    std::ranges::copy(nums, std::ostream_iterator&lt;int&gt;(std::cout, &quot; &quot;));

    std::cout &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/3fdW1P7hj">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/ranges/transform_view"><code>std::views::transform</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/ranges/filter_view"><code>std::views::filter</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/ranges/reverse_view"><code>std::views::reverse</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/ranges/take_view"><code>std::views::take</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/ranges/take_while_view"><code>std::views::take_while</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/ranges/drop_view"><code>std::views::drop</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/ranges/drop_while_view"><code>std::views::drop_while</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/ranges/join_view"><code>std::views::join</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/ranges/split_view"><code>std::views::split</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/ranges/lazy_split_view"><code>std::views::lazy_split</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/ranges/common_view"><code>std::views::common</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/ranges/elements_view"><code>std::views::elements</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/ranges/keys_view"><code>std::views::keys</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/ranges/values_view"><code>std::views::values</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="task-3--circular-buffer"><a class="header" href="#task-3--circular-buffer">Task 3 : Circular Buffer</a></h1>
<p>This assignment is a tricker one. Your job is to implement a <a href="https://en.wikipedia.org/wiki/Circular_buffer">circular buffer</a> or a ring buffer. Circular buffers are First-In-First-Out buffers</p>
<h2 id="requirements-2"><a class="header" href="#requirements-2">Requirements</a></h2>
<ul>
<li>Must be a <code>class</code> (or <code>struct</code>).</li>
<li>Must have these constructors
<ul>
<li>Default</li>
<li>Copy</li>
<li>Move</li>
<li>Assignment Copy</li>
<li>Assignment Move</li>
<li>A destructor</li>
</ul>
</li>
<li>Must be templated for any element type <code>T</code>.</li>
<li>Can either be dynamic in size (adds memory as it needs) or semi-static (fixed maximum but variable current size)</li>
<li>Methods for pushing in a new element to the front and popping the oldest from the back.</li>
<li>Introspection methods
<ul>
<li>Current size</li>
<li>Current capacity</li>
<li>One that returns a pointer to the first element</li>
<li>A method to check if the buffer is full</li>
<li>A method to check if the buffer is empty</li>
</ul>
</li>
<li>Element access
<ul>
<li><em>at-like</em> method with index checking</li>
<li>subscript operator overload (<code>[]</code>)</li>
</ul>
</li>
</ul>
<p>You can manually create and destroy the memory, use smart pointers or use a container to store the underlying memory.</p>
<h3 id="optional"><a class="header" href="#optional">Optional</a></h3>
<ul>
<li>Have a custom iterator type with the relevant methods in the circular buffer for obtaining them.</li>
<li>front and and back element access.</li>
<li>Equality (<code>==</code>) and inequality (<code>!=</code>) operator overloads.</li>
<li>Output stream operator overload (<code>&gt;&gt;</code>).</li>
<li>Constructor and assignment operator overload (<code>=</code>) that take an <code>std::initializer_list</code>.</li>
<li>Uses an allocator (eg. <code>std::allocator</code>) to allocate memory.</li>
<li>Takes an additional template argument that correlates to a generic allocator type.</li>
<li>Takes an additional template parameter that correlates to the type of the underlying container used to for storage of elements (eg. <code>std::vector</code>) making the circular buffer an adaptor.</li>
</ul>
<h2 id="submitting-2"><a class="header" href="#submitting-2">Submitting</a></h2>
<p>You can use Godbolt or bpt to build and test your struct. Once you have created your implementation:</p>
<ul>
<li>Clone this repo using <code>git clone https://github.com/MonashDeepNeuron/HPP.git</code>.</li>
<li>Create a new branch using <code>git checkout -b triple/&lt;your-name&gt;</code>.</li>
<li>Create a folder in the <code>/submissions</code> directory with your name.</li>
<li>Create a folder with the name of this task.</li>
<li>Copy your mini project into this directory (bpt setup, cmake scripts etc.) with a <code>README.md</code> or comment in the code on how to run the program (verify it still works). There is a sample header file in <code>/templates</code> that you can use.</li>
<li>Go to <a href="https://github.com/MonashDeepNeuron/HPP/pulls">https://github.com/MonashDeepNeuron/HPP/pulls</a> and click 'New pull request'.</li>
<li>Change the branches in the drop down so that your branch is going into <code>main</code> and `Create new pull request.</li>
<li>Give the pull request a title and briefly describe what you were able to implement and any struggles you had.</li>
<li>On the right side-panel, under the 'Assignees' section, click the cog and assign me.</li>
<li>Click 'Create pull request' and I'll take it from there.</li>
</ul>
<blockquote>
<p>Note: If you created a GodBolt instance, put the link in a comment at the top of the file (under your copy comments). This is generated by clicking the <code>share</code> button in the top-right-most corner of the webpage and clicking the 'short link' option.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slides-5"><a class="header" href="#slides-5">Slides</a></h1>
<p><img src="chapter6/./imgs/hpp_chapter6-01.png" alt="Slides 01" />
<img src="chapter6/./imgs/hpp_chapter6-02.png" alt="Slides 02" />
<img src="chapter6/./imgs/hpp_chapter6-03.png" alt="Slides 03" />
<img src="chapter6/./imgs/hpp_chapter6-04.png" alt="Slides 04" />
<img src="chapter6/./imgs/hpp_chapter6-05.png" alt="Slides 05" />
<img src="chapter6/./imgs/hpp_chapter6-06.png" alt="Slides 06" />
<img src="chapter6/./imgs/hpp_chapter6-07.png" alt="Slides 07" />
<img src="chapter6/./imgs/hpp_chapter6-08.png" alt="Slides 08" />
<img src="chapter6/./imgs/hpp_chapter6-09.png" alt="Slides 09" />
<img src="chapter6/./imgs/hpp_chapter6-10.png" alt="Slides 10" />
<img src="chapter6/./imgs/hpp_chapter6-11.png" alt="Slides 11" />
<img src="chapter6/./imgs/hpp_chapter6-12.png" alt="Slides 12" />
<img src="chapter6/./imgs/hpp_chapter6-13.png" alt="Slides 13" />
<img src="chapter6/./imgs/hpp_chapter6-14.png" alt="Slides 14" />
<img src="chapter6/./imgs/hpp_chapter6-15.png" alt="Slides 15" />
<img src="chapter6/./imgs/hpp_chapter6-16.png" alt="Slides 16" />
<img src="chapter6/./imgs/hpp_chapter6-17.png" alt="Slides 17" />
<img src="chapter6/./imgs/hpp_chapter6-18.png" alt="Slides 18" />
<img src="chapter6/./imgs/hpp_chapter6-19.png" alt="Slides 19" />
<img src="chapter6/./imgs/hpp_chapter6-20.png" alt="Slides 20" />
<img src="chapter6/./imgs/hpp_chapter6-21.png" alt="Slides 21" />
<img src="chapter6/./imgs/hpp_chapter6-22.png" alt="Slides 22" />
<img src="chapter6/./imgs/hpp_chapter6-23.png" alt="Slides 23" />
<img src="chapter6/./imgs/hpp_chapter6-24.png" alt="Slides 24" />
<img src="chapter6/./imgs/hpp_chapter6-25.png" alt="Slides 25" />
<img src="chapter6/./imgs/hpp_chapter6-26.png" alt="Slides 26" />
<img src="chapter6/./imgs/hpp_chapter6-27.png" alt="Slides 27" />
<img src="chapter6/./imgs/hpp_chapter6-28.png" alt="Slides 28" />
<img src="chapter6/./imgs/hpp_chapter6-29.png" alt="Slides 29" />
<img src="chapter6/./imgs/hpp_chapter6-30.png" alt="Slides 30" />
<img src="chapter6/./imgs/hpp_chapter6-31.png" alt="Slides 31" />
<img src="chapter6/./imgs/hpp_chapter6-32.png" alt="Slides 32" />
<img src="chapter6/./imgs/hpp_chapter6-33.png" alt="Slides 33" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrent-programming"><a class="header" href="#concurrent-programming">Concurrent Programming</a></h1>
<p>The focus of this chapter is parallelism and concurrency. Parallelism allows for large amount data to be broken into smaller chunks and processed at the same time. Even undergoing different transformations. Concurrency is the ability to run multiple jobs, sections or functions simultaneously and communicate data and transfer between the states of the jobs. Together, these allow programs to expand the amount of work they are able to do and separate a program into multiple moving pieces. C++ has many primitives that make parallel and concurrent programming simple and effective.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parallel-algorithms"><a class="header" href="#parallel-algorithms">Parallel Algorithms</a></h1>
<h2 id="execution-policies"><a class="header" href="#execution-policies">Execution Policies</a></h2>
<p>The most basic parallelism comes from the algorithms library. Since C++17 almost all of the algorithms (iterator-based not range-based) in the standard library feature an overload that allows for the algorithm to potentially perform in parallel. These overloads accepts as their first arguments an execution policy. This is an object that represent the level of freedom an algorithms implementation has to try and parallelize its operation. Execution policies are found in the <code>&lt;execution&gt;</code> header under the <code>std::execution</code> namespace. Execution policies are suggestions, they indicate that a algorithm may be able to be parallelized. How the parallelism is achieve is up to the implementation and requires a parallelism backend library that the implementations will use. The most common is Intel's Thread Building Blocks (TBB) library. Using parallel overloads does require some due-diligence from the programmer to not create deadlocks or data races. The parallel algorithms will not automatically stop these from happening.</p>
<table><thead><tr><th align="center">Execution Policy</th><th align="center">Description</th></tr></thead><tbody>
<tr><td align="center"><code>std::execution::seq</code></td><td align="center">Forbids an algorithm from being parallelized. Invocations of element access functions within the algorithm are indeterminately sequenced in the calling thread.</td></tr>
<tr><td align="center"><code>std::execution::par</code></td><td align="center">Specifies that an algorithm can be parallelized. Invocations of element access functions within the algorithm are permitted to execute in the working thread or in a thread implicitly created by the underlying parallel library. Invocations executing in the same thread are indeterminately sequenced in the calling thread.</td></tr>
<tr><td align="center"><code>std::execution::unseq</code></td><td align="center">Specifies that an algorithm can be vectorized such that a single thread using instructions that operate on multiple data items.</td></tr>
<tr><td align="center"><code>std::execution::par_unseq</code></td><td align="center">Specifies that an algorithm can be parallelized, vectorized or migrated across threads. Invocations of element access functions within the algorithm are permitted to execute in unordered fashion in unspecified threads and can be un-sequenced with respect to one another within each thread.</td></tr>
</tbody></table>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t">Execution Policies</a></p>
<h2 id="alternative-algorithms"><a class="header" href="#alternative-algorithms">Alternative Algorithms</a></h2>
<p>There are a few algorithms in C++ that did not get parallel overloads. Namely a few of the numerical reductions. This is because reduction algorithms typically use binary operators in order to combine elements. The issue with this is not all binary operators are commutative or associative. This can cause problems when making an algorithm work in parallel because the order of operations can affect the result of the reduction. C++ regular reduction algorithms apply their operations in-order meaning that the commutative and associative properties of the binary operator do not matter. For parallel algorithms, commutativity and associativity must be assumed of the binary operator so that operations can be out-of-order.</p>
<h3 id="reduce"><a class="header" href="#reduce">Reduce</a></h3>
<p><code>std::reduce</code> is the parallel form of <code>std::accumulate</code>. It performs a regular left-fold and can take an optional initial value.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;execution&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

template &lt;typename time_t = std::chrono::microseconds&gt;
struct measure
{
    template &lt;typename F, typename... Args&gt;
    static auto execution(F func, Args&amp;&amp;... args) 
        -&gt; std::pair&lt;typename time_t::rep, std::invoke_result_t&lt;F, Args...&gt;&gt;
    {
        auto start = std::chrono::system_clock::now();
        auto result = std::invoke(func, std::forward&lt;Args&gt;(args)...);
        auto duration = std::chrono::duration_cast&lt;time_t&gt;(std::chrono::system_clock::now() - start);
        return std::pair&lt;typename time_t::rep, std::invoke_result_t&lt;F, Args...&gt;&gt;{ duration.count(), result };
    }
};

auto main() -&gt; int
{
    auto v = std::vector&lt;double&gt;(100'000'007, 0.1);
    std::cout.imbue(std::locale(&quot;en_US.UTF-8&quot;));
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1);
    
    std::cout &lt;&lt; &quot;+-----------------+-------------+-----------+--------+------------+----------------+&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;|    Algorithm    | Exec Policy | Binary-Op |  Type  |    Time    |     Result     |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------+-------------+-----------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::accumulate |   Serial    |     +     | double | &quot;;
    auto [acc_time, acc_result] = measure&lt;&gt;::execution([](const auto&amp; v){ return std::accumulate(v.begin(), v.end(), 0.0); }, v);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; acc_time &lt;&lt; &quot; us |  &quot; &lt;&lt; acc_result &lt;&lt; &quot;  |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------+-------------+-----------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;|   std::reduce   | Sequencial  |     +     | double | &quot;;
    auto [seq_time, seq_result] = measure&lt;&gt;::execution([](const auto&amp; v){ return std::reduce(std::execution::seq, v.begin(), v.end(), 0.0); }, v);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; seq_time &lt;&lt; &quot; us |  &quot; &lt;&lt; seq_result &lt;&lt; &quot;  |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------+-------------+-----------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;|   std::reduce   |  Parallel   |     +     | double | &quot;;
    auto [par_time, par_result] = measure&lt;&gt;::execution([](const auto&amp; v){ return std::reduce(std::execution::par, v.begin(), v.end(), 0.0); }, v);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_time &lt;&lt; &quot; us |  &quot; &lt;&lt; par_result &lt;&lt; &quot;  |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------+-------------+-----------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;|   std::reduce   | Unsequenced |     +     | double | &quot;;
    auto [unseq_time, unseq_result] = measure&lt;&gt;::execution([](const auto&amp; v){ return std::reduce(std::execution::unseq, v.begin(), v.end(), 0.0); }, v);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; unseq_time &lt;&lt; &quot; us |  &quot; &lt;&lt; unseq_result &lt;&lt; &quot;  |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------+-------------+-----------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;|   std::reduce   |  Par-Unseq  |     +     | double | &quot;;
    auto [par_unseq_time, par_unseq_result] = measure&lt;&gt;::execution([](const auto&amp; v){ return std::reduce(std::execution::par_unseq, v.begin(), v.end(), 0.0); }, v);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_unseq_time &lt;&lt; &quot; us |  &quot; &lt;&lt; par_unseq_result &lt;&lt; &quot;  |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------+-------------+-----------+--------+------------+----------------+&quot; &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

$ ./build/reduce
+-----------------+-------------+-----------+--------+------------+----------------+
|    Algorithm    | Exec Policy | Binary-Op |  Type  |    Time    |     Result     |
+-----------------+-------------+-----------+--------+------------+----------------+
| std::accumulate |   Serial    |     +     | double | 151,861 us |  10,000,000.7  |
+-----------------+-------------+-----------+--------+------------+----------------+
|   std::reduce   | Sequencial  |     +     | double |  76,011 us |  10,000,000.7  |
+-----------------+-------------+-----------+--------+------------+----------------+
|   std::reduce   |  Parallel   |     +     | double |  21,098 us |  10,000,000.7  |
+-----------------+-------------+-----------+--------+------------+----------------+
|   std::reduce   | Unsequenced |     +     | double | 135,906 us |  10,000,000.7  |
+-----------------+-------------+-----------+--------+------------+----------------+
|   std::reduce   |  Par-Unseq  |     +     | double |  23,752 us |  10,000,000.7  |
+-----------------+-------------+-----------+--------+------------+----------------+
</code></pre>
<p><a href="chapter7/./examples/par-algs/src/reduce.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/reduce"><code>std::reduce</code></a></p>
<h3 id="transform-reduce"><a class="header" href="#transform-reduce">Transform Reduce</a></h3>
<p><code>std::transform_reduce</code> is akin to <code>std::inner_product</code> performing the same default unary transformation (<code>*</code>) and reduction (<code>+</code>). Takes an initial value that is used as the base accumulator.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;execution&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

template &lt;typename time_t = std::chrono::microseconds&gt;
struct measure
{
    template &lt;typename F, typename... Args&gt;
    static auto execution(F func, Args&amp;&amp;... args) 
        -&gt; std::pair&lt;typename time_t::rep, std::invoke_result_t&lt;F, Args...&gt;&gt;
    {
        auto start = std::chrono::system_clock::now();
        auto result = std::invoke(func, std::forward&lt;Args&gt;(args)...);
        auto duration = std::chrono::duration_cast&lt;time_t&gt;(std::chrono::system_clock::now() - start);
        return std::pair&lt;typename time_t::rep, std::invoke_result_t&lt;F, Args...&gt;&gt;{ duration.count(), result };
    }
};

auto main() -&gt; int
{
    auto v1 = std::vector&lt;double&gt;(100'000'007, 0.145);
    auto v2 = std::vector&lt;double&gt;(100'000'007, 0.524);
    std::cout.imbue(std::locale(&quot;en_US.UTF-8&quot;));
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(4);
    
    std::cout &lt;&lt; &quot;+-----------------------+-------------+------------+--------+------------+----------------+&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;|       Algorithm       | Exec Policy | Binary-Ops |  Type  |    Time    |     Result     |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------------+-------------+------------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;|  std::inner_product   |   Serial    | (*) -&gt; (+) | double | &quot;;
    auto [in_prod_time, in_prod_result] = measure&lt;&gt;::execution([](const auto&amp; v1, const auto&amp; v2){ return std::inner_product(v1.begin(), v1.end(), v2.begin(), 0.0); }, v1, v2);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; in_prod_time &lt;&lt; &quot; us | &quot; &lt;&lt; in_prod_result &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------------+-------------+------------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_reduce | Sequencial  | (*) -&gt; (+) | double | &quot;;
    auto [seq_time, seq_result] = measure&lt;&gt;::execution([](const auto&amp; v1, const auto&amp; v2){ return std::transform_reduce(std::execution::seq, v1.begin(), v1.end(), v2.begin(), 0.0); }, v1, v2);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; seq_time &lt;&lt; &quot; us | &quot; &lt;&lt; seq_result &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------------+-------------+------------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_reduce |  Parallel   | (*) -&gt; (+) | double | &quot;;
    auto [par_time, par_result] = measure&lt;&gt;::execution([](const auto&amp; v1, const auto&amp; v2){ return std::transform_reduce(std::execution::par, v1.begin(), v1.end(), v2.begin(), 0.0); }, v1, v2);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_time &lt;&lt; &quot; us | &quot; &lt;&lt; par_result &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------------+-------------+------------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_reduce | Unsequenced | (*) -&gt; (+) | double | &quot;;
    auto [unseq_time, unseq_result] = measure&lt;&gt;::execution([](const auto&amp; v1, const auto&amp; v2){ return std::transform_reduce(std::execution::unseq, v1.begin(), v1.end(), v2.begin(), 0.0); }, v1, v2);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; unseq_result &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------------+-------------+------------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_reduce |  Par-Unseq  | (*) -&gt; (+) | double | &quot;;
    auto [par_unseq_time, par_unseq_result] = measure&lt;&gt;::execution([](const auto&amp; v1, const auto&amp; v2){ return std::transform_reduce(std::execution::par_unseq, v1.begin(), v1.end(), v2.begin(), 0.0); }, v1, v2);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; par_unseq_result &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------------+-------------+------------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

./build/transform_reduce
+-----------------------+-------------+------------+--------+------------+----------------+
|       Algorithm       | Exec Policy | Binary-Ops |  Type  |    Time    |     Result     |
+-----------------------+-------------+------------+--------+------------+----------------+
|  std::inner_product   |   Serial    | (*) -&gt; (+) | double | 144,255 us | 7,598,000.5455 |
+-----------------------+-------------+------------+--------+------------+----------------+
| std::transform_reduce | Sequencial  | (*) -&gt; (+) | double | 119,467 us | 7,598,000.5455 |
+-----------------------+-------------+------------+--------+------------+----------------+
| std::transform_reduce |  Parallel   | (*) -&gt; (+) | double |  53,172 us | 7,598,000.5318 |
+-----------------------+-------------+------------+--------+------------+----------------+
| std::transform_reduce | Unsequenced | (*) -&gt; (+) | double | 131,677 us | 7,598,000.5455 |
+-----------------------+-------------+------------+--------+------------+----------------+
| std::transform_reduce |  Par-Unseq  | (*) -&gt; (+) | double |  51,095 us | 7,598,000.5319 |
+-----------------------+-------------+------------+--------+------------+----------------+
</code></pre>
<p><a href="chapter7/./examples/par-algs/src/transform_reduce.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/transform_reduce"><code>std::transform_reduce</code></a></p>
<h3 id="exclusive-scan"><a class="header" href="#exclusive-scan">Exclusive Scan</a></h3>
<p><code>std::exclusive_scan</code> is akin to <code>std::partial_sum</code> except is takes in an initial value and excludes the \( ith \) input element from the \( ith \) sum (reduction).</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;execution&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

template &lt;typename time_t = std::chrono::microseconds&gt;
struct measure
{
    template &lt;typename F, typename... Args&gt;
    static auto execution(F func, Args&amp;&amp;... args) 
        -&gt; typename time_t::rep
    {
        auto start = std::chrono::system_clock::now();
        std::invoke(func, std::forward&lt;Args&gt;(args)...);
        auto duration = std::chrono::duration_cast&lt;time_t&gt;(std::chrono::system_clock::now() - start);
        return duration.count();
    }
};

template&lt;typename T&gt;
auto operator&lt;&lt; 
(std::ostream&amp; os, const std::vector&lt;T&gt;&amp; v) -&gt; std::ostream&amp;
{
    os &lt;&lt; &quot;[ &quot;;
    for (auto i { v.size() }; const auto&amp; e : v)
        if (--i &gt; (v.size() - 3))
            os &lt;&lt; e &lt;&lt; &quot;, &quot;;

    auto last = v.end() - 3;
    os &lt;&lt; &quot;..., &quot; &lt;&lt; *++last &lt;&lt; &quot;, &quot;;
    os &lt;&lt; *++last &lt;&lt; &quot; ]&quot;;
    return os;
}

auto main() -&gt; int
{
    auto v = std::vector&lt;double&gt;(100'000'007, 0.1);
    auto r = std::vector&lt;double&gt;(100'000'007, 0.0);
    std::cout.imbue(std::locale(&quot;en_US.UTF-8&quot;));
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1);
    
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;|      Algorithm      | Exec Policy | Binary-Op |  Type  |    Time    |                    Result                     |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;|  std::partial_sum   |   Serial    |     +     | double | &quot;;
    auto scan_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::partial_sum(v.begin(), v.end(), r.begin()); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; scan_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::exclusive_scan | Sequencial  |     +     | double | &quot;;
    auto seq_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::exclusive_scan(std::execution::seq, v.begin(), v.end(), r.begin(), 0.0); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; seq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::exclusive_scan |  Parallel   |     +     | double | &quot;;
    auto par_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::exclusive_scan(std::execution::par, v.begin(), v.end(), r.begin(), 0.0); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::exclusive_scan | Unsequenced |     +     | double | &quot;;
    auto unseq_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::exclusive_scan(std::execution::unseq, v.begin(), v.end(), r.begin(), 0.0); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::exclusive_scan |  Par-Unseq  |     +     | double | &quot;;
    auto par_unseq_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::exclusive_scan(std::execution::par_unseq, v.begin(), v.end(), r.begin(), 0.0); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

./build/exclusive_scan
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
|      Algorithm      | Exec Policy | Binary-Op |  Type  |    Time    |                    Result                     |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
|  std::partial_sum   |   Serial    |     +     | double | 119,096 us | [ 0.1, 0.2, ..., 10,000,000.6, 10,000,000.7 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
| std::exclusive_scan | Sequencial  |     +     | double | 143,338 us | [ 0.0, 0.1, ..., 10,000,000.5, 10,000,000.6 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
| std::exclusive_scan |  Parallel   |     +     | double | 146,967 us | [ 0.0, 0.1, ..., 10,000,000.5, 10,000,000.6 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
| std::exclusive_scan | Unsequenced |     +     | double | 140,900 us | [ 0.0, 0.1, ..., 10,000,000.5, 10,000,000.6 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
| std::exclusive_scan |  Par-Unseq  |     +     | double | 145,098 us | [ 0.0, 0.1, ..., 10,000,000.5, 10,000,000.6 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
</code></pre>
<p><a href="chapter7/./examples/par-algs/src/exclusive_scan.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/exclusive_scan"><code>std::exclusive_scan</code></a></p>
<h3 id="inclusive-scan"><a class="header" href="#inclusive-scan">Inclusive Scan</a></h3>
<p><code>std::inclusive_scan</code> is identical to <code>std::partial_sum</code>. It does not take an initial value and unlike <code>std::exclusive_scan</code> includes the \( ith \) element from the input range in the \( ith \) reduction.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;execution&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

template &lt;typename time_t = std::chrono::microseconds&gt;
struct measure
{
    template &lt;typename F, typename... Args&gt;
    static auto execution(F func, Args&amp;&amp;... args) 
        -&gt; typename time_t::rep
    {
        auto start = std::chrono::system_clock::now();
        std::invoke(func, std::forward&lt;Args&gt;(args)...);
        auto duration = std::chrono::duration_cast&lt;time_t&gt;(std::chrono::system_clock::now() - start);
        return duration.count();
    }
};

template&lt;typename T&gt;
auto operator&lt;&lt; 
(std::ostream&amp; os, const std::vector&lt;T&gt;&amp; v) -&gt; std::ostream&amp;
{
    os &lt;&lt; &quot;[ &quot;;
    for (auto i { v.size() }; const auto&amp; e : v)
        if (--i &gt; (v.size() - 3))
            os &lt;&lt; e &lt;&lt; &quot;, &quot;;

    auto last = v.end() - 3;
    os &lt;&lt; &quot;..., &quot; &lt;&lt; *++last &lt;&lt; &quot;, &quot;;
    os &lt;&lt; *++last &lt;&lt; &quot; ]&quot;;
    return os;
}

auto main() -&gt; int
{
    auto v = std::vector&lt;double&gt;(100'000'007, 0.1);
    auto r = std::vector&lt;double&gt;(100'000'007);
    std::cout.imbue(std::locale(&quot;en_US.UTF-8&quot;));
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1);
    
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;|      Algorithm      | Exec Policy | Binary-Op |  Type  |    Time    |                    Result                     |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;|  std::partial_sum   |   Serial    |     +     | double | &quot;;
    auto scan_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::partial_sum(v.begin(), v.end(), r.begin()); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; scan_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::inclusive_scan | Sequencial  |     +     | double | &quot;;
    auto seq_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::inclusive_scan(std::execution::seq, v.begin(), v.end(), r.begin()); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; seq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::inclusive_scan |  Parallel   |     +     | double | &quot;;
    auto par_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::inclusive_scan(std::execution::par, v.begin(), v.end(), r.begin()); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::inclusive_scan | Unsequenced |     +     | double | &quot;;
    auto unseq_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::inclusive_scan(std::execution::unseq, v.begin(), v.end(), r.begin()); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::inclusive_scan |  Par-Unseq  |     +     | double | &quot;;
    auto par_unseq_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::inclusive_scan(std::execution::par_unseq, v.begin(), v.end(), r.begin()); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

./build/inclusive_scan
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
|      Algorithm      | Exec Policy | Binary-Op |  Type  |    Time    |                    Result                     |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
|  std::partial_sum   |   Serial    |     +     | double | 121,801 us | [ 0.1, 0.2, ..., 10,000,000.6, 10,000,000.7 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
| std::inclusive_scan | Sequencial  |     +     | double | 120,705 us | [ 0.1, 0.2, ..., 10,000,000.6, 10,000,000.7 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
| std::inclusive_scan |  Parallel   |     +     | double | 150,662 us | [ 0.1, 0.2, ..., 10,000,000.6, 10,000,000.7 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
| std::inclusive_scan | Unsequenced |     +     | double | 120,440 us | [ 0.1, 0.2, ..., 10,000,000.6, 10,000,000.7 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
| std::inclusive_scan |  Par-Unseq  |     +     | double | 145,441 us | [ 0.1, 0.2, ..., 10,000,000.6, 10,000,000.7 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
</code></pre>
<p><a href="chapter7/./examples/par-algs/src/inclusive_scan.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/inclusive_scan"><code>std::inclusive_scan</code></a></p>
<h3 id="transform-exclusive-scan"><a class="header" href="#transform-exclusive-scan">Transform Exclusive Scan</a></h3>
<p><code>std::transform_exclusive_scan</code> will perform a unary transformation and then performs a left exclusive scan on a range.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;execution&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

template &lt;typename time_t = std::chrono::microseconds&gt;
struct measure
{
    template &lt;typename F, typename... Args&gt;
    static auto execution(F func, Args&amp;&amp;... args) 
        -&gt; typename time_t::rep
    {
        auto start = std::chrono::system_clock::now();
        std::invoke(func, std::forward&lt;Args&gt;(args)...);
        auto duration = std::chrono::duration_cast&lt;time_t&gt;(std::chrono::system_clock::now() - start);
        return duration.count();
    }
};

template&lt;typename T&gt;
auto operator&lt;&lt; 
(std::ostream&amp; os, const std::vector&lt;T&gt;&amp; v) -&gt; std::ostream&amp;
{
    os &lt;&lt; &quot;[ &quot;;
    for (auto i { v.size() }; const auto&amp; e : v)
        if (--i &gt; (v.size() - 3))
            os &lt;&lt; e &lt;&lt; &quot;, &quot;;

    auto last = v.end() - 3;
    os &lt;&lt; &quot;..., &quot; &lt;&lt; *++last &lt;&lt; &quot;, &quot;;
    os &lt;&lt; *++last &lt;&lt; &quot; ]&quot;;
    return os;
}

auto main() -&gt; int
{
    auto v = std::vector&lt;double&gt;(100'000'007, 0.1);
    auto r = std::vector&lt;double&gt;(100'000'007, 0.0);
    auto times2 = [](const auto&amp; x){ return x * 2; };
    std::cout.imbue(std::locale(&quot;en_US.UTF-8&quot;));
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1);
    
    std::cout &lt;&lt; &quot;+-------------------------------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;|           Algorithm           | Exec Policy | Operations  |  Type  |    Time    |                    Result                     |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_inclusive_scan | Sequencial  | (*2) -&gt; (+) | double | &quot;;
    auto seq_time = measure&lt;&gt;::execution([&amp;](const auto&amp; v, auto&amp; r){  std::transform_inclusive_scan(std::execution::seq, v.begin(), v.end(), r.begin(), std::plus&lt;&gt;{}, times2, 0.0); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; seq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_inclusive_scan |  Parallel   | (*2) -&gt; (+) | double | &quot;;
    auto par_time = measure&lt;&gt;::execution([&amp;](const auto&amp; v, auto&amp; r){  std::transform_inclusive_scan(std::execution::par, v.begin(), v.end(), r.begin(), std::plus&lt;&gt;{}, times2, 0.0); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_inclusive_scan | Unsequenced | (*2) -&gt; (+) | double | &quot;;
    auto unseq_time = measure&lt;&gt;::execution([&amp;](const auto&amp; v, auto&amp; r){  std::transform_inclusive_scan(std::execution::unseq, v.begin(), v.end(), r.begin(), std::plus&lt;&gt;{}, times2, 0.0); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_inclusive_scan |  Par-Unseq  | (*2) -&gt; (+) | double | &quot;;
    auto par_unseq_time = measure&lt;&gt;::execution([&amp;](const auto&amp; v, auto&amp; r){  std::transform_inclusive_scan(std::execution::par_unseq, v.begin(), v.end(), r.begin(), std::plus&lt;&gt;{}, times2, 0.0); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

./build/transform_exclusive_scan
+-------------------------------+-------------+-------------+--------+------------+-----------------------------------------------+
|           Algorithm           | Exec Policy | Operations  |  Type  |    Time    |                    Result                     |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
| std::transform_exclusive_scan | Sequencial  | (*2) -&gt; (+) | double | 125,675 us | [ 0.0, 0.2, ..., 20,000,001.0, 20,000,001.2 ] |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
| std::transform_exclusive_scan |  Parallel   | (*2) -&gt; (+) | double | 150,095 us | [ 0.0, 0.2, ..., 20,000,001.0, 20,000,001.2 ] |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
| std::transform_exclusive_scan | Unsequenced | (*2) -&gt; (+) | double | 167,813 us | [ 0.0, 0.2, ..., 20,000,001.0, 20,000,001.2 ] |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
| std::transform_exclusive_scan |  Par-Unseq  | (*2) -&gt; (+) | double | 146,167 us | [ 0.0, 0.2, ..., 20,000,001.0, 20,000,001.2 ] |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
</code></pre>
<p><a href="chapter7/./examples/par-algs/src/transform_exclusive_scan.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/transform_exclusive_scan"><code>std::transform_exclusive_scan</code></a></p>
<h3 id="transform-inclusive-scan"><a class="header" href="#transform-inclusive-scan">Transform Inclusive Scan</a></h3>
<p><code>std::transform_inclusive_scan</code> will perform a unary transformation and then performs a left inclusive scan on a range.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;execution&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

template &lt;typename time_t = std::chrono::microseconds&gt;
struct measure
{
    template &lt;typename F, typename... Args&gt;
    static auto execution(F func, Args&amp;&amp;... args) 
        -&gt; typename time_t::rep
    {
        auto start = std::chrono::system_clock::now();
        std::invoke(func, std::forward&lt;Args&gt;(args)...);
        auto duration = std::chrono::duration_cast&lt;time_t&gt;(std::chrono::system_clock::now() - start);
        return duration.count();
    }
};

template&lt;typename T&gt;
auto operator&lt;&lt; 
(std::ostream&amp; os, const std::vector&lt;T&gt;&amp; v) -&gt; std::ostream&amp;
{
    os &lt;&lt; &quot;[ &quot;;
    for (auto i { v.size() }; const auto&amp; e : v)
        if (--i &gt; (v.size() - 3))
            os &lt;&lt; e &lt;&lt; &quot;, &quot;;

    auto last = v.end() - 3;
    os &lt;&lt; &quot;..., &quot; &lt;&lt; *++last &lt;&lt; &quot;, &quot;;
    os &lt;&lt; *++last &lt;&lt; &quot; ]&quot;;
    return os;
}

auto main() -&gt; int
{
    auto v = std::vector&lt;double&gt;(100'000'007, 0.1);
    auto r = std::vector&lt;double&gt;(100'000'007, 0.0);
    auto times2 = [](const auto&amp; x){ return x * 2; };
    std::cout.imbue(std::locale(&quot;en_US.UTF-8&quot;));
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1);
    
    std::cout &lt;&lt; &quot;+-------------------------------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;|           Algorithm           | Exec Policy | Operations  |  Type  |    Time    |                    Result                     |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_exclusive_scan | Sequencial  | (*2) -&gt; (+) | double | &quot;;
    auto seq_time = measure&lt;&gt;::execution([&amp;](const auto&amp; v, auto&amp; r){  std::transform_exclusive_scan(std::execution::seq, v.begin(), v.end(), r.begin(), 0.0, std::plus&lt;&gt;{}, times2); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; seq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_exclusive_scan |  Parallel   | (*2) -&gt; (+) | double | &quot;;
    auto par_time = measure&lt;&gt;::execution([&amp;](const auto&amp; v, auto&amp; r){  std::transform_exclusive_scan(std::execution::par, v.begin(), v.end(), r.begin(), 0.0, std::plus&lt;&gt;{}, times2); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_exclusive_scan | Unsequenced | (*2) -&gt; (+) | double | &quot;;
    auto unseq_time = measure&lt;&gt;::execution([&amp;](const auto&amp; v, auto&amp; r){  std::transform_exclusive_scan(std::execution::unseq, v.begin(), v.end(), r.begin(), 0.0, std::plus&lt;&gt;{}, times2); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_exclusive_scan |  Par-Unseq  | (*2) -&gt; (+) | double | &quot;;
    auto par_unseq_time = measure&lt;&gt;::execution([&amp;](const auto&amp; v, auto&amp; r){  std::transform_exclusive_scan(std::execution::par_unseq, v.begin(), v.end(), r.begin(), 0.0, std::plus&lt;&gt;{}, times2); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

./build/transform_inclusive_scan
+-------------------------------+-------------+-------------+--------+------------+-----------------------------------------------+
|           Algorithm           | Exec Policy | Operations  |  Type  |    Time    |                    Result                     |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
| std::transform_inclusive_scan | Sequencial  | (*2) -&gt; (+) | double | 120,220 us | [ 0.2, 0.4, ..., 20,000,001.2, 20,000,001.4 ] |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
| std::transform_inclusive_scan |  Parallel   | (*2) -&gt; (+) | double | 148,472 us | [ 0.2, 0.4, ..., 20,000,001.2, 20,000,001.4 ] |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
| std::transform_inclusive_scan | Unsequenced | (*2) -&gt; (+) | double | 135,489 us | [ 0.2, 0.4, ..., 20,000,001.2, 20,000,001.4 ] |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
| std::transform_inclusive_scan |  Par-Unseq  | (*2) -&gt; (+) | double | 150,443 us | [ 0.2, 0.4, ..., 20,000,001.2, 20,000,001.4 ] |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
</code></pre>
<p><a href="chapter7/./examples/par-algs/src/transform_inclusive_scan.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/transform_inclusive_scan"><code>std::transform_inclusive_scan</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomics"><a class="header" href="#atomics">Atomics</a></h1>
<h2 id="data-races--shared-resources"><a class="header" href="#data-races--shared-resources">Data Races &amp; Shared Resources</a></h2>
<p>In any program, data is shared across multiple chapters of the system. This is largely not a problem because there is only a single thread accessing the data meaning all operations occur sequentially. This guarantees that data will only every be read from or written to but not both at the same time. However, when a program starts to introduce concurrency data now may be shared between different execution processes. This means that data can be read from or written at the same time causing a <em>Race Condition</em>. <em>Race Conditions</em> are UB in almost all programming languages as there is no way for the compiler or interpreter to tell which operation will happen first. There are many techniques to prevent and outright disallow race conditions from occur while still allowing for data to exist in a shared state. The first of which we will look at is <code>std::atomic</code>.</p>
<h2 id="atomic-types"><a class="header" href="#atomic-types">Atomic Types</a></h2>
<p><code>std::atomic</code> is a template class type that represents an <em>atomic-object</em>. Reading from and writing to an <em>atomic-object</em> at the same time is considered well defined. This is because operations are performed atomically meaning that no race conditions can occur as the <a href="https://en.cppreference.com/w/cpp/atomic/memory_order">memory order</a> must be specified. <code>std::atomic</code> can accept template types that are integrals, floating-points, pointers, <code>std::shared_ptr</code> or <code>std::weak_ptr</code>. It can also accept custom types that are trivially copyable and copy and move constructible/assignable. <code>std::atomic</code> also can be used to synchronize execution by blocking and notifying different executions processes. <code>std::atomic</code> itself cannot be copied or move. There is also <code>std::atomic_ref</code> which creates a reference to existing data for which all operations are atomic. The referred object's lifetime must exceed that of the atomic reference the underlying object can only be access through atomic references for the lifetime of all atomic references. <code>std::atomic_ref</code> can by copied.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;execution&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

template &lt;typename time_t = std::chrono::microseconds&gt;
struct measure
{
    template &lt;typename F, typename... Args&gt;
    static auto execution(F func, Args&amp;&amp;... args) 
        -&gt; std::pair&lt;typename time_t::rep, std::invoke_result_t&lt;F, Args...&gt;&gt;
    {
        auto start = std::chrono::system_clock::now();
        auto result = std::invoke(func, std::forward&lt;Args&gt;(args)...);
        auto duration = std::chrono::duration_cast&lt;time_t&gt;(std::chrono::system_clock::now() - start);
        return std::pair&lt;typename time_t::rep, std::invoke_result_t&lt;F, Args...&gt;&gt;{ duration.count(), result };
    }
};

auto main() -&gt; int
{
    auto count = std::atomic&lt;int&gt;{ 0 };
    auto v = std::vector&lt;double&gt;(100'000'007, 0.1);

    auto alg = [&amp;count](const auto&amp; v)
    { 
        return std::reduce(
            std::execution::par_unseq,
            v.begin(),
            v.end(),
            0.0,
            [&amp;count](const auto&amp; x, const auto&amp; y) {
                count.fetch_add(1, std::memory_order_relaxed);
                return x + y;
            }
        ); 
    };

    std::cout.imbue(std::locale(&quot;en_US.UTF-8&quot;));
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(4);
    
    auto [time, result] = measure&lt;&gt;::execution(alg, v);

    std::cout &lt;&lt; &quot;std::reduce (parallel-unsequenced execution):\n&quot;
              &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; &quot;\n&quot;
              &lt;&lt; &quot;Time: &quot; &lt;&lt; time &lt;&lt; &quot; us\n&quot;
              &lt;&lt; &quot;Atomic Count: &quot; &lt;&lt; count.load() &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<pre><code class="language-sh">bpt build -t build.yaml -o build

# ...

./build/atomic
std::reduce (parallel-unsequenced execution):
Result: 10,000,000.7000
Time: 1,699,214 us
Atomic Count: 100,000,007
</code></pre>
<p><a href="chapter7/./examples/atomic/src/atomic.main.cxx">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/atomic/atomic"><code>std::atomic</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/atomic/atomic_ref"><code>std::atomic_ref</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<h2 id="what-are-threads"><a class="header" href="#what-are-threads">What are Threads?</a></h2>
<p>Threads or threads of execution are the smallest sequence of instructions that is managed by a schedular of an operating system. Threads are a sub-object of a process. A process can have multiple threads allowing chapters of a process to run concurrently. In C++ we can spawn thread objects that will run a function until completion and then must be rejoined to the main thread or detached.</p>
<h2 id="thread"><a class="header" href="#thread">Thread</a></h2>
<p>C++ thread object is called <code>std::thread</code>. It takes as its first argument a function to run as well as any arguments that must be forwarded to the function. The function will begin to run immediately at the threads construction. Along with <code>std::thread</code> there is the <code>std::this_thread</code> namespaces which can get the ID or make the current thread sleep for some time. <code>std::thread</code> cannot be copied but can be moved.</p>
<pre><code class="language-cxx">#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;

using namespace std::literals;

auto work = [](std::atomic_ref&lt;int&gt; counter)
{
    std::osyncstream(std::cout) &lt;&lt; &quot;Doing work on thread: &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; ...\n&quot;;
    auto count = counter.fetch_add(1, std::memory_order_relaxed);
    std::osyncstream(std::cout) &lt;&lt; &quot;Call count: &quot; &lt;&lt; count &lt;&lt; &quot;\n&quot;;
    std::this_thread::sleep_for(1.5s);
    std::osyncstream(std::cout) &lt;&lt; &quot;Thread &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; Done!\n&quot;;
};

auto main() -&gt; int
{
    auto counter { 1 };
    auto atomic_counter = std::atomic_ref&lt;int&gt;{ counter };

    std::thread t1(work, atomic_counter);
    std::thread t2(work, atomic_counter);
    std::thread t3(work, atomic_counter);
    std::thread t4(work, atomic_counter);

    std::cout &lt;&lt; &quot;Waiting in main...\n&quot;;

    t1.join();
    t2.join();
    t3.join();
    t4.join();

    return 0;
}
</code></pre>
<blockquote>
<p>Note: Uses <a href="https://en.cppreference.com/w/cpp/io/basic_osyncstream"><code>std::osyncstream</code></a> to synchronize output.</p>
</blockquote>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

$ ./build/thread
Waiting in main...
Doing work on thread: 139836157400640 ...
Call count: 1
Doing work on thread: 139836174186048 ...
Doing work on thread: 139836149007936 ...
Call count: 3
Doing work on thread: 139836165793344 ...
Call count: 4
Call count: 2
Thread 139836157400640 Done!
Thread 139836149007936 Done!
Thread 139836165793344 Done!
Thread 139836174186048 Done!
</code></pre>
<p><a href="chapter7/./examples/thread/src/thread.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/thread/thread"><code>std::thread</code></a></p>
<h2 id="automatic-threads"><a class="header" href="#automatic-threads">Automatic Threads</a></h2>
<p>Since C++20 there has been a thread type that automatically joins on destruction. This is called <code>std::jthread</code>. <code>std::jthread</code> also supports the use of <code>std::stop_token</code> and <code>std::stop_source</code>. These are primitives for preemptively cancelling a <code>std::jthread</code> from other threads. The <code>std::stop_source</code> is obtained from a <code>std::jthread</code> object and can be passed to other threads. For a <code>std::jthread</code> to be able to listen for stop requests, the function it runs must takes as its first argument a <code>std::stop_token</code>.</p>
<pre><code class="language-cxx">#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;

using namespace std::literals;

auto job = [](std::stop_token tkn) 
{
    for (auto i { 10 }; i; --i) 
    {
        std::this_thread::sleep_for(150ms);

        if (tkn.stop_requested()) 
        {
            std::cout &lt;&lt; &quot;  The job has be requested to stop\n&quot;;
            return;
        }

        std::cout &lt;&lt; &quot; Continuing with job\n&quot;;
    }
};

auto stop_job = [](std::stop_source source) 
{
    std::this_thread::sleep_for(500ms);
    std::cout &lt;&lt; &quot;Request stop for worker via source\n&quot;;
    source.request_stop();
};

auto main() -&gt; int
{
    auto worker = std::jthread(job);
 
    std::cout &lt;&lt; &quot;\nPass source to other thread:\n&quot;;
 
    std::stop_source stop_source = worker.get_stop_source();
    auto stopper = std::thread(stop_job, stop_source);
    stopper.join();
    
    std::this_thread::sleep_for(250ms);

    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

$ ./build/jthread

Pass source to other thread:
 Continuing with job
 Continuing with job
 Continuing with job
Request stop for worker via source
  The job has be requested to stop
</code></pre>
<p><a href="chapter7/./examples/threads/src/jthread.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/thread/jthread"><code>std::jthread</code></a></p>
<h2 id="thread-pools"><a class="header" href="#thread-pools">Thread Pools</a></h2>
<p>A thread pool is a very common idiom in Computer Science. It involves creating a pool or array of threads that sit idle, waiting for work. Jobs are then pushed to the pool which get assigned to an available thread. Once the thread has finished the section the thread goes idle again. The most basic way to create a thread pool is to use a vector of threads and emplace jobs at the back of the vector and then join all joinable threads.</p>
<pre><code class="language-cxx">#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

using namespace std::literals;

auto job = [](auto job_id)
{ 
    std::this_thread::sleep_for(150ms);
    std::osyncstream(std::cout) &lt;&lt; &quot;Thread: &quot; 
                                &lt;&lt; std::this_thread::get_id()
                                &lt;&lt; &quot; is running job: &quot;
                                &lt;&lt; job_id
                                &lt;&lt; &quot;\n&quot;;
    std::this_thread::sleep_for(150ms);
};

auto main() -&gt; int
{    
    auto thr_count { std::thread::hardware_concurrency() };
    auto pool = std::vector&lt;std::thread&gt;();

    /// Queue jobs
    for (auto i { 0u }; i &lt; thr_count; ++i)
        pool.emplace_back(job, i);

    std::this_thread::sleep_for(200ms);

    /// Join all job threads
    for (auto&amp; th : pool)
        if (th.joinable())
            th.join();

    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

$ ./build/thread-pools
Thread: 140166858589760 is running job: 4
Thread: 140166841804352 is running job: 6
Thread: 140166866982464 is running job: 3
Thread: 140166816626240 is running job: 9
Thread: 140166875375168 is running job: 2
Thread: 140166833411648 is running job: 7
Thread: 140166766270016 is running job: 15
Thread: 140166774662720 is running job: 14
Thread: 140166892160576 is running job: 0
Thread: 140166825018944 is running job: 8
Thread: 140166883767872 is running job: 1
Thread: 140166850197056 is running job: 5
Thread: 140166799840832 is running job: 11
Thread: 140166783055424 is running job: 13
Thread: 140166791448128 is running job: 12
Thread: 140166808233536 is running job: 10
</code></pre>
<p><a href="chapter7/./examples/threads/src/thread-pools.main.cxx">Example</a></p>
<p><a href="https://en.wikipedia.org/wiki/Thread_pool">Thread Pools</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutexes--locks"><a class="header" href="#mutexes--locks">Mutexes &amp; Locks</a></h1>
<h2 id="what-is-a-mutex"><a class="header" href="#what-is-a-mutex">What is a Mutex?</a></h2>
<p>A mutex is a <em>mutually-exclusive-object</em>. It is used to synchronize access to shared memory resources across multiple threads. C++ mutex type is called <code>std::mutex</code> from the <code>&lt;mutex&gt;</code> header. Threads can own a <code>std::mutex</code> by locking it. Other threads will block when they try to lock a <code>std::mutex</code> owned by another thread. <code>std::mutex</code> also implement a try-lock that returns a Boolean indicating the result off the lock attempt. A thread cannot own a <code>std::mutex</code> before it tries to lock it. Mutexes are generally implemented as a OS primitive. Because <code>std::mutex</code> (and C++ other mutex types) use locking and unlocking methods to control access, these types are not considered to be RAII types. Instead there are locking types that will lock a mutex on construction and unlock it on destruction (more below).</p>
<pre><code class="language-cxx">#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;mutex&gt;
#include &lt;sstream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

using namespace std::literals;

auto mx  = std::mutex{};
auto map = std::map&lt;int, long long&gt;{};

auto job = [](auto job_id)
{ 
    std::this_thread::sleep_for(150ms);
    auto ss = std::stringstream{};
    ss &lt;&lt; std::this_thread::get_id();
    auto thread_id = std::stoll(ss.str());

    while (!mx.try_lock())
        std::this_thread::sleep_for(150ms);

    map.insert({ job_id, thread_id });
    mx.unlock();
    std::this_thread::sleep_for(150ms);
};

auto main() -&gt; int
{    
    auto thr_count { std::thread::hardware_concurrency() };
    auto pool = std::vector&lt;std::thread&gt;(thr_count);

    /// Queue jobs
    for (auto i { 0u }; i &lt; thr_count; ++i)
        pool.emplace_back(job, i);

    std::this_thread::sleep_for(200ms);

    /// Join all job threads
    for (auto&amp; th : pool)
        if (th.joinable())
            th.join();

    std::cout &lt;&lt; &quot;{ &quot;;
    for (auto i { map.size() }; auto&amp; [k, v] : map)
        std::cout &lt;&lt; k &lt;&lt; &quot;: &quot; &lt;&lt; v &lt;&lt; (i-- ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; }&quot; &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<pre><code class="language-sh">bpt build -t build.yaml -o build

# ...

./build/mutex
{ 0: 140667719128640, 1: 140667710735936, 2: 140667702343232, 3: 140667693950528, 4: 140667685557824, 5: 140667677165120, 6: 140667668772416, 7: 140667660379712, 8: 140667651987008, 9: 140667643594304, 10: 140667635201600, 11: 140667626808896, 12: 140667618416192, 13: 140667610023488, 14: 140667601630784, 15: 140667593238080,  }
</code></pre>
<p><a href="chapter7/./examples/mutex/src/mutex.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/thread/mutex"><code>std::mutex</code></a></p>
<h2 id="other-mutex-types"><a class="header" href="#other-mutex-types">Other Mutex Types</a></h2>
<ul>
<li>
<p><code>std::timed_mutex</code> - Mutex that offers timeout based locking methods. Locking will be attempted for a certain duration.</p>
</li>
<li>
<p><code>std::recursive_mutex</code> - Mutex that can be repeatedly locked by the same thread multiple times. Must be unlocked the same number of times to become fully unlocked.</p>
</li>
<li>
<p><code>std::recursive_timed_mutex</code> - Recursive mutex with timeout locking.</p>
</li>
<li>
<p><code>std::shared_mutex</code> - A mutex that offers to levels of access, <em>shared</em> or <em>exclusive</em>. Shared locking allows for multiple threads to share a mutex and read the shared memory resources while exclusive only allows one thread to access the shared resources with write privileges. If one thread has a shared lock an a mutex other threads can only gain a shared lock on it as well prohibiting the ability to gain exclusive access from another thread until all threads have unlocked the shared lock. Similarly, a thread with an exclusive lock on a thread disallows other threads from gaining any lock on the mutex until it has been unlocked.</p>
</li>
<li>
<p><code>std::shared_timed_mutex</code> - Same as a <code>std::shared_mutex</code> but offers timeout based exclusive and shared locking.</p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/thread/timed_mutex"><code>std::timed_mutex</code></a></p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/thread/recursive_mutex"><code>std::recursive_mutex</code></a></p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/thread/recursive_timed_mutex"><code>std::recursive_timed_mutex</code></a></p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/thread/shared_mutex"><code>std::shared_mutex</code></a></p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/thread/shared_timed_mutex"><code>std::shared_timed_mutex</code></a></p>
</li>
</ul>
<h2 id="what-is-a-lock"><a class="header" href="#what-is-a-lock">What is a lock?</a></h2>
<p>A lock is another kind of synchronization primitive. Locks can be used to wrap other synchronization primitives like mutexes and bind the locking and unlocking if the mutex to the lifetime of the lock using RAII or can themselves be synchronization primitives that must be acquires and released. Most locks in C++ perform the former which allow for mutex locking to be scoped ensuring proper releasing of resources even if exceptions are thrown. Locks however, can also be used erroneously creating <em>deadlocks</em> for which two threads rely on the releasing of each others locks in order to release their respective locks. They also have a little more overhead as you have to create and destroy locks. Locks will often be created in an unnamed scope to ensure that it only lives as long as it needs.</p>
<h2 id="semaphores"><a class="header" href="#semaphores">Semaphores</a></h2>
<p>The most simple type of lock is a semaphore. Semaphores allow multiple threads to access the same resource. The number of accessors is dictated by a count which decrements when the semaphore is acquires and blocks for any acquisitions for which the count is zero. C++ semaphore type which supports arbitrary size counts is called <code>std::counting_semaphore</code>. There is also a specialisation for which only a single accessor is allowed, called <code>std::binary_semaphore</code>. Both of these live in the <code>semaphore</code> header.</p>
<pre><code class="language-cxx">#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;semaphore&gt;
#include &lt;thread&gt;

using namespace std::literals;

auto toMain     = std::binary_semaphore{ 0 };
auto fromMain   = std::binary_semaphore{ 0 };

auto work = []()
{ 
    fromMain.acquire();

    std::cout &lt;&lt; &quot;[thread]: Got signal&quot; &lt;&lt; std::endl;
    std::this_thread::sleep_for(3s);
    std::cout &lt;&lt; &quot;[thread]: Sent signal&quot; &lt;&lt; std::endl;

    toMain.release();
};

auto main() -&gt; int
{    
    auto th = std::thread{ work };

    std::cout &lt;&lt; &quot;[Main]: Sent signal&quot; &lt;&lt; std::endl;
    fromMain.release();
    toMain.acquire();
    std::cout &lt;&lt; &quot;[Main]: Got signal&quot; &lt;&lt; std::endl;

    th.join();

    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

$ ./build/semaphores 
[Main]: Sent signal
[thread]: Got signal
[thread]: Sent signal
[Main]: Got signal
</code></pre>
<p><a href="chapter7/./examples/mutex/src/semaphores.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/thread/counting_semaphore"><code>std::counting_semaphore</code> &amp; <code>std::binary_semaphore</code></a></p>
<h2 id="lock-types"><a class="header" href="#lock-types">Lock Types</a></h2>
<ul>
<li><code>std::lock_guard</code> - The most basic kind of mutex locking wrapper. It binds the locking lifetime of a mutex to the lifetime of the lock. It takes a template type parameter of the mutex type and a mutex as a constructor argument. It can also adopt the ownership of a mutex by passing a second constructor argument <code>std::adopt_lock</code> which does not lock the mutex but ensuring the calling thread will unlock it. <code>std::lock_guard</code> is non-copyable.</li>
<li><code>std::scoped_lock</code> - A lock for acquiring ownership of zero or more mutexes for the duration of a scope block. When constructed and given ownership of multiple mutexes, the locking and unlocking of mutexes uses a deadlock avoidance algorithm.</li>
<li><code>std::unique_lock</code> - Used to acquire an exclusive lock on a mutex with deferred, time-constrained, recursive and transfer semantics for locking. It is non-copyable but is moveable.</li>
<li><code>std::shared_lock</code> - Used to gain shared access to a mutex with similar semantics to <code>std::unique_lock</code>. Used for locking a <code>std::shared_mutex</code> in a shared ownership model.</li>
</ul>
<pre><code class="language-cxx">#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;mutex&gt;
#include &lt;sstream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

using namespace std::literals;

auto mx  = std::mutex{};
auto map = std::map&lt;int, long long&gt;{};

auto job = [](auto job_id)
{ 
    std::this_thread::sleep_for(150ms);
    auto ss = std::stringstream{};
    ss &lt;&lt; std::this_thread::get_id();
    auto thread_id = std::stoll(ss.str());

    /// Acquire a lock on mx that lasts for this scope
    {
        auto lk = std::lock_guard{ mx };
        map.insert({ job_id, thread_id });
    }
    
    std::this_thread::sleep_for(150ms);
};

auto main() -&gt; int
{    
    auto thr_count { std::thread::hardware_concurrency() };
    auto pool = std::vector&lt;std::thread&gt;(thr_count);

    /// Queue jobs
    for (auto i { 0u }; i &lt; thr_count; ++i)
        pool.emplace_back(job, i);

    std::this_thread::sleep_for(200ms);

    /// Join all job threads
    for (auto&amp; th : pool)
        if (th.joinable())
            th.join();

    std::cout &lt;&lt; &quot;{ &quot;;
    for (auto i { map.size() }; auto&amp; [k, v] : map)
        std::cout &lt;&lt; k &lt;&lt; &quot;: &quot; &lt;&lt; v &lt;&lt; (i-- ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; }&quot; &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

$ ./build/locks
{ 0: 139998766057024, 1: 139998757664320, 2: 139998749271616, 3: 139998740878912, 4: 139998732486208, 5: 139998724093504, 6: 139998715700800, 7: 139998707308096, 8: 139998698915392, 9: 139998690522688, 10: 139998682129984, 11: 139998673737280, 12: 139998665344576, 13: 139998656951872, 14: 139998648559168, 15: 139998640166464,  }
</code></pre>
<p><a href="chapter7/./examples/mutex/src/locks.main.cxx">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/thread/lock_guard"><code>std::lock_guard</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/scoped_lock"><code>std:scoped_lock</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/unique_lock"><code>std::unique_lock</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/shared_lock"><code>std::shared_lock</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/lock_tag">Locking Strategies</a></li>
</ul>
<h2 id="latches"><a class="header" href="#latches">Latches</a></h2>
<p>A <code>std::latch</code> is count-down synchronization primitive with the count is initialized on construction. Threads can wait at a <code>std::latch</code> until the count reaches zero. Once this happens, all the threads waiting on the latch are released. <code>std::latch</code> cannot increment or reset its counter after construction making it a single use barrier. <code>std::latch</code> is non-copyable and lives in the <code>&lt;latch&gt;</code> header.</p>
<pre><code class="language-cxx">#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;latch&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

using namespace std::literals;

auto thr_count  = std::thread::hardware_concurrency();
auto done       = std::latch{ thr_count };
auto cleanup    = std::latch{ 1 };

auto job = [](auto job_id)
{ 
    std::this_thread::sleep_for(2s);
    std::osyncstream(std::cout) &lt;&lt; &quot;Job &quot; &lt;&lt; job_id &lt;&lt; &quot; done.\n&quot;;
    done.count_down();
    cleanup.wait();
    std::osyncstream(std::cout) &lt;&lt; &quot;Job &quot; &lt;&lt; job_id &lt;&lt; &quot; cleaned up.\n&quot;;
};

auto main() -&gt; int
{    
    auto pool = std::vector&lt;std::thread&gt;(thr_count);

    std::cout &lt;&lt; &quot;Starting jobs...\n&quot;;
    for (auto i { 0u }; i &lt; thr_count; ++i)
        pool.emplace_back(job, i);

    done.wait();
    std::cout &lt;&lt; &quot;All jobs done.\n&quot;;
    std::this_thread::sleep_for(200ms);
    std::cout &lt;&lt; &quot;\nStarting cleanup...\n&quot;;
    cleanup.count_down();
    std::this_thread::sleep_for(200ms);

    for (auto&amp; th : pool)
        if (th.joinable())
            th.join();
    std::cout &lt;&lt; &quot;All jobs cleaned up.\n&quot;;

    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

$ ./build/latch
Starting jobs...
Job 1 done.
Job 0 done.
Job 3 done.
Job 5 done.
Job 4 done.
Job 7 done.
Job 6 done.
Job 8 done.
Job 2 done.
Job 10 done.
Job 9 done.
Job 13 done.
Job 12 done.
Job 11 done.
Job 14 done.
Job 15 done.
All jobs done.

Starting cleanup...
Job 4 cleaned up.
Job 6 cleaned up.
Job 7 cleaned up.
Job 12 cleaned up.
Job 13 cleaned up.
Job 0 cleaned up.
Job 14 cleaned up.
Job 10 cleaned up.
Job 11 cleaned up.
Job 2 cleaned up.
Job 15 cleaned up.
Job 5 cleaned up.
Job 3 cleaned up.
Job 9 cleaned up.
Job 8 cleaned up.
Job 1 cleaned up.
All jobs cleaned up.
</code></pre>
<p><a href="chapter7/./examples/mutex/src/latch.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/thread/latch"><code>std::latch</code></a></p>
<h2 id="barriers"><a class="header" href="#barriers">Barriers</a></h2>
<p><code>std::barrier</code> is a more general version of <code>std::latch</code>. The lifetime of a <code>std::barrier</code> consists of one or more phases. The first is a synchronization phase for which threads will block where once the counter has reach zero for the <code>std::barrier</code> the threads will unblock. Right before unblocking, a completion function will run which is optionally supplied at the <code>std::barrier</code> construction. After this the <code>std::barrier</code> will reset its counter and can be reused. The overall count can be reduced on arrival by a thread. <code>std::barrier</code> is non-copyable and lives in the <code>&lt;barrier&gt;</code> header.</p>
<pre><code class="language-cxx">#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;barrier&gt;
#include &lt;syncstream&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

using namespace std::literals;

auto thr_count  = std::thread::hardware_concurrency();

auto on_completion = []() noexcept
{ 
    static auto message = &quot;All jobs done.\nWorkers are at lunch before cleaning up...\n&quot;s;
    std::osyncstream(std::cout) &lt;&lt; message;
    std::this_thread::sleep_for(3s);
    message = &quot;All cleaned up.\n&quot;s;
};

auto barrier = std::barrier{ thr_count, on_completion };

auto job = [](auto job_id)
{ 
    std::this_thread::sleep_for(2s);
    std::osyncstream(std::cout) &lt;&lt; &quot;Job &quot; &lt;&lt; job_id &lt;&lt; &quot; done.\n&quot;;
    barrier.arrive_and_wait();
    std::osyncstream(std::cout) &lt;&lt; &quot;Job &quot; &lt;&lt; job_id &lt;&lt; &quot; cleaned up.\n&quot;;
    barrier.arrive_and_wait();
};

auto main() -&gt; int
{    
    auto pool = std::vector&lt;std::thread&gt;(thr_count);

    std::cout &lt;&lt; &quot;Starting jobs...\n&quot;;
    for (auto i { 0u }; i &lt; thr_count; ++i)
        pool.emplace_back(job, i);

    std::this_thread::sleep_for(200ms);

    for (auto&amp; th : pool)
        if (th.joinable())
            th.join();
    
    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

$ ./build/barrier
Starting jobs...
Job 2 done.
Job 1 done.
Job 3 done.
Job 5 done.
Job 0 done.
Job 4 done.
Job 8 done.
Job 7 done.
Job 6 done.
Job 12 done.
Job 11 done.
Job 10 done.
Job 9 done.
Job 15 done.
Job 13 done.
Job 14 done.
All jobs done.
Workers are at lunch before cleaning up...
Job 2 cleaned up.
Job 8 cleaned up.
Job 1 cleaned up.
Job 0 cleaned up.
Job 6 cleaned up.
Job 3 cleaned up.
Job 14 cleaned up.
Job 4 cleaned up.
Job 11 cleaned up.
Job 15 cleaned up.
Job 12 cleaned up.
Job 9 cleaned up.
Job 13 cleaned up.
Job 7 cleaned up.
Job 5 cleaned up.
Job 10 cleaned up.
All cleaned up.
</code></pre>
<p><a href="chapter7/./examples/mutex/src/barrier.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/thread/barrier"><code>std::barrier</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asynchronous-programming"><a class="header" href="#asynchronous-programming">Asynchronous Programming</a></h1>
<p>Asynchronous programming is the ability to run functions an computations simultaneously while being able to communicate the results between different functions and execution paths.</p>
<h2 id="futures-and-promises"><a class="header" href="#futures-and-promises">Futures and Promises</a></h2>
<p>A promise; represented by the class <code>std::promise</code>, is a object that stores a value or exception that is retrieved by a <code>std::future</code> object. Semantically, this means that a; generally asynchronous function has promised a value to the caller of the asynchronous function but however, does not yet have the value. The future of a promised value is obtained directly from the <code>std::promise</code> object. The caller of the promised value can query, wait for or extract the value from the corresponding <code>std::future</code> object however, these may block if the result is not yet ready. The timeout methods will return a <code>std::future_status</code> object which is an enum indicating if the wait timed out, if the future is deferred (<em>lazy</em> loading) or ready. The value of a promise is communicated via a shared memory state between the <code>std::future</code> and <code>std::promise</code> objects. This shared state cannot be shared between different threads meaning that only one <code>std::future</code> can be used to obtain the result of a promised value. To enforce this <code>std::future</code> is move-only. A shared future can be obtained by called <code>std::future::share</code> to create a <code>std::shared_future</code> which claims ownership of the shared state such that the future can be copied between different threads. Promises and futures are found in the <code>&lt;future&gt;</code> header.</p>
<pre><code class="language-cxx">#include &lt;chrono&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;utility&gt;

using namespace std::literals;

auto job = [](std::promise&lt;int&gt;&amp;&amp; p, auto a, auto b)
{
    std::this_thread::sleep_for(3s);
    auto r = a + b;
    p.set_value(r);  
    std::this_thread::sleep_for(3s);
};


auto main() -&gt; int
{
    auto p = std::promise&lt;int&gt;{};
    auto f = p.get_future();

    auto th = std::thread(job, std::move(p), 4, 5);

    auto start = std::chrono::high_resolution_clock::now();
    std::cout &lt;&lt; &quot;Waiting for job...\n&quot;;
    auto r          = f.get();
    auto finish     = std::chrono::high_resolution_clock::now();
    auto duration   = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(finish - start).count();

    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; r &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Took: &quot; &lt;&lt; duration &lt;&lt; &quot; ms&quot; &lt;&lt; std::endl;

    th.join();

    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

$ ./build/futures
Waiting for job...
Result: 9
Took: 3000 ms
</code></pre>
<p><a href="chapter7/./examples/async/src/futures.main.cxx">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/thread/future"><code>std::future</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/shared_future"><code>std::shared_future</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/shared_future"><code>std::future</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/promise"><code>std::promise</code></a></li>
</ul>
<h2 id="async"><a class="header" href="#async">Async</a></h2>
<p>Another way to create asynchronous functions without having to deal with threads directly is to use <code>std::async</code>. This function will create an asynchronous section that will run according to a launch policy. The standard only defines two policies, this being <code>std::launch::async</code>; which will run a function a separate thread, or <code>std::launch::deferred</code> which will run the function lazily on the calling thread the first time the value is requested. <code>std::async</code> returns a <code>std::future</code> object that is used to query, wait for or extract the result of the asynchronous function. <code>std::async</code> is found in the <code>&lt;future&gt;</code> header.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;concepts&gt;
#include &lt;execution&gt;
#include &lt;future&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

template &lt;typename time_t = std::chrono::microseconds&gt;
struct measure
{
    template &lt;typename F, typename... Args&gt;
    static auto execution(F func, Args&amp;&amp;... args) 
        -&gt; std::pair&lt;typename time_t::rep, std::invoke_result_t&lt;F, Args...&gt;&gt;
    {
        auto start = std::chrono::system_clock::now();
        auto result = std::invoke(func, std::forward&lt;Args&gt;(args)...);
        auto duration = std::chrono::duration_cast&lt;time_t&gt;(std::chrono::system_clock::now() - start);
        return std::pair&lt;typename time_t::rep, std::invoke_result_t&lt;F, Args...&gt;&gt;{ duration.count(), result };
    }
};

template&lt;std::random_access_iterator I, std::sentinel_for&lt;I&gt; S, std::movable A&gt;
auto parallel_sum(I first, S last, A init) -&gt; A
{
    auto middle = first + ((last - first) / 2);
    
    /// Launch async sum on last half of the values 
    auto future = std::async(std::launch::async, parallel_sum&lt;I, S, A&gt;, middle, last, A{});
    
    /// Sum first half of the range locally.
    auto result = parallel_sum(first, middle, init);

    /// Obtain the future and sum with the result
    return result + future.get();
}

auto main() -&gt; int
{
    auto v1 = std::vector&lt;double&gt;(999, 0.1);
    auto v2 = std::vector&lt;double&gt;(100'000'007, 0.1);

    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(5);

    auto [acc_time_v1, acc_result_v1] = measure&lt;&gt;::execution([](const auto&amp; rng){ return std::accumulate(rng.begin(), rng.end(), 0.0); }, v1);
    std::cout &lt;&lt; &quot;std::accumulate : [v1 - 999 elements]\n&quot;;
    std::cout &lt;&lt; &quot;Time: &quot; &lt;&lt; acc_time_v1 &lt;&lt; &quot; us\n&quot;;
    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; acc_result_v1 &lt;&lt; std::endl;

    auto [reduce_time_v1, reduce_result_v1] = measure&lt;&gt;::execution([](const auto&amp; rng){ return std::reduce(std::execution::par, rng.begin(), rng.end(), 0.0); }, v1);
    std::cout &lt;&lt; &quot;std::reduce(std::execution::par) : [v1 - 999 elements]\n&quot;;
    std::cout &lt;&lt; &quot;Time: &quot; &lt;&lt; reduce_time_v1 &lt;&lt; &quot; us\n&quot;;
    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; reduce_result_v1 &lt;&lt; std::endl;

    auto [par_time_v1, par_result_v1] = measure&lt;&gt;::execution([](const auto&amp; rng){ return std::accumulate(rng.begin(), rng.end(), 0.0); }, v1);
    std::cout &lt;&lt; &quot;parallel_sum : [v1 - 999 elements]\n&quot;;
    std::cout &lt;&lt; &quot;Time: &quot; &lt;&lt; par_time_v1 &lt;&lt; &quot; us\n&quot;;
    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; par_result_v1 &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;------------------------------------------------------\n&quot;;

    auto [acc_time_v2, acc_result_v2] = measure&lt;&gt;::execution([](const auto&amp; rng){ return std::accumulate(rng.begin(), rng.end(), 0.0); }, v2);
    std::cout &lt;&lt; &quot;std::accumulate : [v2 - 100'000'007 elements]\n&quot;;
    std::cout &lt;&lt; &quot;Time: &quot; &lt;&lt; acc_time_v2 &lt;&lt; &quot; us\n&quot;;
    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; acc_result_v2 &lt;&lt; std::endl;

    auto [reduce_time_v2, reduce_result_v2] = measure&lt;&gt;::execution([](const auto&amp; rng){ return std::reduce(std::execution::par, rng.begin(), rng.end(), 0.0); }, v2);
    std::cout &lt;&lt; &quot;std::reduce(std::execution::par) : [v2 - 100'000'007 elements]\n&quot;;
    std::cout &lt;&lt; &quot;Time: &quot; &lt;&lt; reduce_time_v2 &lt;&lt; &quot; us\n&quot;;
    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; reduce_result_v2 &lt;&lt; std::endl;

    auto [par_time_v2, par_result_v2] = measure&lt;&gt;::execution([](const auto&amp; rng){ return std::accumulate(rng.begin(), rng.end(), 0.0); }, v2);
    std::cout &lt;&lt; &quot;parallel_sum : [v2 - 100'000'007 elements]\n&quot;;
    std::cout &lt;&lt; &quot;Time: &quot; &lt;&lt; par_time_v2 &lt;&lt; &quot; us\n&quot;;
    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; par_result_v2 &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

$ ./build/async
std::accumulate : [v1 - 999 elements]
Time: 2 us
Result: 99.90000
std::reduce(std::execution::par) : [v1 - 999 elements]
Time: 750 us
Result: 99.90000
parallel_sum : [v1 - 999 elements]
Time: 2 us
Result: 99.90000
------------------------------------------------------
std::accumulate : [v2 - 100'000'007 elements]
Time: 178779 us
Result: 10000000.68113
std::reduce(std::execution::par) : [v2 - 100'000'007 elements]
Time: 19993 us
Result: 10000000.70009
parallel_sum : [v2 - 100'000'007 elements]
Time: 153180 us
Result: 10000000.68113
</code></pre>
<p><a href="chapter7/./examples/async/src/async.main.cxx">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/thread/async"><code>std::async</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/launch"><code>std::launch</code></a></li>
</ul>
<h2 id="packaged-sections"><a class="header" href="#packaged-sections">Packaged Sections</a></h2>
<p>The final way to create a future value is the use of <code>std::packaged_task</code>. This wraps a callable such that its result type is held in a shared state that can be accesses by a <code>std::future</code> object created from the section. <code>std::packaged_task</code> objects can be moved to <code>std::thread</code> and <code>std::jthread</code> objects so that the return value of a section can be acquired from a thread (which usually discards it). <code>std::packaged_task</code> is move-only and is found in the <code>&lt;future&gt;</code> header.</p>
<pre><code class="language-cxx">#include &lt;chrono&gt;
#include &lt;future&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;utility&gt;

using namespace std::literals;

auto job = [](auto a, auto b)
{
    std::this_thread::sleep_for(150ms);
    auto r = a + b;
    std::this_thread::sleep_for(150ms);
    return r;
};

auto main() -&gt; int
{
    auto pkg    = std::packaged_task&lt;int(int, int)&gt;{ job };
    auto f      = pkg.get_future();

    auto th = std::thread(std::move(pkg), 4, 5);

    auto start = std::chrono::high_resolution_clock::now();
    std::cout &lt;&lt; &quot;Waiting for job...\n&quot;;
    auto r          = f.get();
    auto finish     = std::chrono::high_resolution_clock::now();
    auto duration   = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(finish - start).count();

    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; r &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Took: &quot; &lt;&lt; duration &lt;&lt; &quot; ms&quot; &lt;&lt; std::endl;

    th.join();

    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

$ ./build/packaged_task
Waiting for job...
Result: 9
Took: 300 ms
</code></pre>
<p><a href="chapter7/./examples/async/src/packaged_task.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/thread/packaged_task"><code>std::packaged_task</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slides-6"><a class="header" href="#slides-6">Slides</a></h1>
<p><img src="chapter7/./imgs/hpp_chapter7-01.png" alt="Slides 01" />
<img src="chapter7/./imgs/hpp_chapter7-02.png" alt="Slides 02" />
<img src="chapter7/./imgs/hpp_chapter7-03.png" alt="Slides 03" />
<img src="chapter7/./imgs/hpp_chapter7-04.png" alt="Slides 04" />
<img src="chapter7/./imgs/hpp_chapter7-05.png" alt="Slides 05" />
<img src="chapter7/./imgs/hpp_chapter7-06.png" alt="Slides 06" />
<img src="chapter7/./imgs/hpp_chapter7-07.png" alt="Slides 07" />
<img src="chapter7/./imgs/hpp_chapter7-08.png" alt="Slides 08" />
<img src="chapter7/./imgs/hpp_chapter7-09.png" alt="Slides 09" />
<img src="chapter7/./imgs/hpp_chapter7-10.png" alt="Slides 10" />
<img src="chapter7/./imgs/hpp_chapter7-11.png" alt="Slides 11" />
<img src="chapter7/./imgs/hpp_chapter7-12.png" alt="Slides 12" />
<img src="chapter7/./imgs/hpp_chapter7-13.png" alt="Slides 13" />
<img src="chapter7/./imgs/hpp_chapter7-14.png" alt="Slides 14" />
<img src="chapter7/./imgs/hpp_chapter7-15.png" alt="Slides 15" />
<img src="chapter7/./imgs/hpp_chapter7-16.png" alt="Slides 16" />
<img src="chapter7/./imgs/hpp_chapter7-17.png" alt="Slides 17" />
<img src="chapter7/./imgs/hpp_chapter7-18.png" alt="Slides 18" />
<img src="chapter7/./imgs/hpp_chapter7-19.png" alt="Slides 19" />
<img src="chapter7/./imgs/hpp_chapter7-20.png" alt="Slides 20" />
<img src="chapter7/./imgs/hpp_chapter7-21.png" alt="Slides 21" />
<img src="chapter7/./imgs/hpp_chapter7-22.png" alt="Slides 22" />
<img src="chapter7/./imgs/hpp_chapter7-23.png" alt="Slides 23" />
<img src="chapter7/./imgs/hpp_chapter7-24.png" alt="Slides 24" />
<img src="chapter7/./imgs/hpp_chapter7-25.png" alt="Slides 25" />
<img src="chapter7/./imgs/hpp_chapter7-26.png" alt="Slides 26" />
<img src="chapter7/./imgs/hpp_chapter7-27.png" alt="Slides 27" />
<img src="chapter7/./imgs/hpp_chapter7-28.png" alt="Slides 28" />
<img src="chapter7/./imgs/hpp_chapter7-29.png" alt="Slides 29" />
<img src="chapter7/./imgs/hpp_chapter7-30.png" alt="Slides 30" />
<img src="chapter7/./imgs/hpp_chapter7-31.png" alt="Slides 31" />
<img src="chapter7/./imgs/hpp_chapter7-32.png" alt="Slides 32" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="godbolt-links"><a class="header" href="#godbolt-links">Godbolt Links</a></h1>
<p>All Compiler Explorer links used.</p>
<p>format: &lt;chapter.task.subsections~unnamed&gt;</p>
<hr />
<ol>
<li><a href="/content/chapter1/examples/hello/hello.cxx">Example : 1.6.2</a></li>
<li><a href="/content/chapter1/examples/hello-bpt">Example : 1.6.5</a></li>
<li><a href="https://www.godbolt.org/z/GKxzfees6">Example : 1.7.1</a></li>
<li><a href="https://www.godbolt.org/z/xKMooTb4s">Example : 2.4.1~1</a></li>
<li><a href="https://www.godbolt.org/z/eeYqPbcaT">Example : 2.4.1~2</a></li>
<li><a href="https://www.godbolt.org/z/o9afoszjP">Example : 2.4.1~3</a></li>
<li><a href="https://www.godbolt.org/z/5Ps5ezhaT">Example : 2.4.1~4</a></li>
<li><a href="https://www.godbolt.org/z/E6GTExxEj">Example : 2.4.2</a></li>
<li><a href="https://www.godbolt.org/z/37b58aTjf">Example : 2.4.3</a></li>
<li><a href="https://www.godbolt.org/z/33hP5o4v7">Example : 2.4.4</a></li>
<li><a href="https://www.godbolt.org/z/8E4vTdPbc">Example : 2.4.5</a></li>
<li><a href="https://www.godbolt.org/z/3zoz1517r">Example : 2.5.2.1</a></li>
<li><a href="https://www.godbolt.org/z/s8rGc4heM">Example : 2.5.3</a></li>
<li><a href="https://www.godbolt.org/z/EK14h6fhd">Example : 2.6.1</a></li>
<li><a href="https://www.godbolt.org/z/v4EYf1n3j">Example : 2.6.2</a></li>
<li><a href="https://www.godbolt.org/z/asKsxKc1W">Example : 2.6.3.3</a></li>
<li><a href="https://www.godbolt.org/z/xqx3o4hW6">Example : 2.6.4</a></li>
<li><a href="https://www.godbolt.org/z/57hne667f">Example : 2.7.1</a></li>
<li><a href="https://www.godbolt.org/z/4dK3P17ax">Example : 2.7.2~1</a></li>
<li><a href="https://www.godbolt.org/z/31TcjvYrP">Example : 2.7.2~2</a></li>
<li><a href="https://www.godbolt.org/z/Md3Mfx3MK">Example : 2.7.2~3</a></li>
<li><a href="https://www.godbolt.org/z/4n4xYh7T8">Example : 2.7.3</a></li>
<li><a href="https://www.godbolt.org/z/nz6TYWodK">Example : 2.7.4</a></li>
<li><a href="https://www.godbolt.org/z/9oEfYrMMq">Example : 2.7.4.1</a></li>
<li><a href="https://www.godbolt.org/z/Pxa3G8T4o">Example : 2.8.1</a></li>
<li><a href="https://www.godbolt.org/z/od31P37d7">Example : 2.8.2</a></li>
<li><a href="https://www.godbolt.org/z/KKTrYP5Pe">Example : 2.8.3</a></li>
<li><a href="https://www.godbolt.org/z/P78T9c1Ev">Example : 2.8.4</a></li>
<li><a href="https://www.godbolt.org/z/Gx4P9jTej">Example : 2.9.2~1</a></li>
<li><a href="https://www.godbolt.org/z/radjo93bx">Example : 2.9.2~2</a></li>
<li><a href="https://www.godbolt.org/z/jeb77d165">Example : 2.9.2.3</a></li>
<li><a href="https://www.godbolt.org/z/aaf33YEYW">Example : 3.1.2</a></li>
<li><a href="https://www.godbolt.org/z/sed7Wcf7s">Example : 3.1.3</a></li>
<li><a href="https://www.godbolt.org/z/n9Ynd7fYq">Example : 3.1.4</a></li>
<li><a href="https://www.godbolt.org/z/qdx6csE7x">Example : 3.1.5</a></li>
<li><a href="https://www.godbolt.org/z/594hMbcz6">Example : 3.1.6</a></li>
<li><a href="https://www.godbolt.org/z/MPPczrWzd">Example : 3.1.7</a></li>
<li><a href="https://www.godbolt.org/z/eGs9PTvfb">Example : 3.2.2.1</a></li>
<li><a href="https://www.godbolt.org/z/r7or3x7Tj">Example : 3.2.3</a></li>
<li><a href="https://www.godbolt.org/z/v13hfhM54">Example : 3.3.2</a></li>
<li><a href="https://www.godbolt.org/z/fx7136qnv">Example : 3.3.3</a></li>
<li><a href="https://www.godbolt.org/z/7TWjK5rKe">Example : 3.4.2</a></li>
<li><a href="https://www.godbolt.org/z/as3rTWavj">Example : 3.4.3</a></li>
<li><a href="https://www.godbolt.org/z/dbcKqx53f">Example : 3.5.3</a></li>
<li><a href="https://www.godbolt.org/z/4Yo93e7Tr">Example : 3.5.4</a></li>
<li><a href="https://www.godbolt.org/z/hqT44PM7M">Example : 3.5.5</a></li>
<li><a href="https://www.godbolt.org/z/cbb95YWWj">Example : 3.5.5.1</a></li>
<li><a href="https://www.godbolt.org/z/jcMfrG76c">Example : 3.5.5.2</a></li>
<li><a href="https://www.godbolt.org/z/G1T1j84nE">Example : 3.5.6.1</a></li>
<li><a href="https://www.godbolt.org/z/39dPYooTW">Example : 3.5.6.2</a></li>
<li><a href="https://www.godbolt.org/z/PaonscnEG">Example : 3.5.6.3</a></li>
<li><a href="https://www.godbolt.org/z/jaevh6dna">Example : 4.1.2.1</a></li>
<li><a href="https://www.godbolt.org/z/6Gco6zsvs">Example : 4.1.3.2~1</a></li>
<li><a href="https://www.godbolt.org/z/qbzqKcffa">Example : 4.1.3.2~2</a></li>
<li><a href="https://www.godbolt.org/z/TjrWfM5Th">Example : 4.1.4.1</a></li>
<li><a href="https://www.godbolt.org/z/he59bKxPf">Example : 4.1.4.2</a></li>
<li><a href="https://www.godbolt.org/z/79T3hYvea">Example : 4.1.4.3~1</a></li>
<li><a href="https://www.godbolt.org/z/vfxG95Eqr">Example : 4.1.4.3~2</a></li>
<li><a href="https://www.godbolt.org/z/9oon3r944">Example : 4.2.1</a></li>
<li><a href="https://www.godbolt.org/z/r9PPxbYh5">Example : 4.2.2</a></li>
<li><a href="https://www.godbolt.org/z/afj6eEYe7">Example : 4.2.3</a></li>
<li><a href="https://www.godbolt.org/z/8PMbxxehb">Example : 4.3.1</a></li>
<li><a href="https://www.godbolt.org/z/c6E1vjzoK">Example : 4.3.1.2</a></li>
<li><a href="https://www.godbolt.org/z/Kqs6rvvMr">Example : 4.3.2</a></li>
<li><a href="https://www.godbolt.org/z/zGeTs8ozn">Example : 4.4.1</a></li>
<li><a href="https://www.godbolt.org/z/rqPz5hK45">Example : 4.4.2</a></li>
<li><a href="https://www.godbolt.org/z/aGvnrYPzn">Example : 4.4.3.1</a></li>
<li><a href="https://www.godbolt.org/z/fzMKbjWW3">Example : 4.4.3.2</a></li>
<li><a href="https://www.godbolt.org/z/6MbYMGGMz">Example : 4.5.1</a></li>
<li><a href="https://www.godbolt.org/z/MrorPKKxW">Example : 5.1.2</a></li>
<li><a href="https://www.godbolt.org/z/1hWjrhee7">Example : 5.1.2.1.1</a></li>
<li><a href="https://www.godbolt.org/z/Wr8av57cz">Example : 5.1.2.1.2</a></li>
<li><a href="https://www.godbolt.org/z/748dx3vG1">Example : 5.1.3.1</a></li>
<li><a href="https://www.godbolt.org/z/Wrne3b1nd">Example : 5.1.3.2</a></li>
<li><a href="https://www.godbolt.org/z/YYhf9baW3">Example : 5.1.3.3</a></li>
<li><a href="https://www.godbolt.org/z/TfGEWW7qM">Example : 5.1.3.4</a></li>
<li><a href="https://www.godbolt.org/z/TGoh9Yrjc">Example : 5.1.4.1</a></li>
<li><a href="https://www.godbolt.org/z/TG9WW74bo">Example : 5.1.4.3</a></li>
<li><a href="https://www.godbolt.org/z/xvcf57xcT">Example : 5.1.4.3.1</a></li>
<li><a href="https://www.godbolt.org/z/MxacvscTY">Example : 5.1.4.4</a></li>
<li><a href="https://www.godbolt.org/z/xvMdeq3n5">Example : 5.1.5</a></li>
<li><a href="https://www.godbolt.org/z/zrMs4EhKn">Example : 5.1.5.1</a></li>
<li><a href="https://www.godbolt.org/z/qT5v7aEPx">Example : 5.1.5.2</a></li>
<li><a href="https://www.godbolt.org/z/axj9Tbr4v">Example : 5.1.5.3</a></li>
<li><a href="https://www.godbolt.org/z/WxsGsfna4">Example : 5.2.4</a></li>
<li><a href="https://www.godbolt.org/z/nhbsbnE9b">Example : 5.2.5</a></li>
<li><a href="https://www.godbolt.org/z/4WKKrMsqn">Example : 5.2.5.1</a></li>
<li><a href="https://www.godbolt.org/z/4eqKcTT4s">Example : 5.2.6</a></li>
<li><a href="https://www.godbolt.org/z/sMxWcd1fM">Example : 5.3.2</a></li>
<li><a href="https://www.godbolt.org/z/nhnj3Ehne">Example : 5.3.2.1</a></li>
<li><a href="https://www.godbolt.org/z/zh97vevo3">Example : 5.3.2.2</a></li>
<li><a href="https://www.godbolt.org/z/v5sP6TjYs">Example : 5.3.3</a></li>
<li><a href="https://www.godbolt.org/z/ax688eds3">Example : 5.3.3.1</a></li>
<li><a href="https://www.godbolt.org/z/5v8zb998o">Example : 5.3.3.2</a></li>
<li><a href="https://www.godbolt.org/z/P9b3EMGdY">Example : 5.4.1</a></li>
<li><a href="https://www.godbolt.org/z/Px75v8ssf">Example : 5.4.2</a></li>
<li><a href="https://www.godbolt.org/z/1f1x8MTer">Example : 5.4.3</a></li>
<li><a href="https://www.godbolt.org/z/55dhT6W6j">Example : 5.4.4</a></li>
<li><a href="https://www.godbolt.org/z/763Y6fjjc">Example : 5.4.4.1</a></li>
<li><a href="https://www.godbolt.org/z/nqxoE7466">Example : 5.4.4.2</a></li>
<li><a href="https://www.godbolt.org/z/vcGW1qPY9">Example : 5.4.5</a></li>
<li><a href="https://www.godbolt.org/z/MG7q3d63a">Example : 6.1.3</a></li>
<li><a href="https://www.godbolt.org/z/jeGjnrWvn">Example : 6.1.4.1</a></li>
<li><a href="https://www.godbolt.org/z/P17PEnsaE">Example : 6.1.4.2</a></li>
<li><a href="https://www.godbolt.org/z/9dzsjn1eM">Example : 6.1.5</a></li>
<li><a href="https://www.godbolt.org/z/sYhf5rG6r">Example : 6.2.2.1</a></li>
<li><a href="https://www.godbolt.org/z/Tnx49fajv">Example : 6.2.2.2</a></li>
<li><a href="https://www.godbolt.org/z/Y5c4z67Pz">Example : 6.2.2.3</a></li>
<li><a href="https://www.godbolt.org/z/YfoWacKcK">Example : 6.2.2.4</a></li>
<li><a href="https://www.godbolt.org/z/P8E99q43c">Example : 6.2.3.1</a></li>
<li><a href="https://www.godbolt.org/z/Wb5xPhraq">Example : 6.2.3.2</a></li>
<li><a href="https://www.godbolt.org/z/ro5MaxeEG">Example : 6.2.3.3</a></li>
<li><a href="https://www.godbolt.org/z/G97n97r3G">Example : 6.2.4.1</a></li>
<li><a href="https://www.godbolt.org/z/qj5bq9fze">Example : 6.2.4.2</a></li>
<li><a href="https://www.godbolt.org/z/heKfcz6K1">Example : 6.2.4.3</a></li>
<li><a href="https://www.godbolt.org/z/1qnYTWxMb">Example : 6.2.5.1</a></li>
<li><a href="https://www.godbolt.org/z/n57nYonqs">Example : 6.2.5.2</a></li>
<li><a href="https://www.godbolt.org/z/W1croE686">Example : 6.3.3</a></li>
<li><a href="https://www.godbolt.org/z/d9K618hhn">Example : 6.3.4.1</a></li>
<li><a href="https://www.godbolt.org/z/48jfqqdcd">Example : 6.3.4.2</a></li>
<li><a href="https://www.godbolt.org/z/GM1rrW68P">Example : 6.3.4.3</a></li>
<li><a href="https://www.godbolt.org/z/KhqvGao43">Example : 6.3.5.1</a></li>
<li><a href="https://www.godbolt.org/z/51cqjG8Pb">Example : 6.3.5.2</a></li>
<li><a href="https://www.godbolt.org/z/WMxqEezfn">Example : 6.3.5.3</a></li>
<li><a href="https://www.godbolt.org/z/xq7cerxYf">Example : 6.3.5.4</a></li>
<li><a href="https://www.godbolt.org/z/eTK3jaKb7">Example : 6.3.5.5</a></li>
<li><a href="https://www.godbolt.org/z/jrhM39hz4">Example : 6.3.6.1</a></li>
<li><a href="https://www.godbolt.org/z/3eqcdfG4f">Example : 6.3.6.2</a></li>
<li><a href="https://www.godbolt.org/z/Er64q3T3b">Example : 6.3.6.3</a></li>
<li><a href="https://www.godbolt.org/z/cjT6vEd7M">Example : 6.3.6.4</a></li>
<li><a href="https://www.godbolt.org/z/9n9WjerzG">Example : 6.3.6.5</a></li>
<li><a href="https://www.godbolt.org/z/YTnEn1o7d">Example : 6.3.6.6</a></li>
<li><a href="https://www.godbolt.org/z/rr6PPbb8a">Example : 6.3.6.7</a></li>
<li><a href="https://www.godbolt.org/z/cjY6W7cPe">Example : 6.3.6.8</a></li>
<li><a href="https://www.godbolt.org/z/G8Y9dchEv">Example : 6.3.7.1</a></li>
<li><a href="https://www.godbolt.org/z/5xejqWf6s">Example : 6.3.7.2</a></li>
<li><a href="https://www.godbolt.org/z/q5sWsrK1x">Example : 6.3.7.3</a></li>
<li><a href="https://www.godbolt.org/z/v3jEMP4c1">Example : 6.3.7.4</a></li>
<li><a href="https://www.godbolt.org/z/schxqWbo3">Example : 6.3.7.5</a></li>
<li><a href="https://www.godbolt.org/z/YnWdvq1nv">Example : 6.3.7.6</a></li>
<li><a href="https://www.godbolt.org/z/rbvK3P1ah">Example : 6.3.7.7</a></li>
<li><a href="https://www.godbolt.org/z/fs1T64vq5">Example : 6.3.8.1</a></li>
<li><a href="https://www.godbolt.org/z/YqovzcTYM">Example : 6.3.8.2</a></li>
<li><a href="https://www.godbolt.org/z/hddx535Wj">Example : 6.3.8.3</a></li>
<li><a href="https://www.godbolt.org/z/jj69vr5qe">Example : 6.3.8.4</a></li>
<li><a href="https://www.godbolt.org/z/57ssP7P36">Example : 6.3.9.1</a></li>
<li><a href="https://www.godbolt.org/z/oz1179Gn6">Example : 6.3.9.2</a></li>
<li><a href="https://www.godbolt.org/z/s3GrYnv1a">Example : 6.3.9.3</a></li>
<li><a href="https://www.godbolt.org/z/6bdKa63j4">Example : 6.4.1</a></li>
<li><a href="https://www.godbolt.org/z/sE5Eq5a3z">Example : 6.5.1</a></li>
<li><a href="https://www.godbolt.org/z/brff8rY5T">Example : 6.5.3</a></li>
<li><a href="https://www.godbolt.org/z/3fdW1P7hj">Example : 6.5.5</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="planned-additions"><a class="header" href="#planned-additions">Planned Additions</a></h1>
<ul>
<li>Separate installation for different OS
<ul>
<li>Windows</li>
<li>Linux</li>
<li>MacOS</li>
<li>WSL</li>
</ul>
</li>
<li>Coroutines (Chapter 7)</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
