<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Data Structures - High Performance Programming</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Monash DeepNeuron&#x27;s High Performance Programming Curriculum">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../home.html">Home</a></li><li class="chapter-item expanded affix "><div>Foreword</div></li><li class="chapter-item expanded "><a href="../chapter1/chapter1.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter1/wsl.html"><strong aria-hidden="true">1.1.</strong> WSL</a></li><li class="chapter-item expanded "><a href="../chapter1/software.html"><strong aria-hidden="true">1.2.</strong> Installing Software</a></li><li class="chapter-item expanded "><a href="../chapter1/helloworld.html"><strong aria-hidden="true">1.3.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="../chapter1/godbolt.html"><strong aria-hidden="true">1.4.</strong> Compiler Explorer</a></li><li class="chapter-item expanded "><a href="../chapter1/slides1.html"><strong aria-hidden="true">1.5.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter2/chapter2.html"><strong aria-hidden="true">2.</strong> Basics of C++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter2/typesystem.html"><strong aria-hidden="true">2.1.</strong> The C++ Type System</a></li><li class="chapter-item expanded "><a href="../chapter2/types.html"><strong aria-hidden="true">2.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../chapter2/variables.html"><strong aria-hidden="true">2.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../chapter2/operators.html"><strong aria-hidden="true">2.4.</strong> Operators</a></li><li class="chapter-item expanded "><a href="../chapter2/io.html"><strong aria-hidden="true">2.5.</strong> IO</a></li><li class="chapter-item expanded "><a href="../chapter2/eqordlogic.html"><strong aria-hidden="true">2.6.</strong> Equality, Ordering &amp; Logical Operators</a></li><li class="chapter-item expanded "><a href="../chapter2/condexpr.html"><strong aria-hidden="true">2.7.</strong> Conditional Expressions</a></li><li class="chapter-item expanded "><a href="../chapter2/loops.html"><strong aria-hidden="true">2.8.</strong> Loops</a></li><li class="chapter-item expanded "><a href="../chapter2/functions.html"><strong aria-hidden="true">2.9.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../chapter2/slides2.html"><strong aria-hidden="true">2.10.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter3/chapter3.html"><strong aria-hidden="true">3.</strong> Memory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter3/pointers.html"><strong aria-hidden="true">3.1.</strong> Pointers</a></li><li class="chapter-item expanded "><a href="../chapter3/slices.html"><strong aria-hidden="true">3.2.</strong> Slices</a></li><li class="chapter-item expanded "><a href="../chapter3/references.html"><strong aria-hidden="true">3.3.</strong> References</a></li><li class="chapter-item expanded "><a href="../chapter3/memory.html"><strong aria-hidden="true">3.4.</strong> Dynamic Memory</a></li><li class="chapter-item expanded "><a href="../chapter3/stdlib.html"><strong aria-hidden="true">3.5.</strong> The Standard Library</a></li><li class="chapter-item expanded "><a href="../chapter3/slides3.html"><strong aria-hidden="true">3.6.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter4/chapter4.html"><strong aria-hidden="true">4.</strong> Intermediate C++ Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter4/advfunc.html"><strong aria-hidden="true">4.1.</strong> Advanced Function Concepts</a></li><li class="chapter-item expanded "><a href="../chapter4/namespaces.html"><strong aria-hidden="true">4.2.</strong> Namespaces</a></li><li class="chapter-item expanded "><a href="../chapter4/enums.html"><strong aria-hidden="true">4.3.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="../chapter4/unions.html"><strong aria-hidden="true">4.4.</strong> Unions</a></li><li class="chapter-item expanded "><a href="../chapter4/structs.html"><strong aria-hidden="true">4.5.</strong> Structures</a></li><li class="chapter-item expanded "><a href="../chapter4/task1.html"><strong aria-hidden="true">4.6.</strong> Task 1</a></li><li class="chapter-item expanded "><a href="../chapter4/slides4.html"><strong aria-hidden="true">4.7.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter5/chapter5.html"><strong aria-hidden="true">5.</strong> Generic Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter5/classes.html"><strong aria-hidden="true">5.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="../chapter5/templates.html"><strong aria-hidden="true">5.2.</strong> Templates</a></li><li class="chapter-item expanded "><a href="../chapter5/generics.html"><strong aria-hidden="true">5.3.</strong> Generics</a></li><li class="chapter-item expanded "><a href="../chapter5/concepts.html"><strong aria-hidden="true">5.4.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="../chapter5/task2.html"><strong aria-hidden="true">5.5.</strong> Task 2</a></li><li class="chapter-item expanded "><a href="../chapter5/slides5.html"><strong aria-hidden="true">5.6.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter6/chapter6.html"><strong aria-hidden="true">6.</strong> Algorithms &amp; Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter6/iterators.html"><strong aria-hidden="true">6.1.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="../chapter6/data-structures.html" class="active"><strong aria-hidden="true">6.2.</strong> Data Structures</a></li><li class="chapter-item expanded "><a href="../chapter6/algorithms.html"><strong aria-hidden="true">6.3.</strong> Algorithms</a></li><li class="chapter-item expanded "><a href="../chapter6/ranges.html"><strong aria-hidden="true">6.4.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="../chapter6/views.html"><strong aria-hidden="true">6.5.</strong> Views</a></li><li class="chapter-item expanded "><a href="../chapter6/task3.html"><strong aria-hidden="true">6.6.</strong> Task 3</a></li><li class="chapter-item expanded "><a href="../chapter6/slides6.html"><strong aria-hidden="true">6.7.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter7/chapter7.html"><strong aria-hidden="true">7.</strong> Concurrent Computing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter7/parallel-alg.html"><strong aria-hidden="true">7.1.</strong> Parallel Algorithms</a></li><li class="chapter-item expanded "><a href="../chapter7/atomics.html"><strong aria-hidden="true">7.2.</strong> Atomics</a></li><li class="chapter-item expanded "><a href="../chapter7/threads.html"><strong aria-hidden="true">7.3.</strong> Threads</a></li><li class="chapter-item expanded "><a href="../chapter7/mutexes.html"><strong aria-hidden="true">7.4.</strong> Mutexes</a></li><li class="chapter-item expanded "><a href="../chapter7/async.html"><strong aria-hidden="true">7.5.</strong> Asynchronous Programming</a></li><li class="chapter-item expanded "><a href="../chapter7/slides7.html"><strong aria-hidden="true">7.6.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../GODBOLT.html">Godbolt Examples</a></li><li class="chapter-item expanded affix "><a href="../planned.html">Planned Additions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">High Performance Programming</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/MonashDeepNeuron/HPP" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h1>
<h2 id="what-is-a-data-structure"><a class="header" href="#what-is-a-data-structure">What is a Data Structure</a></h2>
<p>Data structures are a fundamental concept in computer science. Data structures are types or classes used to organise and manage data. Data structures differ primarily by their internal means of organising the data they manage to be as optimal as possible and often support various different operations. Using the correct data structure can be a difficult question to answer, particularly in C++ where many operation on these most basic data structures are expected to have as little size and time overhead.</p>
<p>This section mostly goes into a high level look at the data structures or containers available in C++, how they work and to give an idea of when one might use them. All containers have methods for obtaining iterators to their first and last element and all work with a <em>range-for</em> loop.</p>
<h2 id="sequence-containers"><a class="header" href="#sequence-containers">Sequence Containers</a></h2>
<p>Sequence containers are <em>Array-Like</em> containers in the sense that they model their data as a 1D array of values. Along with slices and <code>std::array</code>, C++ offers four other sequence based containers.</p>
<h3 id="vector"><a class="header" href="#vector">Vector</a></h3>
<p><code>std::vector</code> is the most fundamental container in C++. It models a contiguous dynamic array. It has constant (\( O(1) \)) index-based random access to elements. Vectors offer random access insertion and erasure of elements as well as efficient pushing and popping of elements at the end of the vector. Indexing is <strong>0-based</strong> which is the same for all index based containers. Insertion and erasure is less efficient anywhere in the vector that is not the back (\( O(n) \) where \( n \) is the number elements past the insertion or erasure) as all elements past the insertion or erasure have to be moved back one cell. Insertion and erasure also (has a chance of [invalidating]) invalidates any iterators or references of the shifted elements. Vectors can reserve more memory then it currently uses in order to make any operations involving potential allocations more efficient by pre-allocating the resources. Erasures also do not remove the memory owned by the vector but save it for later use.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;vector&gt;

template&lt;typename T&gt;
auto println(const std::vector&lt;T&gt;&amp; v) -&gt; void
{
    std::cout &lt;&lt; &quot;[ &quot;;
    for (auto i { v.size() }; const auto&amp; e : v)
        std::cout &lt;&lt; e &lt;&lt; (--i ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; ]&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto v = std::vector&lt;int&gt;{ 1, 2, 3, 4, 5 };

    println(v);
    v.push_back(6);
    println(v);
    v.pop_back();
    v.pop_back();
    println(v);
    v.insert(v.begin() + 3, 77);
    println(v);
    v.erase(v.end() - 4);
    println(v);

    std::cout &lt;&lt; &quot;v[4] = &quot; &lt;&lt; v[4] &lt;&lt; std::endl;        ///&lt; Unsafe version
    std::cout &lt;&lt; &quot;v.at(2) = &quot; &lt;&lt; v.at(2) &lt;&lt; std::endl;  ///&lt; Range checked

    std::cout &lt;&lt; &quot;Before v.shrink_to_fit()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; v.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Capacity: &quot; &lt;&lt; v.capacity() &lt;&lt; std::endl;
    println(v);

    v.shrink_to_fit();

    std::cout &lt;&lt; &quot;After v.shrink_to_fit()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; v.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Capacity: &quot; &lt;&lt; v.capacity() &lt;&lt; std::endl;
    println(v);

    v.clear();
    std::cout &lt;&lt; &quot;After v.clear()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; v.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Capacity: &quot; &lt;&lt; v.capacity() &lt;&lt; std::endl;
    println(v);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/sYhf5rG6r">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/vector"><code>std::vector</code></a></p>
<h3 id="deque"><a class="header" href="#deque">Deque</a></h3>
<p><code>std::deque</code> is a double ended queue that offers efficient (\( O(1) \)) insertion and erasure at both the front and back of a deque while also never invalidating iterators and references to the rest of the elements. Deques elements are not stored contiguously resulting in a larger memory footprint due to 'book-keeping' data for smaller deques when compared to vectors. Deques also have two indirections to get elements compared to vectors single indirection. Deques also cannot reserve extra memory for later use.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;deque&gt;

template&lt;typename T&gt;
auto println(const std::deque&lt;T&gt;&amp; dq) -&gt; void
{
    std::cout &lt;&lt; &quot;[&gt; &quot;;
    for (auto i { dq.size() }; const auto&amp; e : dq)
        std::cout &lt;&lt; e &lt;&lt; (--i ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; &lt;]&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto dq = std::deque&lt;int&gt;{ 1, 2, 3, 4, 5 };

    println(dq);
    dq.push_back(6);
    println(dq);
    dq.pop_back();
    dq.pop_back();
    println(dq);
    dq.push_front(33);
    dq.push_front(914);
    dq.push_front(-44);
    dq.push_front(0);
    println(dq);
    dq.pop_front();
    dq.pop_front();
    println(dq);

    dq.insert(dq.begin() + 3, 77);
    println(dq);
    dq.erase(dq.end() - 4);
    println(dq);

    std::cout &lt;&lt; &quot;dq[4] = &quot; &lt;&lt; dq[4] &lt;&lt; std::endl;        ///&lt; Unsafe version
    std::cout &lt;&lt; &quot;dq.at(2) = &quot; &lt;&lt; dq.at(2) &lt;&lt; std::endl;  ///&lt; Range checked

    std::cout &lt;&lt; &quot;Before dq.shrink_to_fit()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; dq.size() &lt;&lt; std::endl;
    println(dq);

    dq.shrink_to_fit();

    std::cout &lt;&lt; &quot;After dq.shrink_to_fit()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; dq.size() &lt;&lt; std::endl;
    println(dq);

    dq.clear();
    std::cout &lt;&lt; &quot;After dq.clear()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; dq.size() &lt;&lt; std::endl;
    println(dq);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/Tnx49fajv">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/deque"><code>std::deque</code></a></p>
<h3 id="forward-list"><a class="header" href="#forward-list">Forward List</a></h3>
<p><code>std::forward_list</code> is an implementation of a singly-linked-list offering fast access, insertion and erasure to the beginning of the list. Forward lists also allows for easy merging of two sorted lists as well as operations for reversing and sorting the list. Insertion and erasure has <code>_after</code> semantics meaning that these operations occur to the element after the passed iterator.
Forward lists are not indexable.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;forward_list&gt;

template&lt;typename T&gt;
auto println(const std::forward_list&lt;T&gt;&amp; f_lst) -&gt; void
{
    std::cout &lt;&lt; &quot;[ &quot;;
    for (auto i { std::distance(f_lst.cbegin(), f_lst.cend()) }; const auto&amp; e : f_lst)
        std::cout &lt;&lt; e &lt;&lt; (--i ? &quot; -&gt; &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; ]&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto f_lst = std::forward_list&lt;int&gt;{ 1, 2, 3, 4, 5 };

    println(f_lst);
    f_lst.push_front(33);
    f_lst.push_front(914);
    f_lst.push_front(-44);
    f_lst.push_front(0);
    println(f_lst);
    f_lst.pop_front();
    f_lst.pop_front();
    println(f_lst);

    f_lst.insert_after(f_lst.begin(), 77);
    println(f_lst);
    f_lst.erase_after(f_lst.begin());
    println(f_lst);
    f_lst.clear();
    println(f_lst);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/Y5c4z67Pz">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/forward_list"><code>std::forward_list</code></a></p>
<h3 id="list"><a class="header" href="#list">List</a></h3>
<p>Along with a singly-linked-list C++ offers a doubly-linked-list called <code>std::list</code>. This offers constant (\( O(1) \)) insertion and erasure anywhere within the container with the biggest benefits occurring at the beginning and end of the list. Lists allow for bidirectional iteration through the container. Iterators and references are not invalidated during insertion and erasure except for the element that got erased.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;list&gt;

template&lt;typename T&gt;
auto println(const std::list&lt;T&gt;&amp; lst) -&gt; void
{
    std::cout &lt;&lt; &quot;[ &quot;;
    for (auto i { lst.size() }; const auto&amp; e : lst)
        std::cout &lt;&lt; e &lt;&lt; (--i ? &quot; &lt;-&gt; &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; ]&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto lst = std::list&lt;int&gt;{ 1, 2, 3, 4, 5 };

    println(lst);
    lst.push_back(6);
    println(lst);
    lst.pop_back();
    lst.pop_back();
    println(lst);
    lst.push_front(33);
    lst.push_front(914);
    lst.push_front(-44);
    lst.push_front(0);
    println(lst);
    lst.pop_front();
    lst.pop_front();
    println(lst);

    lst.insert(lst.begin(), 77);
    println(lst);
    lst.erase(++lst.begin());
    println(lst);

    lst.clear();
    std::cout &lt;&lt; &quot;After lst.clear()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; lst.size() &lt;&lt; std::endl;
    println(lst);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/YfoWacKcK">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/list"><code>std::list</code></a></p>
<h3 id="a-harsh-truth"><a class="header" href="#a-harsh-truth">A harsh truth</a></h3>
<p>While many of these sequences offer a variety of different ways to organise data and offer different performance guarantees to fit different needs when it comes to searching, insertion and erasure, the harsh reality is often this doesn't matter outside of semantics. 99.9% of the time (I'm exaggerating a bit) the best data structure; particularly for sequences based organisation of data, are vectors. Even for searching, sorting, insertion and erasure. This is because computers are so much faster then they were two decades ago and CPU's have much larger (L2) caches. What does this have to do with it? Well, computer memory is sequential in nature meaning that all data that is stored contiguously. Copying, allocating and transfer of sequential memory is almost always faster as the CPU will often vectorize the operation, assuming that it can move sequential from memory to the cache even if it doesn't explicitly know this. Compare this to other data structures, particularly linked-lists which 'optimise' insertion and erasure by having nodes of data spread out throughout memory, removing the restriction on the data needing to be contiguous. What this actually does is prevent the CPU from predicting what memory it might use maximizing the opportunity for a cache miss to occur which is much slower than copying more data. Copies are cheap, especially for <code>std::vector</code> as it contains only three pointers. One to the start of the data, one to the end of the used memory and one to the end of the owned memory. All of this pointers are reachable from each other. To get to the data, it costs one pointer indirection to the data and one jump of size <code>n</code> to the desired value. This jump happens in constant time as the CPU will already know exactly how many bytes over this is (exactly $n \cdot sizeof(element)$) and can add this directly to the pointer to the start of the data. If the CPU can figure out that memory near the current memory being fetched will ned to be fetched as well it will take as much as it can from the region, optimising the IO the CPU does which is one of the largest bottlenecks of performance. Compare this to many pointer indirections that have to go into getting a single node from a linked list. Not to mention the CPU has no way of determining where the next memory it needs might be, increasing the fetching time the CPU execute. Not to mention that is has to make room in its cache and eject memory every time it reads.</p>
<p>What does this all mean? Don't think too much about which data structure is best based on the \( BigO \) complexities. Start with using vectors and arrays and adapt your programs to use specific data structures as you need. After all; for C++, the \( BigO \) complexity are minimum requirements for the standard library that must be met by a particular implementation and not their real world average performance. That is not to say that linked lists or deques do not have there uses. Linked lists are used in the Linux kernel to connect and organise related data. It looks very different to lists in C++ but has a pretty intuitive implementation and use. It is implemented as a intrusive linked list. How this works is that a data structure will have a member that is node containing a pointer to the previous and next node. The benefit to this is that the list is not tied to any type as the nodes don't hold any data themselves, instead the data holds information on how to get to the nxe or previous node. This list structure is used everywhere in the Linux kernel and is very efficient.</p>
<h2 id="associative-containers"><a class="header" href="#associative-containers">Associative Containers</a></h2>
<p>Associative containers are used for sorted data. They allow for very fast searching as well as efficient insertion, erasure and access. Associative containers work by ordering keys and (sometimes) mapping values to these keys.</p>
<h3 id="set"><a class="header" href="#set">Set</a></h3>
<p><code>std::set</code> is an ordered collections of unique keys usually sorted in ascending order. Search, insertion and erasure occur in logarithmic time (\( O(\log{n}) \)). Sets also offer merging operations for combining two sets into a single set with all elements merged and sorted. Sets can be accessed using extraction methods that moves the <em>node-type</em> that owns the key value out of the set and gives it to the caller.</p>
<blockquote>
<p>Note: <em>node-type</em> is an exposition only type that is implemented as chapter of the set. It is not to be used as an independent type.</p>
</blockquote>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;set&gt;

template&lt;typename T&gt;
auto println(const std::set&lt;T&gt;&amp; st) -&gt; void
{
    std::cout &lt;&lt; &quot;{ &quot;;
    for (auto i { st.size() }; const auto&amp; e : st)
        std::cout &lt;&lt; e &lt;&lt; (--i ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; }&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto st = std::set&lt;int&gt;{ 1, 2, 3, 4, 5 };

    st.insert(77);
    println(st);
    st.erase(++st.begin());
    println(st);

    std::cout &lt;&lt; &quot;st.extract(++st.begin()).value() = &quot; &lt;&lt; st.extract(++st.begin()).value() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;st.extract(5).value() = &quot; &lt;&lt; st.extract(5).value() &lt;&lt; std::endl;
    println(st);

    st.merge(std::set&lt;int&gt;{ -1, 5, 4, 2, 0, 8, 6 });
    std::cout &lt;&lt; &quot;After st.merge(...): &quot; &lt;&lt; std::endl;
    println(st);

    st.clear();
    std::cout &lt;&lt; &quot;After st.clear()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; st.size() &lt;&lt; std::endl;
    println(st);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/P8E99q43c">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/set"><code>std::set</code></a></p>
<h3 id="map"><a class="header" href="#map">Map</a></h3>
<p><code>std::map</code> is the most general associative container available in C++. Maps are made up of ordered key value pairs with strictly unique key values. Searching, key-indexing, insertion and erasure of elements is logarithmic (\( O(\log{n}) \)) in time. Values are obtained using the associated key using indexing syntax. It also offers similar extraction and merging functionalities as sets. Maps in C++ are typically implemented as <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-Black Trees</a>.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

template&lt;typename K, typename V&gt;
auto println(const std::map&lt;K, V&gt;&amp; m) -&gt; void
{
    std::cout &lt;&lt; &quot;[ &quot;;
    for (auto i { m.size() }; const auto&amp; [k, v] : m)
        std::cout &lt;&lt; k &lt;&lt; &quot;: &quot; &lt;&lt; v &lt;&lt; (--i ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; ]&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto m = std::map&lt;std::string, int&gt;{ {&quot;z&quot;, 1}, {&quot;f&quot;, 2}, {&quot;a&quot;, 3}, {&quot;g&quot;, 4}, {&quot;x&quot;, 5} };

    println(m);
    m[&quot;a&quot;] = 5;         ///&lt; Can read, write and insert
    println(m);
    m[&quot;q&quot;] = 7;
    println(m);
    m.at(&quot;g&quot;) = 265;    ///&lt; Can only be used for read or write, not insert
    println(m);
    m.insert({&quot;w&quot;, 77});
    println(m);
    m.insert_or_assign(&quot;w&quot;, 354658);
    println(m);

    m.erase(&quot;a&quot;);
    println(m);
    m.erase(++m.begin());
    println(m);

    m.clear();
    std::cout &lt;&lt; &quot;After m.clear()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; m.size() &lt;&lt; std::endl;
    println(m);

    return 0;
}
</code></pre>
<blockquote>
<p>Note: In the <em>range-for</em> if <code>println()</code>, you may notice a weird syntax for the element. Because iterators to <code>std::map</code> yield a <code>std::pair</code> we can destructure it straight into individual variables using structured bindings.</p>
</blockquote>
<p><a href="https://www.godbolt.org/z/Wb5xPhraq">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/map"><code>std::map</code></a></p>
<h3 id="multiset--multimap"><a class="header" href="#multiset--multimap">Multiset &amp; Multimap</a></h3>
<p>Along with the regular set and map classes, C++ offers <code>std::multiset</code> and <code>std::multimap</code> which hold ordered keys (and values) but allow for duplicate keys. They offer pretty much the exact same interface as the key-exclusive counterparts except that the order of duplicate keys is the same order as their insertion. This order between duplicates remains constant unless the node holding a particular key (and value) is extracted and it's ownership given to the caller. Searching, insertion and erasure take logarithmic time (\( O(\log{n}) \)).</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;string&gt;

template&lt;typename K, typename V&gt;
auto println(const std::multimap&lt;K, V&gt;&amp; m) -&gt; void
{
    std::cout &lt;&lt; &quot;{ &quot;;
    for (auto i { m.size() }; const auto&amp; [k, v] : m)
        std::cout &lt;&lt; k &lt;&lt; &quot;: &quot; &lt;&lt; v &lt;&lt; (--i ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; }&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto mm = std::multimap&lt;std::string, int&gt;{ {&quot;z&quot;, 12}, {&quot;f&quot;, 2}, {&quot;a&quot;, 3}, {&quot;g&quot;, 4}, {&quot;x&quot;, 5} };

    println(mm);
    mm.insert({&quot;z&quot;, 77});
    println(mm);

    mm.erase(&quot;a&quot;);
    println(mm);
    mm.erase(++mm.begin());
    println(mm);

    mm.clear();
    std::cout &lt;&lt; &quot;After mm.clear()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; mm.size() &lt;&lt; std::endl;
    println(mm);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/ro5MaxeEG">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/multiset"><code>std::multiset</code></a>
<a href="https://en.cppreference.com/w/cpp/container/multimap"><code>std::multimap</code></a></p>
<h2 id="unordered-associative-containers"><a class="header" href="#unordered-associative-containers">Unordered Associative Containers</a></h2>
<p>Unordered associative containers are data structures that do not sort their key values but instead use a hashing function to create bucket based access to elements. Hashing functions are designed to avoid hash collisions however, many hashed data structures account for hash collisions. Hashing is the process of computing a discrete hash value for a key indicating the index in an internalised array or <em>bucket</em>. Which bucket a key (and value) is placed in relies solely on the result of hashing that key, with keys creating duplicate hash results being placed in the same bucket (typically).</p>
<h3 id="unordered-set"><a class="header" href="#unordered-set">Unordered Set</a></h3>
<p><code>std::unordered_set</code> is the first of our unordered associative containers. Unlike sets, hashed sets do not need to order their keys. Searching, insertion and erasure in a hashed set occurs in constant time (\( O(1) \)). Elements of a hashed set cannot be changes as this would invalidate the hash table. Instead erasure and insertion must be used instead.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;unordered_set&gt;
#include &lt;string&gt;

template&lt;typename K&gt;
auto println(const std::unordered_set&lt;K&gt;&amp; ust) -&gt; void
{
    std::cout &lt;&lt; &quot;{ &quot;;
    for (auto i { ust.size() }; const auto&amp; k : ust)
        std::cout &lt;&lt; k &lt;&lt; (--i ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; }&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto ust = std::unordered_set&lt;std::string&gt;{ &quot;z&quot;, &quot;f&quot;, &quot;a&quot;, &quot;g&quot;, &quot;x&quot; };

    println(ust);
    ust.insert(&quot;k&quot;);
    println(ust);

    ust.erase(&quot;a&quot;);
    println(ust);
    ust.erase(++ust.begin());
    println(ust);

    std::cout &lt;&lt; &quot;Loading Factor: &quot; &lt;&lt; ust.load_factor() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Max Loading Factor: &quot; &lt;&lt; ust.max_load_factor() &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; ust.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;# Buckets: &quot; &lt;&lt; ust.bucket_count() &lt;&lt; std::endl;
    ust.insert(&quot;m&quot;);
    println(ust);
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; ust.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;# Buckets: &quot; &lt;&lt; ust.bucket_count() &lt;&lt; std::endl;

    auto bckt = ust.bucket(&quot;f&quot;);  ///&lt; returns index of bucket
    std::cout &lt;&lt; &quot;Bucket Size: &quot; &lt;&lt; ust.bucket_size(bckt) &lt;&lt; std::endl;

    ust.clear();
    std::cout &lt;&lt; &quot;After ust.clear()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; ust.size() &lt;&lt; std::endl;
    println(ust);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/G97n97r3G">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/unordered_set"><code>std::unordered_set</code></a></p>
<h3 id="unordered-map"><a class="header" href="#unordered-map">Unordered Map</a></h3>
<p><code>std::unordered_map</code> is a hashed version of a regular map but like its hash set counterpart, instead of ordering keys it uses a hashing functions to create an index into buckets. Search, insertion and erasure all happen in constant time (\( O(1) \)). Unlike hashed sets, values can be accessed and inserted using key-based indexing.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;

template&lt;typename K, typename V&gt;
auto println(const std::unordered_map&lt;K, V&gt;&amp; umap) -&gt; void
{
    std::cout &lt;&lt; &quot;{ &quot;;
    for (auto i { umap.size() }; const auto&amp; [k, v] : umap)
        std::cout &lt;&lt; k &lt;&lt; &quot;: &quot; &lt;&lt; v &lt;&lt; (--i ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; }&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto umap = std::unordered_map&lt;std::string, int&gt;{ {&quot;z&quot;, 12}, {&quot;f&quot;, 2}, {&quot;a&quot;, 3}, {&quot;g&quot;, 4}, {&quot;x&quot;, 5} };

    println(umap);
    umap[&quot;h&quot;] = 576;
    println(umap);
    umap.at(&quot;f&quot;) = 368548;
    println(umap);

    println(umap);
    umap.insert({&quot;k&quot;, 56});
    println(umap);

    umap.erase(&quot;a&quot;);
    println(umap);
    umap.erase(++umap.begin());
    println(umap);

    std::cout &lt;&lt; &quot;Loading Factor: &quot; &lt;&lt; umap.load_factor() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Max Loading Factor: &quot; &lt;&lt; umap.max_load_factor() &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; umap.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;# Buckets: &quot; &lt;&lt; umap.bucket_count() &lt;&lt; std::endl;
    umap.insert({&quot;m&quot;, 78});
    println(umap);
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; umap.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;# Buckets: &quot; &lt;&lt; umap.bucket_count() &lt;&lt; std::endl;

    auto bckt = umap.bucket(&quot;f&quot;);  ///&lt; returns index of bucket
    std::cout &lt;&lt; &quot;Bucket Size: &quot; &lt;&lt; umap.bucket_size(bckt) &lt;&lt; std::endl;

    umap.clear();
    std::cout &lt;&lt; &quot;After umap.clear()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; umap.size() &lt;&lt; std::endl;
    println(umap);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/qj5bq9fze">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/unordered_map"><code>std::unordered_map</code></a></p>
<h3 id="unordered-multiset--multimap"><a class="header" href="#unordered-multiset--multimap">Unordered Multiset &amp; Multimap</a></h3>
<p>Much like how there are sets and maps that can store duplicate keys, there are hashed versions of these data structures called <code>std::unordered_multiset</code> and <code>std::unordered_multimap</code> respectively. Search, insertion and erasure occur in constant time (\( O(n) \)). Hashed multimaps cannot be accessed using key-based indexing as it cannot be determined which key to return if duplicates exist.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;

template&lt;typename K, typename V&gt;
auto println(const std::unordered_multimap&lt;K, V&gt;&amp; ummap) -&gt; void
{
    std::cout &lt;&lt; &quot;{ &quot;;
    for (auto i { ummap.size() }; const auto&amp; [k, v] : ummap)
        std::cout &lt;&lt; k &lt;&lt; &quot;: &quot; &lt;&lt; v &lt;&lt; (--i ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; }&quot; &lt;&lt; std::endl;
}

auto main() -&gt; int
{
    auto ummap = std::unordered_multimap&lt;std::string, int&gt;{ {&quot;z&quot;, 1}, {&quot;f&quot;, 2}, {&quot;a&quot;, 3}, {&quot;g&quot;, 4}, {&quot;x&quot;, 5} };

    println(ummap);
    ummap.insert({&quot;w&quot;, 77});
    println(ummap);
    ummap.insert({&quot;w&quot;, 879});
    println(ummap);
    ummap.insert({&quot;w&quot;, -23});
    println(ummap);
    ummap.insert({&quot;w&quot;, 209538});
    println(ummap);

    std::cout &lt;&lt; &quot;Loading Factor: &quot; &lt;&lt; ummap.load_factor() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Max Loading Factor: &quot; &lt;&lt; ummap.max_load_factor() &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; ummap.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;# Buckets: &quot; &lt;&lt; ummap.bucket_count() &lt;&lt; std::endl;
    ummap.insert({&quot;m&quot;, 78});
    println(ummap);
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; ummap.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;# Buckets: &quot; &lt;&lt; ummap.bucket_count() &lt;&lt; std::endl;

    auto bckt = ummap.bucket(&quot;w&quot;);  ///&lt; returns index of bucket
    std::cout &lt;&lt; &quot;Bucket Size: &quot; &lt;&lt; ummap.bucket_size(bckt) &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;w: { &quot;;
    auto i { ummap.bucket_size(bckt) };
    for (auto it = ummap.begin(bckt); it != ummap.end(bckt); ++it)
        std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot;: &quot; &lt;&lt; it-&gt;second &lt;&lt; (--i ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; }&quot; &lt;&lt; std::endl;

    ummap.erase(&quot;a&quot;);
    println(ummap);
    ummap.erase(++ummap.begin());
    println(ummap);

    ummap.clear();
    std::cout &lt;&lt; &quot;After ummap.clear()&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; ummap.size() &lt;&lt; std::endl;
    println(ummap);

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/heKfcz6K1">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/container/unordered_multiset"><code>std::unordered_multiset</code></a>
<a href="https://en.cppreference.com/w/cpp/container/unordered_multimap"><code>std::unordered_multimap</code></a></p>
<h2 id="miscellaneous"><a class="header" href="#miscellaneous">Miscellaneous</a></h2>
<h3 id="bitset"><a class="header" href="#bitset">Bitset</a></h3>
<p><code>std::bitset</code> allows for efficient storage of individually addressable bits. The size of a bitset is fixed at compile time allowing for bitsets to be evaluated in <code>constexpr</code> context. The standard bit manipulation operators are available for bitwise manipulation between bitsets. Bitset also allow for single bit access as well as testing of single or all bits in the bitset. Bitsets also have conversion methods for obtaining the string, and integral representations of the bits. Bitsets can be constructed from string representations of bits or or from binary literal integrals. The bit to the right is the least significant bit ie. the first bit.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;bitset&gt;
#include &lt;string&gt;

template&lt;std::size_t N&gt;
auto println(const std::bitset&lt;N&gt;&amp; b) -&gt; void
{ std::cout &lt;&lt; &quot;0b&quot; &lt;&lt; b &lt;&lt; std::endl; }

auto main() -&gt; int
{
    auto b = std::bitset&lt;6&gt;(0b011010uLL);

    println(b);
    b[2] = true;
    println(b);
    b.set(4) = false;

    b.flip(0);
    println(b);
    b.flip();
    println(b);
    b.reset();
    println(b);

    std::cout &lt;&lt; std::boolalpha;
    std::cout &lt;&lt; (b.test(5) == false) &lt;&lt; std::endl;
    std::cout &lt;&lt; b.any() &lt;&lt; std::endl;
    std::cout &lt;&lt; b.all() &lt;&lt; std::endl;
    std::cout &lt;&lt; b.none() &lt;&lt; std::endl;
    std::cout &lt;&lt; std::noboolalpha;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/1qnYTWxMb">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/utility/bitset"><code>std::bitset</code></a></p>
<h3 id="any"><a class="header" href="#any">Any</a></h3>
<p><code>std::any</code> is a unique data structure that can hold any <em>Copy-Constructable</em> type. It can also be changed to any new type simply through assignment. You can introspect the type contained as well as destroy the contained object. The only way to access the contained value is through an <code>std::any_cast&lt;&gt;</code> which will yield the value which is cast to the template type of the any cast. Any also comes with a factory function for creating a any object.</p>
<pre><code class="language-cxx">#include &lt;iostream&gt;
#include &lt;any&gt;

template&lt;typename T&gt;
auto println(const std::any&amp; a) -&gt; void
{ std::cout &lt;&lt; std::any_cast&lt;T&gt;(a) &lt;&lt; std::endl; }

auto main() -&gt; int
{
    auto a = std::make_any&lt;int&gt;(6);

    println&lt;int&gt;(a);
    a.emplace&lt;double&gt;(6.797898);
    println&lt;double&gt;(a);    

    std::cout &lt;&lt; a.type().name() &lt;&lt; std::endl; 

    std::cout &lt;&lt; std::boolalpha;
    std::cout &lt;&lt; a.has_value() &lt;&lt; std::endl;
    a.reset();
    std::cout &lt;&lt; a.has_value() &lt;&lt; std::endl;
    std::cout &lt;&lt; std::noboolalpha;

    return 0;
}
</code></pre>
<p><a href="https://www.godbolt.org/z/n57nYonqs">Exmaple</a></p>
<p><a href="https://en.cppreference.com/w/cpp/utility/any"><code>std::any</code></a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter6/iterators.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../chapter6/algorithms.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter6/iterators.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../chapter6/algorithms.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
