<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mutexes - High Performance Programming</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Monash DeepNeuron&#x27;s High Performance Programming Curriculum">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../home.html">Home</a></li><li class="chapter-item expanded affix "><div>Foreword</div></li><li class="chapter-item expanded "><a href="../chapter1/chapter1.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter1/wsl.html"><strong aria-hidden="true">1.1.</strong> WSL</a></li><li class="chapter-item expanded "><a href="../chapter1/software.html"><strong aria-hidden="true">1.2.</strong> Installing Software</a></li><li class="chapter-item expanded "><a href="../chapter1/helloworld.html"><strong aria-hidden="true">1.3.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="../chapter1/godbolt.html"><strong aria-hidden="true">1.4.</strong> Compiler Explorer</a></li><li class="chapter-item expanded "><a href="../chapter1/slides1.html"><strong aria-hidden="true">1.5.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter2/chapter2.html"><strong aria-hidden="true">2.</strong> Basics of C++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter2/typesystem.html"><strong aria-hidden="true">2.1.</strong> The C++ Type System</a></li><li class="chapter-item expanded "><a href="../chapter2/types.html"><strong aria-hidden="true">2.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../chapter2/variables.html"><strong aria-hidden="true">2.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../chapter2/operators.html"><strong aria-hidden="true">2.4.</strong> Operators</a></li><li class="chapter-item expanded "><a href="../chapter2/io.html"><strong aria-hidden="true">2.5.</strong> IO</a></li><li class="chapter-item expanded "><a href="../chapter2/eqordlogic.html"><strong aria-hidden="true">2.6.</strong> Equality, Ordering &amp; Logical Operators</a></li><li class="chapter-item expanded "><a href="../chapter2/condexpr.html"><strong aria-hidden="true">2.7.</strong> Conditional Expressions</a></li><li class="chapter-item expanded "><a href="../chapter2/loops.html"><strong aria-hidden="true">2.8.</strong> Loops</a></li><li class="chapter-item expanded "><a href="../chapter2/functions.html"><strong aria-hidden="true">2.9.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../chapter2/slides2.html"><strong aria-hidden="true">2.10.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter3/chapter3.html"><strong aria-hidden="true">3.</strong> Memory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter3/pointers.html"><strong aria-hidden="true">3.1.</strong> Pointers</a></li><li class="chapter-item expanded "><a href="../chapter3/slices.html"><strong aria-hidden="true">3.2.</strong> Slices</a></li><li class="chapter-item expanded "><a href="../chapter3/references.html"><strong aria-hidden="true">3.3.</strong> References</a></li><li class="chapter-item expanded "><a href="../chapter3/memory.html"><strong aria-hidden="true">3.4.</strong> Dynamic Memory</a></li><li class="chapter-item expanded "><a href="../chapter3/stdlib.html"><strong aria-hidden="true">3.5.</strong> The Standard Library</a></li><li class="chapter-item expanded "><a href="../chapter3/slides3.html"><strong aria-hidden="true">3.6.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter4/chapter4.html"><strong aria-hidden="true">4.</strong> Intermediate C++ Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter4/advfunc.html"><strong aria-hidden="true">4.1.</strong> Advanced Function Concepts</a></li><li class="chapter-item expanded "><a href="../chapter4/namespaces.html"><strong aria-hidden="true">4.2.</strong> Namespaces</a></li><li class="chapter-item expanded "><a href="../chapter4/enums.html"><strong aria-hidden="true">4.3.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="../chapter4/unions.html"><strong aria-hidden="true">4.4.</strong> Unions</a></li><li class="chapter-item expanded "><a href="../chapter4/structs.html"><strong aria-hidden="true">4.5.</strong> Structures</a></li><li class="chapter-item expanded "><a href="../chapter4/task1.html"><strong aria-hidden="true">4.6.</strong> Task 1</a></li><li class="chapter-item expanded "><a href="../chapter4/slides4.html"><strong aria-hidden="true">4.7.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter5/chapter5.html"><strong aria-hidden="true">5.</strong> Generic Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter5/classes.html"><strong aria-hidden="true">5.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="../chapter5/templates.html"><strong aria-hidden="true">5.2.</strong> Templates</a></li><li class="chapter-item expanded "><a href="../chapter5/generics.html"><strong aria-hidden="true">5.3.</strong> Generics</a></li><li class="chapter-item expanded "><a href="../chapter5/concepts.html"><strong aria-hidden="true">5.4.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="../chapter5/task2.html"><strong aria-hidden="true">5.5.</strong> Task 2</a></li><li class="chapter-item expanded "><a href="../chapter5/slides5.html"><strong aria-hidden="true">5.6.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter6/chapter6.html"><strong aria-hidden="true">6.</strong> Algorithms &amp; Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter6/iterators.html"><strong aria-hidden="true">6.1.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="../chapter6/data-structures.html"><strong aria-hidden="true">6.2.</strong> Data Structures</a></li><li class="chapter-item expanded "><a href="../chapter6/algorithms.html"><strong aria-hidden="true">6.3.</strong> Algorithms</a></li><li class="chapter-item expanded "><a href="../chapter6/ranges.html"><strong aria-hidden="true">6.4.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="../chapter6/views.html"><strong aria-hidden="true">6.5.</strong> Views</a></li><li class="chapter-item expanded "><a href="../chapter6/task3.html"><strong aria-hidden="true">6.6.</strong> Task 3</a></li><li class="chapter-item expanded "><a href="../chapter6/slides6.html"><strong aria-hidden="true">6.7.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter7/chapter7.html"><strong aria-hidden="true">7.</strong> Concurrent Computing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter7/parallel-alg.html"><strong aria-hidden="true">7.1.</strong> Parallel Algorithms</a></li><li class="chapter-item expanded "><a href="../chapter7/atomics.html"><strong aria-hidden="true">7.2.</strong> Atomics</a></li><li class="chapter-item expanded "><a href="../chapter7/threads.html"><strong aria-hidden="true">7.3.</strong> Threads</a></li><li class="chapter-item expanded "><a href="../chapter7/mutexes.html" class="active"><strong aria-hidden="true">7.4.</strong> Mutexes</a></li><li class="chapter-item expanded "><a href="../chapter7/async.html"><strong aria-hidden="true">7.5.</strong> Asynchronous Programming</a></li><li class="chapter-item expanded "><a href="../chapter7/slides7.html"><strong aria-hidden="true">7.6.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../GODBOLT.html">Godbolt Examples</a></li><li class="chapter-item expanded affix "><a href="../planned.html">Planned Additions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">High Performance Programming</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/MonashDeepNeuron/HPP" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="mutexes--locks"><a class="header" href="#mutexes--locks">Mutexes &amp; Locks</a></h1>
<h2 id="what-is-a-mutex"><a class="header" href="#what-is-a-mutex">What is a Mutex?</a></h2>
<p>A mutex is a <em>mutually-exclusive-object</em>. It is used to synchronize access to shared memory resources across multiple threads. C++ mutex type is called <code>std::mutex</code> from the <code>&lt;mutex&gt;</code> header. Threads can own a <code>std::mutex</code> by locking it. Other threads will block when they try to lock a <code>std::mutex</code> owned by another thread. <code>std::mutex</code> also implement a try-lock that returns a Boolean indicating the result off the lock attempt. A thread cannot own a <code>std::mutex</code> before it tries to lock it. Mutexes are generally implemented as a OS primitive. Because <code>std::mutex</code> (and C++ other mutex types) use locking and unlocking methods to control access, these types are not considered to be RAII types. Instead there are locking types that will lock a mutex on construction and unlock it on destruction (more below).</p>
<pre><code class="language-cxx">#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;mutex&gt;
#include &lt;sstream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

using namespace std::literals;

auto mx  = std::mutex{};
auto map = std::map&lt;int, long long&gt;{};

auto job = [](auto job_id)
{ 
    std::this_thread::sleep_for(150ms);
    auto ss = std::stringstream{};
    ss &lt;&lt; std::this_thread::get_id();
    auto thread_id = std::stoll(ss.str());

    while (!mx.try_lock())
        std::this_thread::sleep_for(150ms);

    map.insert({ job_id, thread_id });
    mx.unlock();
    std::this_thread::sleep_for(150ms);
};

auto main() -&gt; int
{    
    auto thr_count { std::thread::hardware_concurrency() };
    auto pool = std::vector&lt;std::thread&gt;(thr_count);

    /// Queue jobs
    for (auto i { 0u }; i &lt; thr_count; ++i)
        pool.emplace_back(job, i);

    std::this_thread::sleep_for(200ms);

    /// Join all job threads
    for (auto&amp; th : pool)
        if (th.joinable())
            th.join();

    std::cout &lt;&lt; &quot;{ &quot;;
    for (auto i { map.size() }; auto&amp; [k, v] : map)
        std::cout &lt;&lt; k &lt;&lt; &quot;: &quot; &lt;&lt; v &lt;&lt; (i-- ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; }&quot; &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<pre><code class="language-sh">bpt build -t build.yaml -o build

# ...

./build/mutex
{ 0: 140667719128640, 1: 140667710735936, 2: 140667702343232, 3: 140667693950528, 4: 140667685557824, 5: 140667677165120, 6: 140667668772416, 7: 140667660379712, 8: 140667651987008, 9: 140667643594304, 10: 140667635201600, 11: 140667626808896, 12: 140667618416192, 13: 140667610023488, 14: 140667601630784, 15: 140667593238080,  }
</code></pre>
<p><a href="./examples/mutex/src/mutex.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/thread/mutex"><code>std::mutex</code></a></p>
<h2 id="other-mutex-types"><a class="header" href="#other-mutex-types">Other Mutex Types</a></h2>
<ul>
<li>
<p><code>std::timed_mutex</code> - Mutex that offers timeout based locking methods. Locking will be attempted for a certain duration.</p>
</li>
<li>
<p><code>std::recursive_mutex</code> - Mutex that can be repeatedly locked by the same thread multiple times. Must be unlocked the same number of times to become fully unlocked.</p>
</li>
<li>
<p><code>std::recursive_timed_mutex</code> - Recursive mutex with timeout locking.</p>
</li>
<li>
<p><code>std::shared_mutex</code> - A mutex that offers to levels of access, <em>shared</em> or <em>exclusive</em>. Shared locking allows for multiple threads to share a mutex and read the shared memory resources while exclusive only allows one thread to access the shared resources with write privileges. If one thread has a shared lock an a mutex other threads can only gain a shared lock on it as well prohibiting the ability to gain exclusive access from another thread until all threads have unlocked the shared lock. Similarly, a thread with an exclusive lock on a thread disallows other threads from gaining any lock on the mutex until it has been unlocked.</p>
</li>
<li>
<p><code>std::shared_timed_mutex</code> - Same as a <code>std::shared_mutex</code> but offers timeout based exclusive and shared locking.</p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/thread/timed_mutex"><code>std::timed_mutex</code></a></p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/thread/recursive_mutex"><code>std::recursive_mutex</code></a></p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/thread/recursive_timed_mutex"><code>std::recursive_timed_mutex</code></a></p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/thread/shared_mutex"><code>std::shared_mutex</code></a></p>
</li>
<li>
<p><a href="https://en.cppreference.com/w/cpp/thread/shared_timed_mutex"><code>std::shared_timed_mutex</code></a></p>
</li>
</ul>
<h2 id="what-is-a-lock"><a class="header" href="#what-is-a-lock">What is a lock?</a></h2>
<p>A lock is another kind of synchronization primitive. Locks can be used to wrap other synchronization primitives like mutexes and bind the locking and unlocking if the mutex to the lifetime of the lock using RAII or can themselves be synchronization primitives that must be acquires and released. Most locks in C++ perform the former which allow for mutex locking to be scoped ensuring proper releasing of resources even if exceptions are thrown. Locks however, can also be used erroneously creating <em>deadlocks</em> for which two threads rely on the releasing of each others locks in order to release their respective locks. They also have a little more overhead as you have to create and destroy locks. Locks will often be created in an unnamed scope to ensure that it only lives as long as it needs.</p>
<h2 id="semaphores"><a class="header" href="#semaphores">Semaphores</a></h2>
<p>The most simple type of lock is a semaphore. Semaphores allow multiple threads to access the same resource. The number of accessors is dictated by a count which decrements when the semaphore is acquires and blocks for any acquisitions for which the count is zero. C++ semaphore type which supports arbitrary size counts is called <code>std::counting_semaphore</code>. There is also a specialisation for which only a single accessor is allowed, called <code>std::binary_semaphore</code>. Both of these live in the <code>semaphore</code> header.</p>
<pre><code class="language-cxx">#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;semaphore&gt;
#include &lt;thread&gt;

using namespace std::literals;

auto toMain     = std::binary_semaphore{ 0 };
auto fromMain   = std::binary_semaphore{ 0 };

auto work = []()
{ 
    fromMain.acquire();

    std::cout &lt;&lt; &quot;[thread]: Got signal&quot; &lt;&lt; std::endl;
    std::this_thread::sleep_for(3s);
    std::cout &lt;&lt; &quot;[thread]: Sent signal&quot; &lt;&lt; std::endl;

    toMain.release();
};

auto main() -&gt; int
{    
    auto th = std::thread{ work };

    std::cout &lt;&lt; &quot;[Main]: Sent signal&quot; &lt;&lt; std::endl;
    fromMain.release();
    toMain.acquire();
    std::cout &lt;&lt; &quot;[Main]: Got signal&quot; &lt;&lt; std::endl;

    th.join();

    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

$ ./build/semaphores 
[Main]: Sent signal
[thread]: Got signal
[thread]: Sent signal
[Main]: Got signal
</code></pre>
<p><a href="./examples/mutex/src/semaphores.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/thread/counting_semaphore"><code>std::counting_semaphore</code> &amp; <code>std::binary_semaphore</code></a></p>
<h2 id="lock-types"><a class="header" href="#lock-types">Lock Types</a></h2>
<ul>
<li><code>std::lock_guard</code> - The most basic kind of mutex locking wrapper. It binds the locking lifetime of a mutex to the lifetime of the lock. It takes a template type parameter of the mutex type and a mutex as a constructor argument. It can also adopt the ownership of a mutex by passing a second constructor argument <code>std::adopt_lock</code> which does not lock the mutex but ensuring the calling thread will unlock it. <code>std::lock_guard</code> is non-copyable.</li>
<li><code>std::scoped_lock</code> - A lock for acquiring ownership of zero or more mutexes for the duration of a scope block. When constructed and given ownership of multiple mutexes, the locking and unlocking of mutexes uses a deadlock avoidance algorithm.</li>
<li><code>std::unique_lock</code> - Used to acquire an exclusive lock on a mutex with deferred, time-constrained, recursive and transfer semantics for locking. It is non-copyable but is moveable.</li>
<li><code>std::shared_lock</code> - Used to gain shared access to a mutex with similar semantics to <code>std::unique_lock</code>. Used for locking a <code>std::shared_mutex</code> in a shared ownership model.</li>
</ul>
<pre><code class="language-cxx">#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;mutex&gt;
#include &lt;sstream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

using namespace std::literals;

auto mx  = std::mutex{};
auto map = std::map&lt;int, long long&gt;{};

auto job = [](auto job_id)
{ 
    std::this_thread::sleep_for(150ms);
    auto ss = std::stringstream{};
    ss &lt;&lt; std::this_thread::get_id();
    auto thread_id = std::stoll(ss.str());

    /// Acquire a lock on mx that lasts for this scope
    {
        auto lk = std::lock_guard{ mx };
        map.insert({ job_id, thread_id });
    }
    
    std::this_thread::sleep_for(150ms);
};

auto main() -&gt; int
{    
    auto thr_count { std::thread::hardware_concurrency() };
    auto pool = std::vector&lt;std::thread&gt;(thr_count);

    /// Queue jobs
    for (auto i { 0u }; i &lt; thr_count; ++i)
        pool.emplace_back(job, i);

    std::this_thread::sleep_for(200ms);

    /// Join all job threads
    for (auto&amp; th : pool)
        if (th.joinable())
            th.join();

    std::cout &lt;&lt; &quot;{ &quot;;
    for (auto i { map.size() }; auto&amp; [k, v] : map)
        std::cout &lt;&lt; k &lt;&lt; &quot;: &quot; &lt;&lt; v &lt;&lt; (i-- ? &quot;, &quot; : &quot;&quot;);
    std::cout &lt;&lt; &quot; }&quot; &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

$ ./build/locks
{ 0: 139998766057024, 1: 139998757664320, 2: 139998749271616, 3: 139998740878912, 4: 139998732486208, 5: 139998724093504, 6: 139998715700800, 7: 139998707308096, 8: 139998698915392, 9: 139998690522688, 10: 139998682129984, 11: 139998673737280, 12: 139998665344576, 13: 139998656951872, 14: 139998648559168, 15: 139998640166464,  }
</code></pre>
<p><a href="./examples/mutex/src/locks.main.cxx">Example</a></p>
<ul>
<li><a href="https://en.cppreference.com/w/cpp/thread/lock_guard"><code>std::lock_guard</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/scoped_lock"><code>std:scoped_lock</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/unique_lock"><code>std::unique_lock</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/shared_lock"><code>std::shared_lock</code></a></li>
<li><a href="https://en.cppreference.com/w/cpp/thread/lock_tag">Locking Strategies</a></li>
</ul>
<h2 id="latches"><a class="header" href="#latches">Latches</a></h2>
<p>A <code>std::latch</code> is count-down synchronization primitive with the count is initialized on construction. Threads can wait at a <code>std::latch</code> until the count reaches zero. Once this happens, all the threads waiting on the latch are released. <code>std::latch</code> cannot increment or reset its counter after construction making it a single use barrier. <code>std::latch</code> is non-copyable and lives in the <code>&lt;latch&gt;</code> header.</p>
<pre><code class="language-cxx">#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;latch&gt;
#include &lt;syncstream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

using namespace std::literals;

auto thr_count  = std::thread::hardware_concurrency();
auto done       = std::latch{ thr_count };
auto cleanup    = std::latch{ 1 };

auto job = [](auto job_id)
{ 
    std::this_thread::sleep_for(2s);
    std::osyncstream(std::cout) &lt;&lt; &quot;Job &quot; &lt;&lt; job_id &lt;&lt; &quot; done.\n&quot;;
    done.count_down();
    cleanup.wait();
    std::osyncstream(std::cout) &lt;&lt; &quot;Job &quot; &lt;&lt; job_id &lt;&lt; &quot; cleaned up.\n&quot;;
};

auto main() -&gt; int
{    
    auto pool = std::vector&lt;std::thread&gt;(thr_count);

    std::cout &lt;&lt; &quot;Starting jobs...\n&quot;;
    for (auto i { 0u }; i &lt; thr_count; ++i)
        pool.emplace_back(job, i);

    done.wait();
    std::cout &lt;&lt; &quot;All jobs done.\n&quot;;
    std::this_thread::sleep_for(200ms);
    std::cout &lt;&lt; &quot;\nStarting cleanup...\n&quot;;
    cleanup.count_down();
    std::this_thread::sleep_for(200ms);

    for (auto&amp; th : pool)
        if (th.joinable())
            th.join();
    std::cout &lt;&lt; &quot;All jobs cleaned up.\n&quot;;

    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

$ ./build/latch
Starting jobs...
Job 1 done.
Job 0 done.
Job 3 done.
Job 5 done.
Job 4 done.
Job 7 done.
Job 6 done.
Job 8 done.
Job 2 done.
Job 10 done.
Job 9 done.
Job 13 done.
Job 12 done.
Job 11 done.
Job 14 done.
Job 15 done.
All jobs done.

Starting cleanup...
Job 4 cleaned up.
Job 6 cleaned up.
Job 7 cleaned up.
Job 12 cleaned up.
Job 13 cleaned up.
Job 0 cleaned up.
Job 14 cleaned up.
Job 10 cleaned up.
Job 11 cleaned up.
Job 2 cleaned up.
Job 15 cleaned up.
Job 5 cleaned up.
Job 3 cleaned up.
Job 9 cleaned up.
Job 8 cleaned up.
Job 1 cleaned up.
All jobs cleaned up.
</code></pre>
<p><a href="./examples/mutex/src/latch.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/thread/latch"><code>std::latch</code></a></p>
<h2 id="barriers"><a class="header" href="#barriers">Barriers</a></h2>
<p><code>std::barrier</code> is a more general version of <code>std::latch</code>. The lifetime of a <code>std::barrier</code> consists of one or more phases. The first is a synchronization phase for which threads will block where once the counter has reach zero for the <code>std::barrier</code> the threads will unblock. Right before unblocking, a completion function will run which is optionally supplied at the <code>std::barrier</code> construction. After this the <code>std::barrier</code> will reset its counter and can be reused. The overall count can be reduced on arrival by a thread. <code>std::barrier</code> is non-copyable and lives in the <code>&lt;barrier&gt;</code> header.</p>
<pre><code class="language-cxx">#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;barrier&gt;
#include &lt;syncstream&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

using namespace std::literals;

auto thr_count  = std::thread::hardware_concurrency();

auto on_completion = []() noexcept
{ 
    static auto message = &quot;All jobs done.\nWorkers are at lunch before cleaning up...\n&quot;s;
    std::osyncstream(std::cout) &lt;&lt; message;
    std::this_thread::sleep_for(3s);
    message = &quot;All cleaned up.\n&quot;s;
};

auto barrier = std::barrier{ thr_count, on_completion };

auto job = [](auto job_id)
{ 
    std::this_thread::sleep_for(2s);
    std::osyncstream(std::cout) &lt;&lt; &quot;Job &quot; &lt;&lt; job_id &lt;&lt; &quot; done.\n&quot;;
    barrier.arrive_and_wait();
    std::osyncstream(std::cout) &lt;&lt; &quot;Job &quot; &lt;&lt; job_id &lt;&lt; &quot; cleaned up.\n&quot;;
    barrier.arrive_and_wait();
};

auto main() -&gt; int
{    
    auto pool = std::vector&lt;std::thread&gt;(thr_count);

    std::cout &lt;&lt; &quot;Starting jobs...\n&quot;;
    for (auto i { 0u }; i &lt; thr_count; ++i)
        pool.emplace_back(job, i);

    std::this_thread::sleep_for(200ms);

    for (auto&amp; th : pool)
        if (th.joinable())
            th.join();
    
    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

$ ./build/barrier
Starting jobs...
Job 2 done.
Job 1 done.
Job 3 done.
Job 5 done.
Job 0 done.
Job 4 done.
Job 8 done.
Job 7 done.
Job 6 done.
Job 12 done.
Job 11 done.
Job 10 done.
Job 9 done.
Job 15 done.
Job 13 done.
Job 14 done.
All jobs done.
Workers are at lunch before cleaning up...
Job 2 cleaned up.
Job 8 cleaned up.
Job 1 cleaned up.
Job 0 cleaned up.
Job 6 cleaned up.
Job 3 cleaned up.
Job 14 cleaned up.
Job 4 cleaned up.
Job 11 cleaned up.
Job 15 cleaned up.
Job 12 cleaned up.
Job 9 cleaned up.
Job 13 cleaned up.
Job 7 cleaned up.
Job 5 cleaned up.
Job 10 cleaned up.
All cleaned up.
</code></pre>
<p><a href="./examples/mutex/src/barrier.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/thread/barrier"><code>std::barrier</code></a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter7/threads.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../chapter7/async.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter7/threads.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../chapter7/async.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
