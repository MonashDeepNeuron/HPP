<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Parallel Algorithms - High Performance Programming</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Monash DeepNeuron&#x27;s High Performance Programming Curriculum">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../home.html">Home</a></li><li class="chapter-item expanded affix "><div>Foreword</div></li><li class="chapter-item expanded "><a href="../chapter1/chapter1.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter1/wsl.html"><strong aria-hidden="true">1.1.</strong> WSL</a></li><li class="chapter-item expanded "><a href="../chapter1/software.html"><strong aria-hidden="true">1.2.</strong> Installing Software</a></li><li class="chapter-item expanded "><a href="../chapter1/helloworld.html"><strong aria-hidden="true">1.3.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="../chapter1/godbolt.html"><strong aria-hidden="true">1.4.</strong> Compiler Explorer</a></li><li class="chapter-item expanded "><a href="../chapter1/slides1.html"><strong aria-hidden="true">1.5.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter2/chapter2.html"><strong aria-hidden="true">2.</strong> Basics of C++</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter2/typesystem.html"><strong aria-hidden="true">2.1.</strong> The C++ Type System</a></li><li class="chapter-item expanded "><a href="../chapter2/types.html"><strong aria-hidden="true">2.2.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="../chapter2/variables.html"><strong aria-hidden="true">2.3.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../chapter2/operators.html"><strong aria-hidden="true">2.4.</strong> Operators</a></li><li class="chapter-item expanded "><a href="../chapter2/io.html"><strong aria-hidden="true">2.5.</strong> IO</a></li><li class="chapter-item expanded "><a href="../chapter2/eqordlogic.html"><strong aria-hidden="true">2.6.</strong> Equality, Ordering &amp; Logical Operators</a></li><li class="chapter-item expanded "><a href="../chapter2/condexpr.html"><strong aria-hidden="true">2.7.</strong> Conditional Expressions</a></li><li class="chapter-item expanded "><a href="../chapter2/loops.html"><strong aria-hidden="true">2.8.</strong> Loops</a></li><li class="chapter-item expanded "><a href="../chapter2/functions.html"><strong aria-hidden="true">2.9.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../chapter2/slides2.html"><strong aria-hidden="true">2.10.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter3/chapter3.html"><strong aria-hidden="true">3.</strong> Memory</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter3/pointers.html"><strong aria-hidden="true">3.1.</strong> Pointers</a></li><li class="chapter-item expanded "><a href="../chapter3/slices.html"><strong aria-hidden="true">3.2.</strong> Slices</a></li><li class="chapter-item expanded "><a href="../chapter3/references.html"><strong aria-hidden="true">3.3.</strong> References</a></li><li class="chapter-item expanded "><a href="../chapter3/memory.html"><strong aria-hidden="true">3.4.</strong> Dynamic Memory</a></li><li class="chapter-item expanded "><a href="../chapter3/stdlib.html"><strong aria-hidden="true">3.5.</strong> The Standard Library</a></li><li class="chapter-item expanded "><a href="../chapter3/slides3.html"><strong aria-hidden="true">3.6.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter4/chapter4.html"><strong aria-hidden="true">4.</strong> Intermediate C++ Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter4/advfunc.html"><strong aria-hidden="true">4.1.</strong> Advanced Function Concepts</a></li><li class="chapter-item expanded "><a href="../chapter4/namespaces.html"><strong aria-hidden="true">4.2.</strong> Namespaces</a></li><li class="chapter-item expanded "><a href="../chapter4/enums.html"><strong aria-hidden="true">4.3.</strong> Enumerations</a></li><li class="chapter-item expanded "><a href="../chapter4/unions.html"><strong aria-hidden="true">4.4.</strong> Unions</a></li><li class="chapter-item expanded "><a href="../chapter4/structs.html"><strong aria-hidden="true">4.5.</strong> Structures</a></li><li class="chapter-item expanded "><a href="../chapter4/task1.html"><strong aria-hidden="true">4.6.</strong> Task 1</a></li><li class="chapter-item expanded "><a href="../chapter4/slides4.html"><strong aria-hidden="true">4.7.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter5/chapter5.html"><strong aria-hidden="true">5.</strong> Generic Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter5/classes.html"><strong aria-hidden="true">5.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="../chapter5/templates.html"><strong aria-hidden="true">5.2.</strong> Templates</a></li><li class="chapter-item expanded "><a href="../chapter5/generics.html"><strong aria-hidden="true">5.3.</strong> Generics</a></li><li class="chapter-item expanded "><a href="../chapter5/concepts.html"><strong aria-hidden="true">5.4.</strong> Concepts</a></li><li class="chapter-item expanded "><a href="../chapter5/task2.html"><strong aria-hidden="true">5.5.</strong> Task 2</a></li><li class="chapter-item expanded "><a href="../chapter5/slides5.html"><strong aria-hidden="true">5.6.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter6/chapter6.html"><strong aria-hidden="true">6.</strong> Algorithms &amp; Data Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter6/iterators.html"><strong aria-hidden="true">6.1.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="../chapter6/data-structures.html"><strong aria-hidden="true">6.2.</strong> Data Structures</a></li><li class="chapter-item expanded "><a href="../chapter6/algorithms.html"><strong aria-hidden="true">6.3.</strong> Algorithms</a></li><li class="chapter-item expanded "><a href="../chapter6/ranges.html"><strong aria-hidden="true">6.4.</strong> Ranges</a></li><li class="chapter-item expanded "><a href="../chapter6/views.html"><strong aria-hidden="true">6.5.</strong> Views</a></li><li class="chapter-item expanded "><a href="../chapter6/task3.html"><strong aria-hidden="true">6.6.</strong> Task 3</a></li><li class="chapter-item expanded "><a href="../chapter6/slides6.html"><strong aria-hidden="true">6.7.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter7/chapter7.html"><strong aria-hidden="true">7.</strong> Concurrent Computing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter7/parallel-alg.html" class="active"><strong aria-hidden="true">7.1.</strong> Parallel Algorithms</a></li><li class="chapter-item expanded "><a href="../chapter7/atomics.html"><strong aria-hidden="true">7.2.</strong> Atomics</a></li><li class="chapter-item expanded "><a href="../chapter7/threads.html"><strong aria-hidden="true">7.3.</strong> Threads</a></li><li class="chapter-item expanded "><a href="../chapter7/mutexes.html"><strong aria-hidden="true">7.4.</strong> Mutexes</a></li><li class="chapter-item expanded "><a href="../chapter7/async.html"><strong aria-hidden="true">7.5.</strong> Asynchronous Programming</a></li><li class="chapter-item expanded "><a href="../chapter7/slides7.html"><strong aria-hidden="true">7.6.</strong> Slides</a></li></ol></li><li class="chapter-item expanded "><a href="../GODBOLT.html">Godbolt Examples</a></li><li class="chapter-item expanded affix "><a href="../planned.html">Planned Additions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">High Performance Programming</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/MonashDeepNeuron/HPP" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="parallel-algorithms"><a class="header" href="#parallel-algorithms">Parallel Algorithms</a></h1>
<h2 id="execution-policies"><a class="header" href="#execution-policies">Execution Policies</a></h2>
<p>The most basic parallelism comes from the algorithms library. Since C++17 almost all of the algorithms (iterator-based not range-based) in the standard library feature an overload that allows for the algorithm to potentially perform in parallel. These overloads accepts as their first arguments an execution policy. This is an object that represent the level of freedom an algorithms implementation has to try and parallelize its operation. Execution policies are found in the <code>&lt;execution&gt;</code> header under the <code>std::execution</code> namespace. Execution policies are suggestions, they indicate that a algorithm may be able to be parallelized. How the parallelism is achieve is up to the implementation and requires a parallelism backend library that the implementations will use. The most common is Intel's Thread Building Blocks (TBB) library. Using parallel overloads does require some due-diligence from the programmer to not create deadlocks or data races. The parallel algorithms will not automatically stop these from happening.</p>
<table><thead><tr><th align="center">Execution Policy</th><th align="center">Description</th></tr></thead><tbody>
<tr><td align="center"><code>std::execution::seq</code></td><td align="center">Forbids an algorithm from being parallelized. Invocations of element access functions within the algorithm are indeterminately sequenced in the calling thread.</td></tr>
<tr><td align="center"><code>std::execution::par</code></td><td align="center">Specifies that an algorithm can be parallelized. Invocations of element access functions within the algorithm are permitted to execute in the working thread or in a thread implicitly created by the underlying parallel library. Invocations executing in the same thread are indeterminately sequenced in the calling thread.</td></tr>
<tr><td align="center"><code>std::execution::unseq</code></td><td align="center">Specifies that an algorithm can be vectorized such that a single thread using instructions that operate on multiple data items.</td></tr>
<tr><td align="center"><code>std::execution::par_unseq</code></td><td align="center">Specifies that an algorithm can be parallelized, vectorized or migrated across threads. Invocations of element access functions within the algorithm are permitted to execute in unordered fashion in unspecified threads and can be un-sequenced with respect to one another within each thread.</td></tr>
</tbody></table>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/execution_policy_tag_t">Execution Policies</a></p>
<h2 id="alternative-algorithms"><a class="header" href="#alternative-algorithms">Alternative Algorithms</a></h2>
<p>There are a few algorithms in C++ that did not get parallel overloads. Namely a few of the numerical reductions. This is because reduction algorithms typically use binary operators in order to combine elements. The issue with this is not all binary operators are commutative or associative. This can cause problems when making an algorithm work in parallel because the order of operations can affect the result of the reduction. C++ regular reduction algorithms apply their operations in-order meaning that the commutative and associative properties of the binary operator do not matter. For parallel algorithms, commutativity and associativity must be assumed of the binary operator so that operations can be out-of-order.</p>
<h3 id="reduce"><a class="header" href="#reduce">Reduce</a></h3>
<p><code>std::reduce</code> is the parallel form of <code>std::accumulate</code>. It performs a regular left-fold and can take an optional initial value.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;execution&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

template &lt;typename time_t = std::chrono::microseconds&gt;
struct measure
{
    template &lt;typename F, typename... Args&gt;
    static auto execution(F func, Args&amp;&amp;... args) 
        -&gt; std::pair&lt;typename time_t::rep, std::invoke_result_t&lt;F, Args...&gt;&gt;
    {
        auto start = std::chrono::system_clock::now();
        auto result = std::invoke(func, std::forward&lt;Args&gt;(args)...);
        auto duration = std::chrono::duration_cast&lt;time_t&gt;(std::chrono::system_clock::now() - start);
        return std::pair&lt;typename time_t::rep, std::invoke_result_t&lt;F, Args...&gt;&gt;{ duration.count(), result };
    }
};

auto main() -&gt; int
{
    auto v = std::vector&lt;double&gt;(100'000'007, 0.1);
    std::cout.imbue(std::locale(&quot;en_US.UTF-8&quot;));
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1);
    
    std::cout &lt;&lt; &quot;+-----------------+-------------+-----------+--------+------------+----------------+&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;|    Algorithm    | Exec Policy | Binary-Op |  Type  |    Time    |     Result     |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------+-------------+-----------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::accumulate |   Serial    |     +     | double | &quot;;
    auto [acc_time, acc_result] = measure&lt;&gt;::execution([](const auto&amp; v){ return std::accumulate(v.begin(), v.end(), 0.0); }, v);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; acc_time &lt;&lt; &quot; us |  &quot; &lt;&lt; acc_result &lt;&lt; &quot;  |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------+-------------+-----------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;|   std::reduce   | Sequencial  |     +     | double | &quot;;
    auto [seq_time, seq_result] = measure&lt;&gt;::execution([](const auto&amp; v){ return std::reduce(std::execution::seq, v.begin(), v.end(), 0.0); }, v);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; seq_time &lt;&lt; &quot; us |  &quot; &lt;&lt; seq_result &lt;&lt; &quot;  |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------+-------------+-----------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;|   std::reduce   |  Parallel   |     +     | double | &quot;;
    auto [par_time, par_result] = measure&lt;&gt;::execution([](const auto&amp; v){ return std::reduce(std::execution::par, v.begin(), v.end(), 0.0); }, v);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_time &lt;&lt; &quot; us |  &quot; &lt;&lt; par_result &lt;&lt; &quot;  |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------+-------------+-----------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;|   std::reduce   | Unsequenced |     +     | double | &quot;;
    auto [unseq_time, unseq_result] = measure&lt;&gt;::execution([](const auto&amp; v){ return std::reduce(std::execution::unseq, v.begin(), v.end(), 0.0); }, v);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; unseq_time &lt;&lt; &quot; us |  &quot; &lt;&lt; unseq_result &lt;&lt; &quot;  |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------+-------------+-----------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;|   std::reduce   |  Par-Unseq  |     +     | double | &quot;;
    auto [par_unseq_time, par_unseq_result] = measure&lt;&gt;::execution([](const auto&amp; v){ return std::reduce(std::execution::par_unseq, v.begin(), v.end(), 0.0); }, v);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_unseq_time &lt;&lt; &quot; us |  &quot; &lt;&lt; par_unseq_result &lt;&lt; &quot;  |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------+-------------+-----------+--------+------------+----------------+&quot; &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

$ ./build/reduce
+-----------------+-------------+-----------+--------+------------+----------------+
|    Algorithm    | Exec Policy | Binary-Op |  Type  |    Time    |     Result     |
+-----------------+-------------+-----------+--------+------------+----------------+
| std::accumulate |   Serial    |     +     | double | 151,861 us |  10,000,000.7  |
+-----------------+-------------+-----------+--------+------------+----------------+
|   std::reduce   | Sequencial  |     +     | double |  76,011 us |  10,000,000.7  |
+-----------------+-------------+-----------+--------+------------+----------------+
|   std::reduce   |  Parallel   |     +     | double |  21,098 us |  10,000,000.7  |
+-----------------+-------------+-----------+--------+------------+----------------+
|   std::reduce   | Unsequenced |     +     | double | 135,906 us |  10,000,000.7  |
+-----------------+-------------+-----------+--------+------------+----------------+
|   std::reduce   |  Par-Unseq  |     +     | double |  23,752 us |  10,000,000.7  |
+-----------------+-------------+-----------+--------+------------+----------------+
</code></pre>
<p><a href="./examples/par-algs/src/reduce.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/reduce"><code>std::reduce</code></a></p>
<h3 id="transform-reduce"><a class="header" href="#transform-reduce">Transform Reduce</a></h3>
<p><code>std::transform_reduce</code> is akin to <code>std::inner_product</code> performing the same default unary transformation (<code>*</code>) and reduction (<code>+</code>). Takes an initial value that is used as the base accumulator.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;execution&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

template &lt;typename time_t = std::chrono::microseconds&gt;
struct measure
{
    template &lt;typename F, typename... Args&gt;
    static auto execution(F func, Args&amp;&amp;... args) 
        -&gt; std::pair&lt;typename time_t::rep, std::invoke_result_t&lt;F, Args...&gt;&gt;
    {
        auto start = std::chrono::system_clock::now();
        auto result = std::invoke(func, std::forward&lt;Args&gt;(args)...);
        auto duration = std::chrono::duration_cast&lt;time_t&gt;(std::chrono::system_clock::now() - start);
        return std::pair&lt;typename time_t::rep, std::invoke_result_t&lt;F, Args...&gt;&gt;{ duration.count(), result };
    }
};

auto main() -&gt; int
{
    auto v1 = std::vector&lt;double&gt;(100'000'007, 0.145);
    auto v2 = std::vector&lt;double&gt;(100'000'007, 0.524);
    std::cout.imbue(std::locale(&quot;en_US.UTF-8&quot;));
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(4);
    
    std::cout &lt;&lt; &quot;+-----------------------+-------------+------------+--------+------------+----------------+&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;|       Algorithm       | Exec Policy | Binary-Ops |  Type  |    Time    |     Result     |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------------+-------------+------------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;|  std::inner_product   |   Serial    | (*) -&gt; (+) | double | &quot;;
    auto [in_prod_time, in_prod_result] = measure&lt;&gt;::execution([](const auto&amp; v1, const auto&amp; v2){ return std::inner_product(v1.begin(), v1.end(), v2.begin(), 0.0); }, v1, v2);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; in_prod_time &lt;&lt; &quot; us | &quot; &lt;&lt; in_prod_result &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------------+-------------+------------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_reduce | Sequencial  | (*) -&gt; (+) | double | &quot;;
    auto [seq_time, seq_result] = measure&lt;&gt;::execution([](const auto&amp; v1, const auto&amp; v2){ return std::transform_reduce(std::execution::seq, v1.begin(), v1.end(), v2.begin(), 0.0); }, v1, v2);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; seq_time &lt;&lt; &quot; us | &quot; &lt;&lt; seq_result &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------------+-------------+------------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_reduce |  Parallel   | (*) -&gt; (+) | double | &quot;;
    auto [par_time, par_result] = measure&lt;&gt;::execution([](const auto&amp; v1, const auto&amp; v2){ return std::transform_reduce(std::execution::par, v1.begin(), v1.end(), v2.begin(), 0.0); }, v1, v2);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_time &lt;&lt; &quot; us | &quot; &lt;&lt; par_result &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------------+-------------+------------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_reduce | Unsequenced | (*) -&gt; (+) | double | &quot;;
    auto [unseq_time, unseq_result] = measure&lt;&gt;::execution([](const auto&amp; v1, const auto&amp; v2){ return std::transform_reduce(std::execution::unseq, v1.begin(), v1.end(), v2.begin(), 0.0); }, v1, v2);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; unseq_result &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------------+-------------+------------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_reduce |  Par-Unseq  | (*) -&gt; (+) | double | &quot;;
    auto [par_unseq_time, par_unseq_result] = measure&lt;&gt;::execution([](const auto&amp; v1, const auto&amp; v2){ return std::transform_reduce(std::execution::par_unseq, v1.begin(), v1.end(), v2.begin(), 0.0); }, v1, v2);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; par_unseq_result &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+-----------------------+-------------+------------+--------+------------+----------------+&quot; &lt;&lt; std::endl;

    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

./build/transform_reduce
+-----------------------+-------------+------------+--------+------------+----------------+
|       Algorithm       | Exec Policy | Binary-Ops |  Type  |    Time    |     Result     |
+-----------------------+-------------+------------+--------+------------+----------------+
|  std::inner_product   |   Serial    | (*) -&gt; (+) | double | 144,255 us | 7,598,000.5455 |
+-----------------------+-------------+------------+--------+------------+----------------+
| std::transform_reduce | Sequencial  | (*) -&gt; (+) | double | 119,467 us | 7,598,000.5455 |
+-----------------------+-------------+------------+--------+------------+----------------+
| std::transform_reduce |  Parallel   | (*) -&gt; (+) | double |  53,172 us | 7,598,000.5318 |
+-----------------------+-------------+------------+--------+------------+----------------+
| std::transform_reduce | Unsequenced | (*) -&gt; (+) | double | 131,677 us | 7,598,000.5455 |
+-----------------------+-------------+------------+--------+------------+----------------+
| std::transform_reduce |  Par-Unseq  | (*) -&gt; (+) | double |  51,095 us | 7,598,000.5319 |
+-----------------------+-------------+------------+--------+------------+----------------+
</code></pre>
<p><a href="./examples/par-algs/src/transform_reduce.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/transform_reduce"><code>std::transform_reduce</code></a></p>
<h3 id="exclusive-scan"><a class="header" href="#exclusive-scan">Exclusive Scan</a></h3>
<p><code>std::exclusive_scan</code> is akin to <code>std::partial_sum</code> except is takes in an initial value and excludes the \( ith \) input element from the \( ith \) sum (reduction).</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;execution&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

template &lt;typename time_t = std::chrono::microseconds&gt;
struct measure
{
    template &lt;typename F, typename... Args&gt;
    static auto execution(F func, Args&amp;&amp;... args) 
        -&gt; typename time_t::rep
    {
        auto start = std::chrono::system_clock::now();
        std::invoke(func, std::forward&lt;Args&gt;(args)...);
        auto duration = std::chrono::duration_cast&lt;time_t&gt;(std::chrono::system_clock::now() - start);
        return duration.count();
    }
};

template&lt;typename T&gt;
auto operator&lt;&lt; 
(std::ostream&amp; os, const std::vector&lt;T&gt;&amp; v) -&gt; std::ostream&amp;
{
    os &lt;&lt; &quot;[ &quot;;
    for (auto i { v.size() }; const auto&amp; e : v)
        if (--i &gt; (v.size() - 3))
            os &lt;&lt; e &lt;&lt; &quot;, &quot;;

    auto last = v.end() - 3;
    os &lt;&lt; &quot;..., &quot; &lt;&lt; *++last &lt;&lt; &quot;, &quot;;
    os &lt;&lt; *++last &lt;&lt; &quot; ]&quot;;
    return os;
}

auto main() -&gt; int
{
    auto v = std::vector&lt;double&gt;(100'000'007, 0.1);
    auto r = std::vector&lt;double&gt;(100'000'007, 0.0);
    std::cout.imbue(std::locale(&quot;en_US.UTF-8&quot;));
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1);
    
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;|      Algorithm      | Exec Policy | Binary-Op |  Type  |    Time    |                    Result                     |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;|  std::partial_sum   |   Serial    |     +     | double | &quot;;
    auto scan_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::partial_sum(v.begin(), v.end(), r.begin()); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; scan_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::exclusive_scan | Sequencial  |     +     | double | &quot;;
    auto seq_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::exclusive_scan(std::execution::seq, v.begin(), v.end(), r.begin(), 0.0); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; seq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::exclusive_scan |  Parallel   |     +     | double | &quot;;
    auto par_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::exclusive_scan(std::execution::par, v.begin(), v.end(), r.begin(), 0.0); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::exclusive_scan | Unsequenced |     +     | double | &quot;;
    auto unseq_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::exclusive_scan(std::execution::unseq, v.begin(), v.end(), r.begin(), 0.0); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::exclusive_scan |  Par-Unseq  |     +     | double | &quot;;
    auto par_unseq_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::exclusive_scan(std::execution::par_unseq, v.begin(), v.end(), r.begin(), 0.0); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

./build/exclusive_scan
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
|      Algorithm      | Exec Policy | Binary-Op |  Type  |    Time    |                    Result                     |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
|  std::partial_sum   |   Serial    |     +     | double | 119,096 us | [ 0.1, 0.2, ..., 10,000,000.6, 10,000,000.7 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
| std::exclusive_scan | Sequencial  |     +     | double | 143,338 us | [ 0.0, 0.1, ..., 10,000,000.5, 10,000,000.6 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
| std::exclusive_scan |  Parallel   |     +     | double | 146,967 us | [ 0.0, 0.1, ..., 10,000,000.5, 10,000,000.6 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
| std::exclusive_scan | Unsequenced |     +     | double | 140,900 us | [ 0.0, 0.1, ..., 10,000,000.5, 10,000,000.6 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
| std::exclusive_scan |  Par-Unseq  |     +     | double | 145,098 us | [ 0.0, 0.1, ..., 10,000,000.5, 10,000,000.6 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
</code></pre>
<p><a href="./examples/par-algs/src/exclusive_scan.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/exclusive_scan"><code>std::exclusive_scan</code></a></p>
<h3 id="inclusive-scan"><a class="header" href="#inclusive-scan">Inclusive Scan</a></h3>
<p><code>std::inclusive_scan</code> is identical to <code>std::partial_sum</code>. It does not take an initial value and unlike <code>std::exclusive_scan</code> includes the \( ith \) element from the input range in the \( ith \) reduction.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;execution&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

template &lt;typename time_t = std::chrono::microseconds&gt;
struct measure
{
    template &lt;typename F, typename... Args&gt;
    static auto execution(F func, Args&amp;&amp;... args) 
        -&gt; typename time_t::rep
    {
        auto start = std::chrono::system_clock::now();
        std::invoke(func, std::forward&lt;Args&gt;(args)...);
        auto duration = std::chrono::duration_cast&lt;time_t&gt;(std::chrono::system_clock::now() - start);
        return duration.count();
    }
};

template&lt;typename T&gt;
auto operator&lt;&lt; 
(std::ostream&amp; os, const std::vector&lt;T&gt;&amp; v) -&gt; std::ostream&amp;
{
    os &lt;&lt; &quot;[ &quot;;
    for (auto i { v.size() }; const auto&amp; e : v)
        if (--i &gt; (v.size() - 3))
            os &lt;&lt; e &lt;&lt; &quot;, &quot;;

    auto last = v.end() - 3;
    os &lt;&lt; &quot;..., &quot; &lt;&lt; *++last &lt;&lt; &quot;, &quot;;
    os &lt;&lt; *++last &lt;&lt; &quot; ]&quot;;
    return os;
}

auto main() -&gt; int
{
    auto v = std::vector&lt;double&gt;(100'000'007, 0.1);
    auto r = std::vector&lt;double&gt;(100'000'007);
    std::cout.imbue(std::locale(&quot;en_US.UTF-8&quot;));
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1);
    
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;|      Algorithm      | Exec Policy | Binary-Op |  Type  |    Time    |                    Result                     |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;|  std::partial_sum   |   Serial    |     +     | double | &quot;;
    auto scan_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::partial_sum(v.begin(), v.end(), r.begin()); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; scan_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::inclusive_scan | Sequencial  |     +     | double | &quot;;
    auto seq_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::inclusive_scan(std::execution::seq, v.begin(), v.end(), r.begin()); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; seq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::inclusive_scan |  Parallel   |     +     | double | &quot;;
    auto par_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::inclusive_scan(std::execution::par, v.begin(), v.end(), r.begin()); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::inclusive_scan | Unsequenced |     +     | double | &quot;;
    auto unseq_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::inclusive_scan(std::execution::unseq, v.begin(), v.end(), r.begin()); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::inclusive_scan |  Par-Unseq  |     +     | double | &quot;;
    auto par_unseq_time = measure&lt;&gt;::execution([](const auto&amp; v, auto&amp; r){ std::inclusive_scan(std::execution::par_unseq, v.begin(), v.end(), r.begin()); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

./build/inclusive_scan
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
|      Algorithm      | Exec Policy | Binary-Op |  Type  |    Time    |                    Result                     |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
|  std::partial_sum   |   Serial    |     +     | double | 121,801 us | [ 0.1, 0.2, ..., 10,000,000.6, 10,000,000.7 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
| std::inclusive_scan | Sequencial  |     +     | double | 120,705 us | [ 0.1, 0.2, ..., 10,000,000.6, 10,000,000.7 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
| std::inclusive_scan |  Parallel   |     +     | double | 150,662 us | [ 0.1, 0.2, ..., 10,000,000.6, 10,000,000.7 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
| std::inclusive_scan | Unsequenced |     +     | double | 120,440 us | [ 0.1, 0.2, ..., 10,000,000.6, 10,000,000.7 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
| std::inclusive_scan |  Par-Unseq  |     +     | double | 145,441 us | [ 0.1, 0.2, ..., 10,000,000.6, 10,000,000.7 ] |
+---------------------+-------------+-----------+--------+------------+-----------------------------------------------+
</code></pre>
<p><a href="./examples/par-algs/src/inclusive_scan.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/inclusive_scan"><code>std::inclusive_scan</code></a></p>
<h3 id="transform-exclusive-scan"><a class="header" href="#transform-exclusive-scan">Transform Exclusive Scan</a></h3>
<p><code>std::transform_exclusive_scan</code> will perform a unary transformation and then performs a left exclusive scan on a range.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;execution&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

template &lt;typename time_t = std::chrono::microseconds&gt;
struct measure
{
    template &lt;typename F, typename... Args&gt;
    static auto execution(F func, Args&amp;&amp;... args) 
        -&gt; typename time_t::rep
    {
        auto start = std::chrono::system_clock::now();
        std::invoke(func, std::forward&lt;Args&gt;(args)...);
        auto duration = std::chrono::duration_cast&lt;time_t&gt;(std::chrono::system_clock::now() - start);
        return duration.count();
    }
};

template&lt;typename T&gt;
auto operator&lt;&lt; 
(std::ostream&amp; os, const std::vector&lt;T&gt;&amp; v) -&gt; std::ostream&amp;
{
    os &lt;&lt; &quot;[ &quot;;
    for (auto i { v.size() }; const auto&amp; e : v)
        if (--i &gt; (v.size() - 3))
            os &lt;&lt; e &lt;&lt; &quot;, &quot;;

    auto last = v.end() - 3;
    os &lt;&lt; &quot;..., &quot; &lt;&lt; *++last &lt;&lt; &quot;, &quot;;
    os &lt;&lt; *++last &lt;&lt; &quot; ]&quot;;
    return os;
}

auto main() -&gt; int
{
    auto v = std::vector&lt;double&gt;(100'000'007, 0.1);
    auto r = std::vector&lt;double&gt;(100'000'007, 0.0);
    auto times2 = [](const auto&amp; x){ return x * 2; };
    std::cout.imbue(std::locale(&quot;en_US.UTF-8&quot;));
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1);
    
    std::cout &lt;&lt; &quot;+-------------------------------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;|           Algorithm           | Exec Policy | Operations  |  Type  |    Time    |                    Result                     |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_inclusive_scan | Sequencial  | (*2) -&gt; (+) | double | &quot;;
    auto seq_time = measure&lt;&gt;::execution([&amp;](const auto&amp; v, auto&amp; r){  std::transform_inclusive_scan(std::execution::seq, v.begin(), v.end(), r.begin(), std::plus&lt;&gt;{}, times2, 0.0); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; seq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_inclusive_scan |  Parallel   | (*2) -&gt; (+) | double | &quot;;
    auto par_time = measure&lt;&gt;::execution([&amp;](const auto&amp; v, auto&amp; r){  std::transform_inclusive_scan(std::execution::par, v.begin(), v.end(), r.begin(), std::plus&lt;&gt;{}, times2, 0.0); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_inclusive_scan | Unsequenced | (*2) -&gt; (+) | double | &quot;;
    auto unseq_time = measure&lt;&gt;::execution([&amp;](const auto&amp; v, auto&amp; r){  std::transform_inclusive_scan(std::execution::unseq, v.begin(), v.end(), r.begin(), std::plus&lt;&gt;{}, times2, 0.0); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_inclusive_scan |  Par-Unseq  | (*2) -&gt; (+) | double | &quot;;
    auto par_unseq_time = measure&lt;&gt;::execution([&amp;](const auto&amp; v, auto&amp; r){  std::transform_inclusive_scan(std::execution::par_unseq, v.begin(), v.end(), r.begin(), std::plus&lt;&gt;{}, times2, 0.0); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

./build/transform_exclusive_scan
+-------------------------------+-------------+-------------+--------+------------+-----------------------------------------------+
|           Algorithm           | Exec Policy | Operations  |  Type  |    Time    |                    Result                     |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
| std::transform_exclusive_scan | Sequencial  | (*2) -&gt; (+) | double | 125,675 us | [ 0.0, 0.2, ..., 20,000,001.0, 20,000,001.2 ] |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
| std::transform_exclusive_scan |  Parallel   | (*2) -&gt; (+) | double | 150,095 us | [ 0.0, 0.2, ..., 20,000,001.0, 20,000,001.2 ] |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
| std::transform_exclusive_scan | Unsequenced | (*2) -&gt; (+) | double | 167,813 us | [ 0.0, 0.2, ..., 20,000,001.0, 20,000,001.2 ] |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
| std::transform_exclusive_scan |  Par-Unseq  | (*2) -&gt; (+) | double | 146,167 us | [ 0.0, 0.2, ..., 20,000,001.0, 20,000,001.2 ] |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
</code></pre>
<p><a href="./examples/par-algs/src/transform_exclusive_scan.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/transform_exclusive_scan"><code>std::transform_exclusive_scan</code></a></p>
<h3 id="transform-inclusive-scan"><a class="header" href="#transform-inclusive-scan">Transform Inclusive Scan</a></h3>
<p><code>std::transform_inclusive_scan</code> will perform a unary transformation and then performs a left inclusive scan on a range.</p>
<pre><code class="language-cxx">#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;execution&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

template &lt;typename time_t = std::chrono::microseconds&gt;
struct measure
{
    template &lt;typename F, typename... Args&gt;
    static auto execution(F func, Args&amp;&amp;... args) 
        -&gt; typename time_t::rep
    {
        auto start = std::chrono::system_clock::now();
        std::invoke(func, std::forward&lt;Args&gt;(args)...);
        auto duration = std::chrono::duration_cast&lt;time_t&gt;(std::chrono::system_clock::now() - start);
        return duration.count();
    }
};

template&lt;typename T&gt;
auto operator&lt;&lt; 
(std::ostream&amp; os, const std::vector&lt;T&gt;&amp; v) -&gt; std::ostream&amp;
{
    os &lt;&lt; &quot;[ &quot;;
    for (auto i { v.size() }; const auto&amp; e : v)
        if (--i &gt; (v.size() - 3))
            os &lt;&lt; e &lt;&lt; &quot;, &quot;;

    auto last = v.end() - 3;
    os &lt;&lt; &quot;..., &quot; &lt;&lt; *++last &lt;&lt; &quot;, &quot;;
    os &lt;&lt; *++last &lt;&lt; &quot; ]&quot;;
    return os;
}

auto main() -&gt; int
{
    auto v = std::vector&lt;double&gt;(100'000'007, 0.1);
    auto r = std::vector&lt;double&gt;(100'000'007, 0.0);
    auto times2 = [](const auto&amp; x){ return x * 2; };
    std::cout.imbue(std::locale(&quot;en_US.UTF-8&quot;));
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1);
    
    std::cout &lt;&lt; &quot;+-------------------------------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;|           Algorithm           | Exec Policy | Operations  |  Type  |    Time    |                    Result                     |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_exclusive_scan | Sequencial  | (*2) -&gt; (+) | double | &quot;;
    auto seq_time = measure&lt;&gt;::execution([&amp;](const auto&amp; v, auto&amp; r){  std::transform_exclusive_scan(std::execution::seq, v.begin(), v.end(), r.begin(), 0.0, std::plus&lt;&gt;{}, times2); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; seq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_exclusive_scan |  Parallel   | (*2) -&gt; (+) | double | &quot;;
    auto par_time = measure&lt;&gt;::execution([&amp;](const auto&amp; v, auto&amp; r){  std::transform_exclusive_scan(std::execution::par, v.begin(), v.end(), r.begin(), 0.0, std::plus&lt;&gt;{}, times2); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_exclusive_scan | Unsequenced | (*2) -&gt; (+) | double | &quot;;
    auto unseq_time = measure&lt;&gt;::execution([&amp;](const auto&amp; v, auto&amp; r){  std::transform_exclusive_scan(std::execution::unseq, v.begin(), v.end(), r.begin(), 0.0, std::plus&lt;&gt;{}, times2); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;| std::transform_exclusive_scan |  Par-Unseq  | (*2) -&gt; (+) | double | &quot;;
    auto par_unseq_time = measure&lt;&gt;::execution([&amp;](const auto&amp; v, auto&amp; r){  std::transform_exclusive_scan(std::execution::par_unseq, v.begin(), v.end(), r.begin(), 0.0, std::plus&lt;&gt;{}, times2); }, v, r);
    std::cout &lt;&lt; std::setw(7) &lt;&lt; par_unseq_time &lt;&lt; &quot; us | &quot; &lt;&lt; r &lt;&lt; &quot; |&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+&quot; &lt;&lt; std::endl;
    
    return 0;
}
</code></pre>
<pre><code class="language-sh">$ bpt build -t build.yaml -o build

# ...

./build/transform_inclusive_scan
+-------------------------------+-------------+-------------+--------+------------+-----------------------------------------------+
|           Algorithm           | Exec Policy | Operations  |  Type  |    Time    |                    Result                     |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
| std::transform_inclusive_scan | Sequencial  | (*2) -&gt; (+) | double | 120,220 us | [ 0.2, 0.4, ..., 20,000,001.2, 20,000,001.4 ] |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
| std::transform_inclusive_scan |  Parallel   | (*2) -&gt; (+) | double | 148,472 us | [ 0.2, 0.4, ..., 20,000,001.2, 20,000,001.4 ] |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
| std::transform_inclusive_scan | Unsequenced | (*2) -&gt; (+) | double | 135,489 us | [ 0.2, 0.4, ..., 20,000,001.2, 20,000,001.4 ] |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
| std::transform_inclusive_scan |  Par-Unseq  | (*2) -&gt; (+) | double | 150,443 us | [ 0.2, 0.4, ..., 20,000,001.2, 20,000,001.4 ] |
+--------------------+----------+-------------+-------------+--------+------------+-----------------------------------------------+
</code></pre>
<p><a href="./examples/par-algs/src/transform_inclusive_scan.main.cxx">Example</a></p>
<p><a href="https://en.cppreference.com/w/cpp/algorithm/transform_inclusive_scan"><code>std::transform_inclusive_scan</code></a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter7/chapter7.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../chapter7/atomics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter7/chapter7.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../chapter7/atomics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
